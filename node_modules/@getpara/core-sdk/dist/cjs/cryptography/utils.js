var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var utils_exports = {};
__export(utils_exports, {
  decodePrivateKeyPemHex: () => decodePrivateKeyPemHex,
  decryptPrivateKey: () => decryptPrivateKey,
  decryptPrivateKeyAndDecryptShare: () => decryptPrivateKeyAndDecryptShare,
  decryptPrivateKeyWithPassword: () => decryptPrivateKeyWithPassword,
  decryptWithKeyPair: () => decryptWithKeyPair,
  decryptWithPrivateKey: () => decryptWithPrivateKey,
  encodePrivateKeyToPemHex: () => encodePrivateKeyToPemHex,
  encryptPrivateKey: () => encryptPrivateKey,
  encryptPrivateKeyWithPassword: () => encryptPrivateKeyWithPassword,
  encryptWithDerivedPublicKey: () => encryptWithDerivedPublicKey,
  getAsymmetricKeyPair: () => getAsymmetricKeyPair,
  getDerivedPrivateKeyAndDecrypt: () => getDerivedPrivateKeyAndDecrypt,
  getPublicKeyFromSignature: () => getPublicKeyFromSignature,
  getPublicKeyHex: () => getPublicKeyHex,
  getSHA256HashHex: () => getSHA256HashHex,
  hashPasswordWithSalt: () => hashPasswordWithSalt,
  publicKeyFromHex: () => publicKeyFromHex,
  publicKeyHexToPem: () => publicKeyHexToPem,
  symmetricKeyEncryptMessage: () => symmetricKeyEncryptMessage
});
module.exports = __toCommonJS(utils_exports);
var import_base64url = __toESM(require("base64url"));
var import_node_forge = __toESM(require("node-forge"));
var import_utils = require("../utils/index.js");
const rsa = import_node_forge.default.pki.rsa;
const RSA_ENCRYPTION_SCHEME = "RSA-OAEP";
const CONSTANT_IV = "794241bc819a125a7b78ea313decc0bc";
const CONSTANT_IV_AES = new Uint8Array([23, 66, 157, 146, 179, 158, 117, 120, 184, 73, 123, 81]);
function getSHA256HashHex(str) {
  const md = import_node_forge.default.md.sha256.create();
  md.update(str);
  return md.digest().toHex();
}
function getPublicKeyHex(keyPair) {
  const pem = import_node_forge.default.pki.publicKeyToRSAPublicKeyPem(keyPair.publicKey);
  return Buffer.from(pem, "utf-8").toString("hex");
}
function publicKeyFromHex(publicKeyHex) {
  const pem = publicKeyHexToPem(publicKeyHex);
  return import_node_forge.default.pki.publicKeyFromPem(pem);
}
function publicKeyHexToPem(publicKeyHex) {
  return Buffer.from(publicKeyHex, "hex").toString("utf-8");
}
function encodePrivateKeyToPemHex(keyPair) {
  const pem = import_node_forge.default.pki.privateKeyToPem(keyPair.privateKey);
  return Buffer.from(pem, "utf-8").toString("hex");
}
function decodePrivateKeyPemHex(privateKeyPemHex) {
  const pem = Buffer.from(privateKeyPemHex, "hex").toString("utf-8");
  return import_node_forge.default.pki.privateKeyFromPem(pem);
}
function encryptPrivateKey(keyPair, key) {
  return __async(this, null, function* () {
    const privateKeyPemHex = encodePrivateKeyToPemHex(keyPair);
    const cryptoKey = yield window.crypto.subtle.importKey(
      "raw",
      Buffer.from(key, "base64"),
      {
        name: "AES-GCM",
        length: 256
      },
      true,
      ["encrypt", "decrypt"]
    );
    const encodedPlaintext = new TextEncoder().encode(privateKeyPemHex);
    const ciphertext = yield window.crypto.subtle.encrypt(
      { name: "AES-GCM", iv: CONSTANT_IV_AES },
      cryptoKey,
      encodedPlaintext
    );
    return Buffer.from(ciphertext).toString("base64");
  });
}
function decryptPrivateKey(encryptedPrivateKeyPemHex, key) {
  return __async(this, null, function* () {
    const secretKey = yield crypto.subtle.importKey(
      "raw",
      Buffer.from(key, "base64"),
      {
        name: "AES-GCM",
        length: 256
      },
      true,
      ["encrypt", "decrypt"]
    );
    const cleartext = yield crypto.subtle.decrypt(
      { name: "AES-GCM", iv: CONSTANT_IV_AES },
      secretKey,
      Buffer.from(encryptedPrivateKeyPemHex, "base64")
    );
    const privateKeyPemHex = new TextDecoder().decode(cleartext);
    const privateKey = decodePrivateKeyPemHex(privateKeyPemHex);
    return privateKey;
  });
}
function getAsymmetricKeyPair(ctx, seedValue) {
  return __async(this, null, function* () {
    const prng = import_node_forge.default.random.createInstance();
    if (seedValue) {
      prng.seedFileSync = (_n) => seedValue;
      prng.seedFile = (_n, cb) => {
        cb(null, seedValue);
      };
    }
    const options = {
      bits: 2048,
      e: 65537,
      prng
    };
    if (!ctx.disableWorkers) {
      options.workLoad = 100;
      options.workers = seedValue ? 1 : -1;
      const workerRes = yield fetch(`${(0, import_utils.getPortalBaseURL)(ctx)}/static/js/prime.worker.min.js`);
      const workerBlob = new Blob([yield workerRes.text()], { type: "application/javascript" });
      options.workerScript = URL.createObjectURL(workerBlob);
    }
    return new Promise(
      (resolve, reject) => rsa.generateKeyPair(options, (err, keypair) => {
        if (err) {
          reject(err);
        }
        resolve(keypair);
      })
    );
  });
}
function getPublicKeyFromSignature(ctx, userHandle) {
  return __async(this, null, function* () {
    const encodedUserHandle = import_base64url.default.encode(userHandle);
    const keyPair = yield getAsymmetricKeyPair(ctx, encodedUserHandle);
    return getPublicKeyHex(keyPair);
  });
}
function symmetricKeyEncryptMessage(message) {
  const key = import_node_forge.default.random.getBytesSync(16);
  const cipher = import_node_forge.default.cipher.createCipher("AES-CBC", key);
  cipher.start({ iv: CONSTANT_IV });
  cipher.update(import_node_forge.default.util.createBuffer(message));
  cipher.finish();
  const encryptedMessageHex = cipher.output.toHex();
  return { key, encryptedMessageHex };
}
function decipherEncryptedMessageHex(key, encryptedMessageHex) {
  const decipher = import_node_forge.default.cipher.createDecipher("AES-CBC", key);
  decipher.start({ iv: CONSTANT_IV });
  decipher.update(import_node_forge.default.util.createBuffer(import_node_forge.default.util.hexToBytes(encryptedMessageHex)));
  decipher.finish();
  return decipher.output.toString();
}
function decryptWithKeyPair(keyPair, encryptedMessageHex, encryptedKeyHex) {
  const encryptedKey = Buffer.from(encryptedKeyHex, "hex").toString("utf-8");
  const key = keyPair.privateKey.decrypt(encryptedKey, RSA_ENCRYPTION_SCHEME);
  return decipherEncryptedMessageHex(key, encryptedMessageHex);
}
function decryptWithPrivateKey(privateKey, encryptedMessageHex, encryptedKeyHex) {
  const encryptedKey = Buffer.from(encryptedKeyHex, "hex").toString("utf-8");
  const key = privateKey.decrypt(encryptedKey, RSA_ENCRYPTION_SCHEME);
  return decipherEncryptedMessageHex(key, encryptedMessageHex);
}
function decryptWithDerivedPrivateKey(_0, _1) {
  return __async(this, arguments, function* (ctx, {
    seedValue,
    encryptedMessageHex,
    encryptedKeyHex
  }) {
    const keyPair = yield getAsymmetricKeyPair(ctx, seedValue);
    return decryptWithPrivateKey(keyPair.privateKey, encryptedMessageHex, encryptedKeyHex);
  });
}
function getDerivedPrivateKeyAndDecrypt(ctx, seedValue, encryptedShares) {
  return __async(this, null, function* () {
    return Promise.all(
      encryptedShares.map((share) => __async(this, null, function* () {
        return {
          walletId: share.walletId,
          walletScheme: share.walletScheme,
          partnerId: share.partnerId,
          signer: yield decryptWithDerivedPrivateKey(ctx, {
            seedValue,
            encryptedMessageHex: share.encryptedShare,
            encryptedKeyHex: share.encryptedKey
          }),
          protocolId: share.protocolId
        };
      }))
    );
  });
}
function decryptPrivateKeyAndDecryptShare(encryptionKey, encryptedShares, encryptedPrivateKey) {
  return __async(this, null, function* () {
    let privateKey;
    try {
      privateKey = yield decryptPrivateKey(encryptedPrivateKey, encryptionKey);
    } catch (e) {
    }
    try {
      privateKey = yield decryptPrivateKeyWithPassword(encryptedPrivateKey, encryptionKey);
    } catch (e) {
    }
    if (!privateKey) {
      throw new Error("Could not decrypt private key");
    }
    return encryptedShares.map((share) => ({
      walletId: share.walletId,
      walletScheme: share.walletScheme,
      partnerId: share.partnerId,
      signer: decryptWithPrivateKey(privateKey, share.encryptedShare, share.encryptedKey),
      protocolId: share.protocolId
    }));
  });
}
function encryptWithDerivedPublicKey(publicKeyHex, message) {
  const { key, encryptedMessageHex } = symmetricKeyEncryptMessage(message);
  const publicKeyPem = publicKeyHexToPem(publicKeyHex);
  const publicKey = import_node_forge.default.pki.publicKeyFromPem(publicKeyPem);
  const encryptedKey = publicKey.encrypt(key, RSA_ENCRYPTION_SCHEME);
  const encryptedKeyHex = Buffer.from(encryptedKey, "utf-8").toString("hex");
  return { encryptedMessageHex, encryptedKeyHex };
}
function hashPasswordWithSalt(password) {
  const salt = generateSalt();
  const saltedPassword = salt + password;
  const hash = getSHA256HashHex(saltedPassword);
  return { salt, hash };
}
function generateSalt(length = 16) {
  return import_node_forge.default.util.bytesToHex(import_node_forge.default.random.getBytesSync(length));
}
function deriveCryptoKeyFromPassword(hashedPassword) {
  return __async(this, null, function* () {
    const keyBuffer = Buffer.from(hashedPassword, "hex");
    return yield window.crypto.subtle.importKey(
      "raw",
      keyBuffer,
      {
        name: "AES-GCM",
        length: 256
      },
      true,
      ["encrypt", "decrypt"]
    );
  });
}
function encryptPrivateKeyWithPassword(keyPair, hashedPassword) {
  return __async(this, null, function* () {
    const cryptoKey = yield deriveCryptoKeyFromPassword(hashedPassword);
    const privateKeyPemHex = encodePrivateKeyToPemHex(keyPair);
    const encodedPlaintext = new TextEncoder().encode(privateKeyPemHex);
    const ciphertext = yield window.crypto.subtle.encrypt(
      { name: "AES-GCM", iv: CONSTANT_IV_AES },
      cryptoKey,
      encodedPlaintext
    );
    return Buffer.from(ciphertext).toString("base64");
  });
}
function decryptPrivateKeyWithPassword(encryptedPrivateKeyPemHex, hashedPassword) {
  return __async(this, null, function* () {
    const secretKey = yield crypto.subtle.importKey(
      "raw",
      Buffer.from(hashedPassword, "hex"),
      {
        name: "AES-GCM",
        length: 256
      },
      true,
      ["encrypt", "decrypt"]
    );
    const cleartext = yield crypto.subtle.decrypt(
      { name: "AES-GCM", iv: CONSTANT_IV_AES },
      secretKey,
      Buffer.from(encryptedPrivateKeyPemHex, "base64")
    );
    const privateKeyPemHex = new TextDecoder().decode(cleartext);
    const privateKey = decodePrivateKeyPemHex(privateKeyPemHex);
    return privateKey;
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  decodePrivateKeyPemHex,
  decryptPrivateKey,
  decryptPrivateKeyAndDecryptShare,
  decryptPrivateKeyWithPassword,
  decryptWithKeyPair,
  decryptWithPrivateKey,
  encodePrivateKeyToPemHex,
  encryptPrivateKey,
  encryptPrivateKeyWithPassword,
  encryptWithDerivedPublicKey,
  getAsymmetricKeyPair,
  getDerivedPrivateKeyAndDecrypt,
  getPublicKeyFromSignature,
  getPublicKeyHex,
  getSHA256HashHex,
  hashPasswordWithSalt,
  publicKeyFromHex,
  publicKeyHexToPem,
  symmetricKeyEncryptMessage
});

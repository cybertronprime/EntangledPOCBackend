var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var wallet_exports = {};
__export(wallet_exports, {
  WalletSchemeTypeMap: () => WalletSchemeTypeMap,
  entityToWallet: () => entityToWallet,
  getEquivalentTypes: () => getEquivalentTypes,
  getSchemes: () => getSchemes,
  getWalletTypes: () => getWalletTypes,
  isPregenIdentifierMatch: () => isPregenIdentifierMatch,
  isWalletSupported: () => isWalletSupported,
  mergeCurrentWalletIds: () => mergeCurrentWalletIds,
  migrateWallet: () => migrateWallet,
  newUuid: () => newUuid,
  supportedWalletTypesEq: () => supportedWalletTypesEq
});
module.exports = __toCommonJS(wallet_exports);
var uuid = __toESM(require("uuid"));
var import_phone = require("./phone.js");
const WalletSchemeTypeMap = {
  DKLS: {
    EVM: true,
    COSMOS: true
  },
  CGGMP: {
    EVM: true,
    COSMOS: true
  },
  ED25519: {
    SOLANA: true
  }
};
function isPregenIdentifierMatch(a, b, type) {
  if (!a || !b) {
    return false;
  }
  switch (type) {
    case "EMAIL":
      return a.toLowerCase() === b.toLowerCase();
    case "PHONE":
      return (0, import_phone.formatPhoneNumber)(a) === (0, import_phone.formatPhoneNumber)(b);
    case "CUSTOM_ID":
      return a === b;
    default:
      return a.replace(/^@/g, "").toLowerCase() === b.replace(/^@/g, "").toLowerCase();
  }
}
function isWalletSupported(types, wallet) {
  return types.some((walletType) => {
    var _a;
    return !!((_a = WalletSchemeTypeMap[wallet == null ? void 0 : wallet.scheme]) == null ? void 0 : _a[walletType]);
  });
}
function getSchemes(types) {
  return Object.keys(WalletSchemeTypeMap).filter((scheme) => {
    if (scheme === "CGGMP") {
      return false;
    }
    return (Array.isArray(types) ? types : Object.keys(types)).some((type) => WalletSchemeTypeMap[scheme][type]);
  });
}
function getWalletTypes(schemes) {
  return [
    ...new Set(
      schemes.reduce((acc, scheme) => {
        return [...acc, ...Object.keys(WalletSchemeTypeMap[scheme]).filter((type) => WalletSchemeTypeMap[scheme][type])];
      }, [])
    )
  ];
}
function getEquivalentTypes(types) {
  return getWalletTypes(getSchemes(Array.isArray(types) ? types : [types]));
}
function entityToWallet(w) {
  return __spreadProps(__spreadValues({}, w), {
    scheme: w.scheme,
    type: w.type,
    pregenIdentifierType: w.pregenIdentifierType
  });
}
function migrateWallet(obj) {
  if (["USER", "PREGEN"].includes(obj.type)) {
    obj.isPregen = obj.type === "PREGEN";
    obj.type = obj.scheme === "ED25519" ? "SOLANA" : "EVM";
  }
  if (!!obj.scheme && !obj.type) {
    obj.type = obj.scheme === "ED25519" ? "SOLANA" : "EVM";
  }
  return obj;
}
function supportedWalletTypesEq(a, b) {
  return a.length === b.length && a.every(({ type, optional }, index) => b[index].type === type && b[index].optional === optional);
}
function mergeCurrentWalletIds(original, additional) {
  return [.../* @__PURE__ */ new Set([...Object.keys(original), ...Object.keys(additional)])].reduce((acc, key) => {
    return __spreadProps(__spreadValues({}, acc), {
      [key]: [.../* @__PURE__ */ new Set([...original[key] || [], ...additional[key] || []])]
    });
  }, {});
}
function newUuid() {
  return uuid.v4();
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  WalletSchemeTypeMap,
  entityToWallet,
  getEquivalentTypes,
  getSchemes,
  getWalletTypes,
  isPregenIdentifierMatch,
  isWalletSupported,
  mergeCurrentWalletIds,
  migrateWallet,
  newUuid,
  supportedWalletTypesEq
});

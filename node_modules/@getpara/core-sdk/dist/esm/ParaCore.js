import {
  __async,
  __objRest,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __spreadProps,
  __spreadValues
} from "./chunk-7B52C2XE.js";
var _authInfo, _ParaCore_instances, assertPartner_fn, guestWalletIds_get, guestWalletIdsArray_get, toAuthInfo_fn, setAuthInfo_fn, getPartner_fn, assertIsLinkingAccount_fn, assertIsLinkingAccountOrStart_fn, getOAuthUrl_fn, createPregenWallet_fn, _isCreateGuestWalletsPending, prepareAuthState_fn, prepareLoginState_fn, prepareSignUpState_fn;
import { Buffer as NodeBuffer } from "buffer";
if (typeof global !== "undefined") {
  global.Buffer = global.Buffer || NodeBuffer;
} else if (typeof window !== "undefined") {
  window.Buffer = window.Buffer || NodeBuffer;
  window.global = window.global || window;
} else {
  self.Buffer = self.Buffer || NodeBuffer;
  self.global = self.global || self;
}
import {
  AuthMethod,
  PublicKeyStatus,
  PublicKeyType,
  PasswordStatus,
  extractAuthInfo,
  isEmail,
  isPhone,
  isFarcaster,
  isTelegram,
  toPregenTypeAndId,
  toPregenIds,
  isExternalWallet,
  WALLET_TYPES,
  LINKED_ACCOUNT_TYPES,
  isPregenAuth
} from "@getpara/user-management-client";
import forge from "node-forge";
const { pki, jsbn } = forge;
import { decryptWithPrivateKey, getAsymmetricKeyPair, getPublicKeyHex } from "./cryptography/utils.js";
import { getBaseOAuthUrl, initClient } from "./external/userManagementClient.js";
import * as mpcComputationClient from "./external/mpcComputationClient.js";
import { distributeNewShare } from "./shares/shareDistribution.js";
import {
  Environment,
  PopupType,
  ParaEvent,
  AccountLinkError
} from "./types/index.js";
import { sendRecoveryForShare } from "./shares/recovery.js";
import {
  autoBind,
  formatPhoneNumber,
  constructUrl,
  dispatchEvent,
  entityToWallet,
  getCosmosAddress,
  getEquivalentTypes,
  getParaConnectBaseUrl,
  getPortalBaseURL,
  getSchemes,
  isPregenIdentifierMatch,
  isWalletSupported,
  jsonParse,
  migrateWallet,
  newUuid,
  setupListeners,
  supportedWalletTypesEq,
  truncateAddress,
  WalletSchemeTypeMap,
  shortenUrl,
  isServerAuthState,
  splitPhoneNumber
} from "./utils/index.js";
import { TransactionReviewDenied, TransactionReviewTimeout } from "./errors.js";
import * as constants from "./constants.js";
const _ParaCore = class _ParaCore {
  constructor(envOrApiKey, apiKeyOrOpts, opts) {
    __privateAdd(this, _ParaCore_instances);
    __privateAdd(this, _authInfo);
    this.isNativePasskey = false;
    this.isReady = false;
    this.accountLinkInProgress = void 0;
    this.isAwaitingAccountCreation = false;
    this.isAwaitingLogin = false;
    this.isAwaitingFarcaster = false;
    this.isAwaitingOAuth = false;
    this.isWorkerInitialized = false;
    /**
     * The IDs of the currently active wallets, for each supported wallet type. Any signer integrations will default to the first viable wallet ID in this dictionary.
     */
    this.currentWalletIds = {};
    /**
     * Wallets associated with the `ParaCore` instance.
     */
    this.externalWallets = {};
    this.onRampPopup = void 0;
    this.localStorageGetItem = (key) => {
      return this.platformUtils.localStorage.get(key);
    };
    this.localStorageSetItem = (key, value) => {
      return this.platformUtils.localStorage.set(key, value);
    };
    this.localStorageRemoveItem = (key) => {
      return this.platformUtils.localStorage.removeItem(key);
    };
    this.sessionStorageGetItem = (key) => {
      return this.platformUtils.sessionStorage.get(key);
    };
    this.sessionStorageSetItem = (key, value) => {
      return this.platformUtils.sessionStorage.set(key, value);
    };
    this.sessionStorageRemoveItem = (key) => {
      return this.platformUtils.sessionStorage.removeItem(key);
    };
    this.retrieveSessionCookie = () => {
      return this.sessionCookie;
    };
    /**
     * Remove all local storage and prefixed session storage.
     * @param {'local' | 'session' | 'secure' | 'all'} type - Type of storage to clear. Defaults to 'all'.
     */
    this.clearStorage = (type = "all") => __async(this, null, function* () {
      const isAll = type === "all";
      if (isAll || type === "local") {
        this.platformUtils.localStorage.clear(constants.PREFIX);
        this.platformUtils.localStorage.clear(constants.PARA_PREFIX);
      }
      if (isAll || type === "session") {
        this.platformUtils.sessionStorage.clear(constants.PREFIX);
        this.platformUtils.sessionStorage.clear(constants.PARA_PREFIX);
      }
      if ((isAll || type === "secure") && this.platformUtils.secureStorage) {
        this.platformUtils.secureStorage.clear(constants.PREFIX);
        this.platformUtils.secureStorage.clear(constants.PARA_PREFIX);
      }
    });
    this.trackError = (methodName, err) => __async(this, null, function* () {
      try {
        yield this.ctx.client.trackError({
          methodName,
          sdkType: this.platformUtils.sdkType,
          userId: this.userId,
          error: {
            name: err.name,
            message: err.message
          }
        });
      } catch (e) {
        console.error("error tracking error:", e);
      }
      throw err;
    });
    this.wrapMethodsWithErrorTracking = (methodNames) => {
      for (const methodName of methodNames) {
        const original = this[methodName];
        if (typeof original === "function") {
          this[methodName] = (...args) => {
            try {
              const result = original.apply(this, args);
              return result instanceof Promise ? result.catch((err) => this.trackError(methodName, err)) : result;
            } catch (err) {
              return this.trackError(methodName, err);
            }
          };
        }
      }
    };
    this.initializeFromStorage = () => {
      this.updateExternalWalletsFromStorage();
      this.updateAuthInfoFromStorage();
      this.updateUserIdFromStorage();
      this.updateWalletsFromStorage();
      this.updateWalletIdsFromStorage();
      this.updateSessionCookieFromStorage();
      this.updateLoginEncryptionKeyPairFromStorage();
    };
    this.updateAuthInfoFromStorage = () => {
      var _a;
      const storageAuthInfo = this.localStorageGetItem(constants.LOCAL_STORAGE_AUTH_INFO) || void 0;
      let authInfo = jsonParse(storageAuthInfo);
      if (!authInfo) {
        const authParams = {
          email: this.localStorageGetItem(constants.LOCAL_STORAGE_EMAIL) || void 0,
          phone: this.localStorageGetItem(constants.LOCAL_STORAGE_PHONE) || void 0,
          countryCode: this.localStorageGetItem(constants.LOCAL_STORAGE_COUNTRY_CODE) || void 0,
          farcasterUsername: this.localStorageGetItem(constants.LOCAL_STORAGE_FARCASTER_USERNAME) || void 0,
          telegramUserId: this.localStorageGetItem(constants.LOCAL_STORAGE_TELEGRAM_USER_ID) || void 0,
          // Using id here since we store the bech32 address for cosmos in the address field of the wallet
          externalWalletAddress: ((_a = this.externalWalletWithParaAuth) == null ? void 0 : _a.id) || void 0
        };
        authInfo = __privateMethod(this, _ParaCore_instances, toAuthInfo_fn).call(this, authParams);
      }
      __privateSet(this, _authInfo, authInfo);
    };
    this.updateUserIdFromStorage = () => {
      this.userId = this.localStorageGetItem(constants.LOCAL_STORAGE_USER_ID) || void 0;
    };
    this.updateWalletsFromStorage = () => __async(this, null, function* () {
      var _a;
      const _currentWalletIds = (_a = this.localStorageGetItem(constants.LOCAL_STORAGE_CURRENT_WALLET_IDS)) != null ? _a : void 0;
      const currentWalletIds = [void 0, null, "undefined"].includes(_currentWalletIds) ? {} : (() => {
        const fromJson = JSON.parse(_currentWalletIds);
        return Array.isArray(fromJson) ? WALLET_TYPES.reduce((acc, type) => {
          const wallet = Object.values(this.wallets).find(
            (w) => fromJson.includes(w.id) && WalletSchemeTypeMap[w.scheme][type]
          );
          return __spreadValues(__spreadValues({}, acc), wallet && !acc[type] ? { [type]: [wallet.id] } : {});
        }, {}) : fromJson;
      })();
      this.setCurrentWalletIds(currentWalletIds);
      const stringWallets = this.platformUtils.secureStorage ? this.platformUtils.secureStorage.get(constants.LOCAL_STORAGE_WALLETS) : this.localStorageGetItem(constants.LOCAL_STORAGE_WALLETS);
      const _wallets = JSON.parse(stringWallets || "{}");
      const stringEd25519Wallets = this.platformUtils.secureStorage ? this.platformUtils.secureStorage.get(constants.LOCAL_STORAGE_ED25519_WALLETS) : this.localStorageGetItem(constants.LOCAL_STORAGE_ED25519_WALLETS);
      const _ed25519Wallets = JSON.parse(stringEd25519Wallets || "{}");
      const wallets = __spreadValues(__spreadValues({}, Object.keys(_wallets).reduce((res, key) => {
        return __spreadProps(__spreadValues({}, res), {
          [key]: migrateWallet(_wallets[key])
        });
      }, {})), Object.keys(_ed25519Wallets).reduce((res, key) => {
        return __spreadValues(__spreadValues({}, res), !res[key] ? { [key]: migrateWallet(_ed25519Wallets[key]) } : {});
      }, {}));
      this.setWallets(wallets);
    });
    this.updateWalletIdsFromStorage = () => {
      var _a;
      const _currentWalletIds = (_a = this.localStorageGetItem(constants.LOCAL_STORAGE_CURRENT_WALLET_IDS)) != null ? _a : void 0;
      const currentWalletIds = [void 0, null, "undefined", "null"].includes(_currentWalletIds) ? {} : (() => {
        const fromJson = JSON.parse(_currentWalletIds);
        return Array.isArray(fromJson) ? WALLET_TYPES.reduce((acc, type) => {
          const wallet = Object.values(this.wallets).find(
            (w) => fromJson.includes(w.id) && WalletSchemeTypeMap[w.scheme][type]
          );
          return __spreadValues(__spreadValues({}, acc), wallet && !acc[type] ? { [type]: [wallet.id] } : {});
        }, {}) : fromJson;
      })();
      this.setCurrentWalletIds(currentWalletIds);
      if (Object.values(this.wallets).filter((w) => this.isWalletOwned(w)).length > 0 && this.currentWalletIdsArray.length === 0) {
        this.findWalletId(void 0, { forbidPregen: true });
      }
    };
    this.updateSessionCookieFromStorage = () => {
      this.sessionCookie = this.localStorageGetItem(constants.LOCAL_STORAGE_SESSION_COOKIE) || this.sessionStorageGetItem(constants.LOCAL_STORAGE_SESSION_COOKIE) || void 0;
    };
    this.updateLoginEncryptionKeyPairFromStorage = () => {
      const loginEncryptionKey = this.sessionStorageGetItem(constants.SESSION_STORAGE_LOGIN_ENCRYPTION_KEY_PAIR);
      if (loginEncryptionKey && loginEncryptionKey !== "undefined") {
        this.loginEncryptionKeyPair = this.convertEncryptionKeyPair(JSON.parse(loginEncryptionKey));
      }
    };
    this.updateExternalWalletsFromStorage = () => {
      const stringExternalWallets = this.localStorageGetItem(constants.LOCAL_STORAGE_EXTERNAL_WALLETS);
      const _externalWallets = JSON.parse(stringExternalWallets || "{}");
      this.setExternalWallets(_externalWallets);
    };
    this.initializeWorker = () => __async(this, null, function* () {
      if (!this.isWorkerInitialized && !this.ctx.disableWebSockets && !this.ctx.disableWorkers) {
        try {
          this.isWorkerInitialized = true;
          yield this.platformUtils.initializeWorker(this.ctx);
        } catch (e) {
          this.devLog("error initializing worker:", e);
        }
      }
    });
    /**
     * Creates several new wallets with the desired types. If no types are provided, this method
     * will create one for each of the non-optional types specified in the instance's `supportedWalletTypes`
     * object that are not already present. This is automatically called upon account creation to ensure that
     * the user has a wallet of each required type.
     *
     * @deprecated alias for `createWalletPerType`
     **/
    this.createWalletPerMissingType = this.createWalletPerType;
    __privateAdd(this, _isCreateGuestWalletsPending, false);
    this.getWalletBalance = (_0) => __async(this, [_0], function* ({
      walletId,
      rpcUrl
    }) {
      return (yield this.ctx.client.getWalletBalance({ walletId, rpcUrl })).balance;
    });
    let env, apiKey;
    const actualArgs = Array.from(arguments).filter((arg) => arg !== void 0);
    const actualArgumentCount = actualArgs.length;
    if (actualArgumentCount === 1) {
      if (Object.values(Environment).includes(envOrApiKey)) {
        throw new Error("A Para API key is required.");
      }
      env = _ParaCore.resolveEnvironment(void 0, actualArgs[0]);
      apiKey = actualArgs[0];
      opts = void 0;
    } else if (actualArgumentCount === 2) {
      if (typeof apiKeyOrOpts === "object" && apiKeyOrOpts !== null) {
        env = _ParaCore.resolveEnvironment(void 0, envOrApiKey);
        apiKey = envOrApiKey;
        opts = apiKeyOrOpts;
      } else {
        env = _ParaCore.resolveEnvironment(envOrApiKey, apiKeyOrOpts);
        apiKey = apiKeyOrOpts;
        opts = void 0;
      }
    } else {
      env = _ParaCore.resolveEnvironment(envOrApiKey, apiKeyOrOpts);
      apiKey = apiKeyOrOpts;
    }
    if (!opts) opts = {};
    let isE2E = false;
    if (env === "E2E") {
      isE2E = true;
      env = Environment.SANDBOX;
    }
    this.externalWalletConnectionOnly = opts.externalWalletConnectionOnly;
    this.emailPrimaryColor = opts.emailPrimaryColor;
    this.emailTheme = opts.emailTheme;
    this.homepageUrl = opts.homepageUrl;
    this.supportUrl = opts.supportUrl;
    this.xUrl = opts.xUrl;
    this.githubUrl = opts.githubUrl;
    this.linkedinUrl = opts.linkedinUrl;
    this.portalBackgroundColor = opts.portalBackgroundColor;
    this.portalPrimaryButtonColor = opts.portalPrimaryButtonColor;
    this.portalTextColor = opts.portalTextColor;
    this.portalPrimaryButtonTextColor = opts.portalPrimaryButtonTextColor;
    this.portalTheme = opts.portalTheme;
    this.platformUtils = this.getPlatformUtils();
    this.disableProviderModal = this.platformUtils.disableProviderModal;
    this.fetchPregenWalletsOverride = opts.fetchPregenWalletsOverride;
    if (opts.useStorageOverrides) {
      this.localStorageGetItem = opts.localStorageGetItemOverride;
      this.localStorageSetItem = opts.localStorageSetItemOverride;
      this.sessionStorageGetItem = opts.sessionStorageGetItemOverride;
      this.sessionStorageSetItem = opts.sessionStorageSetItemOverride;
      this.sessionStorageRemoveItem = opts.sessionStorageRemoveItemOverride;
      this.clearStorage = opts.clearStorageOverride;
    }
    if (opts.useSessionStorage) {
      this.localStorageGetItem = this.sessionStorageGetItem;
      this.localStorageSetItem = this.sessionStorageSetItem;
    }
    this.persistSessionCookie = (cookie) => {
      this.sessionCookie = cookie;
      (opts.useSessionStorage ? this.sessionStorageSetItem : this.localStorageSetItem)(
        constants.LOCAL_STORAGE_SESSION_COOKIE,
        cookie
      );
    };
    this.ctx = {
      env,
      apiKey,
      client: initClient({
        env,
        version: _ParaCore.version,
        apiKey,
        partnerId: this.isPortal(env) ? opts.portalPartnerId : void 0,
        useFetchAdapter: !!opts.disableWorkers,
        retrieveSessionCookie: this.retrieveSessionCookie,
        persistSessionCookie: this.persistSessionCookie
      }),
      disableWorkers: opts.disableWorkers,
      offloadMPCComputationURL: opts.offloadMPCComputationURL,
      useLocalFiles: opts.useLocalFiles,
      useDKLS: opts.useDKLSForCreation || !opts.offloadMPCComputationURL,
      disableWebSockets: !!opts.disableWebSockets,
      wasmOverride: opts.wasmOverride,
      isE2E
    };
    if (opts.offloadMPCComputationURL) {
      this.ctx.mpcComputationClient = mpcComputationClient.initClient(opts.offloadMPCComputationURL, opts.disableWorkers);
    }
    if (!this.platformUtils.isSyncStorage || opts.useStorageOverrides) {
      return;
    }
    this.initializeFromStorage();
    setupListeners.bind(this)();
    autoBind(this);
    if (env !== Environment.PROD) {
      this.wrapMethodsWithErrorTracking([
        "signUpOrLogIn",
        "verifyNewAccount",
        "waitForLogin",
        "waitForSignup",
        "waitForWalletCreation",
        "verifyOAuth",
        "verifyTelegram",
        "verifyFarcaster",
        "createPregenWallet",
        "claimPregenWallets",
        "signMessage",
        "signTransaction"
      ]);
    }
  }
  get authInfo() {
    return __privateGet(this, _authInfo);
  }
  get email() {
    var _a;
    return isEmail((_a = __privateGet(this, _authInfo)) == null ? void 0 : _a.auth) ? __privateGet(this, _authInfo).auth.email : void 0;
  }
  get phone() {
    var _a;
    return isPhone((_a = __privateGet(this, _authInfo)) == null ? void 0 : _a.auth) ? __privateGet(this, _authInfo).auth.phone : void 0;
  }
  get farcasterUsername() {
    var _a;
    return isFarcaster((_a = __privateGet(this, _authInfo)) == null ? void 0 : _a.auth) ? __privateGet(this, _authInfo).auth.farcasterUsername : void 0;
  }
  get telegramUserId() {
    var _a;
    return isTelegram((_a = __privateGet(this, _authInfo)) == null ? void 0 : _a.auth) ? __privateGet(this, _authInfo).auth.telegramUserId : void 0;
  }
  get externalWalletWithParaAuth() {
    const externalWallets = Object.values(this.externalWallets);
    return externalWallets.find((w) => w.isExternalWithParaAuth);
  }
  get externalWalletConnectionType() {
    if (this.isExternalWalletAuth) {
      return "AUTHENTICATED";
    } else if (this.isExternalWalletWithVerification) {
      return "VERIFICATION";
    } else if (!!Object.keys(this.externalWallets).length) {
      return "CONNECTION_ONLY";
    }
    return "NONE";
  }
  get isEmail() {
    var _a;
    return isEmail((_a = this.authInfo) == null ? void 0 : _a.auth);
  }
  get isPhone() {
    var _a;
    return isPhone((_a = this.authInfo) == null ? void 0 : _a.auth);
  }
  get isFarcaster() {
    var _a;
    return isFarcaster((_a = this.authInfo) == null ? void 0 : _a.auth);
  }
  get isTelegram() {
    var _a;
    return isTelegram((_a = this.authInfo) == null ? void 0 : _a.auth);
  }
  get isExternalWalletAuth() {
    var _a, _b, _c;
    return isExternalWallet((_a = __privateGet(this, _authInfo)) == null ? void 0 : _a.auth) && !!((_c = (_b = __privateGet(this, _authInfo)) == null ? void 0 : _b.externalWallet) == null ? void 0 : _c.withFullParaAuth);
  }
  get isExternalWalletWithVerification() {
    var _a, _b, _c;
    return isExternalWallet((_a = __privateGet(this, _authInfo)) == null ? void 0 : _a.auth) && !!((_c = (_b = __privateGet(this, _authInfo)) == null ? void 0 : _b.externalWallet) == null ? void 0 : _c.withVerification);
  }
  get partnerId() {
    var _a;
    return (_a = this.partner) == null ? void 0 : _a.id;
  }
  get partnerName() {
    var _a;
    return (_a = this.partner) == null ? void 0 : _a.displayName;
  }
  get partnerLogo() {
    var _a;
    return (_a = this.partner) == null ? void 0 : _a.logoUrl;
  }
  get currentWalletIdsArray() {
    var _a, _b;
    return ((_b = (_a = this.partner) == null ? void 0 : _a.supportedWalletTypes) != null ? _b : Object.keys(this.currentWalletIds).map((type) => ({ type }))).reduce(
      (acc, { type }) => {
        var _a2;
        return [
          ...acc,
          ...((_a2 = this.currentWalletIds[type]) != null ? _a2 : []).map((id) => {
            return [id, type];
          })
        ];
      },
      []
    );
  }
  get currentWalletIdsUnique() {
    return [...new Set(Object.values(this.currentWalletIds).flat())];
  }
  /**
   * A map of pre-generated wallet identifiers that can be claimed in the current instance.
   */
  get pregenIds() {
    return __spreadValues({}, Object.values(this.wallets).filter((wallet) => !this.userId || this.isPregenWalletClaimable(wallet)).reduce((acc, wallet) => {
      var _a, _b;
      if (((_a = acc[wallet.pregenIdentifierType]) != null ? _a : []).includes(wallet.pregenIdentifier)) {
        return acc;
      }
      return __spreadProps(__spreadValues({}, acc), {
        [wallet.pregenIdentifierType]: [
          .../* @__PURE__ */ new Set([...(_b = acc[wallet.pregenIdentifierType]) != null ? _b : [], wallet.pregenIdentifier])
        ]
      });
    }, {}));
  }
  /**
   * Whether the instance has multiple wallets connected.
   */
  get isMultiWallet() {
    return this.currentWalletIdsArray.length > 1 || __privateGet(this, _ParaCore_instances, guestWalletIdsArray_get).length > 1;
  }
  get isNoWalletConfig() {
    var _a;
    return !!((_a = this.partner) == null ? void 0 : _a.supportedWalletTypes) && this.partner.supportedWalletTypes.length === 0;
  }
  get supportedWalletTypes() {
    var _a, _b;
    return (_b = (_a = this.partner) == null ? void 0 : _a.supportedWalletTypes) != null ? _b : [];
  }
  get cosmosPrefix() {
    var _a;
    return (_a = this.partner) == null ? void 0 : _a.cosmosPrefix;
  }
  get supportedAccountLinks() {
    var _a, _b;
    return (_b = (_a = this.partner) == null ? void 0 : _a.supportedAccountLinks) != null ? _b : [...LINKED_ACCOUNT_TYPES];
  }
  get isWalletTypeEnabled() {
    var _a;
    return (((_a = this.partner) == null ? void 0 : _a.supportedWalletTypes) || []).reduce((acc, { type }) => {
      return __spreadProps(__spreadValues({}, acc), { [type]: true });
    }, {});
  }
  convertBigInt(bigInt) {
    const convertedBigInt = new jsbn.BigInteger(null);
    convertedBigInt.data = bigInt.data;
    convertedBigInt.s = bigInt.s;
    convertedBigInt.t = bigInt.t;
    return convertedBigInt;
  }
  convertEncryptionKeyPair(jsonKeyPair) {
    return {
      privateKey: pki.setRsaPrivateKey(
        this.convertBigInt(jsonKeyPair.privateKey.n),
        this.convertBigInt(jsonKeyPair.privateKey.e),
        this.convertBigInt(jsonKeyPair.privateKey.d),
        this.convertBigInt(jsonKeyPair.privateKey.p),
        this.convertBigInt(jsonKeyPair.privateKey.q),
        this.convertBigInt(jsonKeyPair.privateKey.dP),
        this.convertBigInt(jsonKeyPair.privateKey.dQ),
        this.convertBigInt(jsonKeyPair.privateKey.qInv)
      ),
      publicKey: pki.setRsaPublicKey(
        this.convertBigInt(jsonKeyPair.publicKey.n),
        this.convertBigInt(jsonKeyPair.publicKey.e)
      )
    };
  }
  isPortal(envOverride) {
    var _a;
    if (typeof window === "undefined") return false;
    return !!((_a = window.location) == null ? void 0 : _a.host) && getPortalBaseURL(envOverride ? { env: envOverride } : this.ctx).includes(window.location.host);
  }
  isParaConnect() {
    var _a;
    if (typeof window === "undefined") return false;
    return !!((_a = window.location) == null ? void 0 : _a.host) && getParaConnectBaseUrl(this.ctx).includes(window.location.host);
  }
  requireApiKey() {
    if (!this.ctx.apiKey) {
      throw new Error(
        `in order to create a wallet or user with Para, you
        must provide an API key to the Para instance`
      );
    }
  }
  isWalletSupported(wallet) {
    var _a, _b;
    return !((_a = this.partner) == null ? void 0 : _a.supportedWalletTypes) || isWalletSupported((_b = this.partner.supportedWalletTypes.map(({ type }) => type)) != null ? _b : [], wallet);
  }
  isWalletOwned(wallet) {
    return this.isWalletSupported(wallet) && !(wallet == null ? void 0 : wallet.pregenIdentifier) && !(wallet == null ? void 0 : wallet.pregenIdentifierType) && !!this.userId && (wallet == null ? void 0 : wallet.userId) === this.userId;
  }
  isPregenWalletUnclaimed(wallet) {
    return this.isWalletSupported(wallet) && (!(wallet == null ? void 0 : wallet.userId) || (wallet == null ? void 0 : wallet.isPregen) && !!(wallet == null ? void 0 : wallet.pregenIdentifier) && !!(wallet == null ? void 0 : wallet.pregenIdentifierType));
  }
  isPregenWalletClaimable(wallet) {
    return this.isWalletSupported(wallet) && this.isPregenWalletUnclaimed(wallet) && (!["EMAIL", "PHONE", "TELEGRAM"].includes(wallet == null ? void 0 : wallet.pregenIdentifierType) || isPregenIdentifierMatch(
      (wallet == null ? void 0 : wallet.pregenIdentifierType) === "EMAIL" ? this.email : (wallet == null ? void 0 : wallet.pregenIdentifierType) === "TELEGRAM" ? this.telegramUserId : this.getPhoneNumber(),
      wallet == null ? void 0 : wallet.pregenIdentifier,
      wallet == null ? void 0 : wallet.pregenIdentifierType
    ));
  }
  isWalletUsable(walletId, { type: types, scheme: schemes, forbidPregen = false } = {}, throwError = false) {
    var _a, _b;
    let error;
    if ((_a = this.externalWallets) == null ? void 0 : _a[walletId]) {
      return true;
    }
    if (!this.wallets[walletId]) {
      error = `wallet with id ${walletId} does not exist`;
    } else {
      const wallet = this.wallets[walletId];
      const [isUnclaimed, isOwned] = [this.isPregenWalletUnclaimed(wallet), this.isWalletOwned(wallet)];
      if (forbidPregen && isUnclaimed && wallet.pregenIdentifierType !== "GUEST_ID") {
        error = `pre-generated wallet with id ${wallet == null ? void 0 : wallet.id} cannot be selected`;
      } else if (!isOwned && !isUnclaimed) {
        error = `wallet with id ${wallet == null ? void 0 : wallet.id} is not owned by the current user`;
      } else if (!this.isWalletSupported(wallet)) {
        error = `wallet with id ${wallet.id} and type ${wallet.type} is not supported, supported types are: ${(((_b = this.partner) == null ? void 0 : _b.supportedWalletTypes) || []).map(({ type }) => type).join(", ")}`;
      } else if (types && (!getEquivalentTypes(types).includes(wallet == null ? void 0 : wallet.type) || isOwned && !types.some((type) => {
        var _a2, _b2;
        return (_b2 = (_a2 = this.currentWalletIds) == null ? void 0 : _a2[type]) == null ? void 0 : _b2.includes(walletId);
      }))) {
        error = `wallet with id ${wallet == null ? void 0 : wallet.id} and type ${wallet == null ? void 0 : wallet.type} cannot be selected`;
      } else if (schemes && !schemes.includes(wallet == null ? void 0 : wallet.scheme)) {
        error = `wallet with id ${wallet == null ? void 0 : wallet.id} and scheme ${wallet == null ? void 0 : wallet.scheme} cannot be selected`;
      }
    }
    if (error) {
      if (throwError) {
        throw new Error(error);
      }
      return false;
    }
    return true;
  }
  /**
   * Returns the formatted address for the desired wallet ID, depending on your app settings.
   * @param {string} walletId the ID of the wallet address to display.
   * @param {object} options additional options for formatting the address.
   * @param {boolean} options.truncate whether to truncate the address.
   * @param {TWalletType} options.addressType the type of address to display.
   * @returns the formatted address
   */
  getDisplayAddress(walletId, options = {}) {
    var _a, _b, _c, _d;
    if (this.externalWallets[walletId]) {
      const wallet2 = this.externalWallets[walletId];
      return options.truncate ? truncateAddress(wallet2.address, wallet2.type, {
        prefix: (_a = this.partner) == null ? void 0 : _a.cosmosPrefix,
        targetLength: options.targetLength
      }) : wallet2.address;
    }
    const wallet = this.findWallet(walletId, options.addressType);
    if (!wallet) {
      return void 0;
    }
    let str;
    let prefix;
    switch (wallet.type) {
      case "COSMOS":
        prefix = (_d = (_c = options.cosmosPrefix) != null ? _c : (_b = this.partner) == null ? void 0 : _b.cosmosPrefix) != null ? _d : "cosmos";
        str = getCosmosAddress(wallet.publicKey, prefix);
        break;
      default:
        prefix = this.cosmosPrefix;
        str = wallet.address;
        break;
    }
    return options.truncate ? truncateAddress(str, wallet.type, { prefix, targetLength: options.targetLength }) : str;
  }
  /**
   * Returns a unique hash for a wallet suitable for use as an identicon seed.
   * @param {string} walletId the ID of the wallet.
   * @param {boolean} options.addressType used to format the hash for another wallet type.
   * @returns the identicon hash string
   */
  getIdenticonHash(walletId, overrideType) {
    if (this.externalWallets[walletId]) {
      const wallet2 = this.externalWallets[walletId];
      return `${wallet2.id}-${wallet2.address}-${wallet2.type}`;
    }
    const wallet = this.findWallet(walletId, overrideType);
    return wallet ? `${wallet.id}-${wallet.address}-${wallet.type}` : void 0;
  }
  getWallets() {
    return this.wallets;
  }
  getAddress(walletId) {
    var _a, _b, _c;
    return walletId ? (_a = this.wallets[walletId]) == null ? void 0 : _a.address : (_c = (_b = Object.values(this.wallets)) == null ? void 0 : _b[0]) == null ? void 0 : _c.address;
  }
  constructPortalUrl(_0) {
    return __async(this, arguments, function* (type, opts = {}) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
      const [isCreate, isLogin, isOnRamp] = [
        ["createAuth", "createPassword", "createPIN"].includes(type),
        ["loginAuth", "loginPassword", "loginPIN"].includes(type),
        type === "onRamp"
      ];
      if (isCreate || isLogin) {
        this.assertIsAuthSet();
      }
      let sessionId = opts.sessionId;
      if ((isLogin || isOnRamp) && !sessionId) {
        const session = yield this.touchSession(true);
        sessionId = session.sessionId;
      }
      if (!this.loginEncryptionKeyPair) {
        yield this.setLoginEncryptionKeyPair();
      }
      const base = type === "onRamp" || type === "telegramLogin" ? getPortalBaseURL(this.ctx, type === "telegramLogin") : yield this.getPortalURL();
      let path;
      switch (type) {
        case "createPassword": {
          path = `/web/users/${this.userId}/passwords/${opts.pathId}`;
          break;
        }
        case "createPIN": {
          path = `/web/users/${this.userId}/pin/${opts.pathId}`;
          break;
        }
        case "createAuth": {
          path = `/web/users/${this.userId}/biometrics/${opts.pathId}`;
          break;
        }
        case "loginPassword": {
          path = "/web/passwords/login";
          break;
        }
        case "loginAuth": {
          path = "/web/biometrics/login";
          break;
        }
        case "loginPIN": {
          path = "/web/pin/login";
          break;
        }
        case "txReview": {
          path = `/web/users/${this.userId}/transaction-review/${opts.pathId}`;
          break;
        }
        case "onRamp": {
          path = `/web/users/${this.userId}/on-ramp-transaction/v2/${opts.pathId}`;
          break;
        }
        case "telegramLogin": {
          path = `/auth/telegram`;
          break;
        }
        default: {
          throw new Error(`invalid URL type ${type}`);
        }
      }
      let partner = void 0;
      try {
        partner = yield __privateMethod(this, _ParaCore_instances, assertPartner_fn).call(this);
      } catch (e) {
        if (this.isPartnerOptional) {
          partner = void 0;
        } else {
          throw e;
        }
      }
      const thisDevice = (_a = opts.thisDevice) != null ? _a : {
        encryptionKey: getPublicKeyHex(this.loginEncryptionKeyPair),
        sessionId
      };
      const params = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
        apiKey: this.ctx.apiKey,
        partnerId: partner == null ? void 0 : partner.id,
        portalFont: ((_b = opts.portalTheme) == null ? void 0 : _b.font) || (partner == null ? void 0 : partner.font) || ((_c = this.portalTheme) == null ? void 0 : _c.font),
        portalBorderRadius: ((_d = opts.portalTheme) == null ? void 0 : _d.borderRadius) || ((_e = this.portalTheme) == null ? void 0 : _e.borderRadius),
        portalThemeMode: ((_f = opts.portalTheme) == null ? void 0 : _f.mode) || (partner == null ? void 0 : partner.themeMode) || ((_g = this.portalTheme) == null ? void 0 : _g.mode),
        portalAccentColor: ((_h = opts.portalTheme) == null ? void 0 : _h.accentColor) || (partner == null ? void 0 : partner.accentColor) || ((_i = this.portalTheme) == null ? void 0 : _i.accentColor),
        portalForegroundColor: ((_j = opts.portalTheme) == null ? void 0 : _j.foregroundColor) || (partner == null ? void 0 : partner.foregroundColor) || ((_k = this.portalTheme) == null ? void 0 : _k.foregroundColor),
        portalBackgroundColor: ((_l = opts.portalTheme) == null ? void 0 : _l.backgroundColor) || (partner == null ? void 0 : partner.backgroundColor) || this.portalBackgroundColor || ((_m = this.portalTheme) == null ? void 0 : _m.backgroundColor),
        portalPrimaryButtonColor: this.portalPrimaryButtonColor,
        portalTextColor: this.portalTextColor,
        portalPrimaryButtonTextColor: this.portalPrimaryButtonTextColor,
        isForNewDevice: opts.isForNewDevice ? opts.isForNewDevice.toString() : void 0
      }, isCreate || isLogin ? __spreadProps(__spreadValues({
        authInfo: JSON.stringify(this.authInfo)
      }, isPhone(this.authInfo.auth) ? splitPhoneNumber(this.authInfo.auth.phone) : this.authInfo.auth), {
        pfpUrl: this.authInfo.pfpUrl,
        displayName: this.authInfo.displayName
      }) : {}), isOnRamp ? { origin: typeof window !== "undefined" ? window.location.origin : void 0, email: this.email } : {}), isLogin ? __spreadProps(__spreadValues({
        sessionId: thisDevice.sessionId,
        encryptionKey: thisDevice.encryptionKey
      }, opts.newDevice ? {
        newDeviceSessionLookupId: opts.newDevice.sessionId,
        newDeviceEncryptionKey: opts.newDevice.encryptionKey
      } : {}), {
        pregenIds: JSON.stringify(this.pregenIds)
      }) : {}), type === "telegramLogin" ? { isEmbed: "true" } : {}), opts.params || {});
      const url = constructUrl({ base, path, params });
      if (opts.shorten) {
        return shortenUrl(this.ctx, url);
      }
      return url;
    });
  }
  static resolveEnvironment(env, apiKey) {
    var _a;
    if (!apiKey) {
      throw new Error("A Para API key is required.");
    }
    if (apiKey.includes("_")) {
      const validEnvironmentPrefixes = Object.values(Environment);
      const envPrefix = (_a = apiKey.split("_")[0]) == null ? void 0 : _a.toUpperCase();
      const hasValidPrefix = validEnvironmentPrefixes.some((envValue) => envValue === envPrefix);
      if (!hasValidPrefix) {
        throw new Error(`Invalid API key environment prefix.`);
      }
      return envPrefix;
    }
    if (!env) {
      throw new Error("Environment parameter is required.");
    }
    return env;
  }
  touchSession(regenerate = false) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d;
      if (!this.isWorkerInitialized) {
        this.initializeWorker();
      }
      if (!this.isReady) {
        yield this.ready();
      }
      const session = yield this.ctx.client.touchSession(regenerate);
      if (!this.partner || ((_a = this.partner) == null ? void 0 : _a.id) !== session.partnerId || !supportedWalletTypesEq(((_b = this.partner) == null ? void 0 : _b.supportedWalletTypes) || [], session.supportedWalletTypes) || (((_c = this.partner) == null ? void 0 : _c.cosmosPrefix) || "cosmos") !== session.cosmosPrefix) {
        if (!session.partnerId) {
          console.error(`
\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501
\u{1F6A8} PARA SDK CONFIGURATION ERROR \u{1F6A8}

INVALID API KEY FOR CONFIGURED ENVIRONMENT

Your API key does not match the configured environment. This usually means:

1. You're using a production API key with a development environment
2. You're using a development API key with a production environment  
3. Your API key is invalid or has been regenerated

SOLUTION:
\u2022 Verify your API key at: https://developer.getpara.com
\u2022 If your API key doesn't contain an environment prefix, ensure your API key is the correct key for your target environment

Current Environment: ${this.ctx.env}
API Key Prefix: ${((_d = this.ctx.apiKey) == null ? void 0 : _d.split("_")[0].toUpperCase()) || "None"}

Need help? Visit: https://docs.getpara.com or contact support
\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501
        `);
        } else {
          yield __privateMethod(this, _ParaCore_instances, getPartner_fn).call(this, session.partnerId);
        }
      }
      return session;
    });
  }
  getVerificationEmailProps() {
    return {
      brandColor: this.emailPrimaryColor,
      theme: this.emailTheme,
      supportUrl: this.supportUrl,
      homepageUrl: this.homepageUrl,
      xUrl: this.xUrl,
      githubUrl: this.githubUrl,
      linkedinUrl: this.linkedinUrl
    };
  }
  getBackupKitEmailProps() {
    return {
      brandColor: this.emailPrimaryColor,
      theme: this.emailTheme,
      homepageUrl: this.homepageUrl,
      xUrl: this.xUrl,
      linkedinUrl: this.linkedinUrl,
      githubUrl: this.githubUrl,
      supportUrl: this.supportUrl
    };
  }
  /**
   * Initialize storage relating to a `ParaCore` instance.
   *
   * Init only needs to be called for storage that is async.
   */
  init() {
    return __async(this, null, function* () {
      var _a, _b;
      this.userId = (yield this.localStorageGetItem(constants.LOCAL_STORAGE_USER_ID)) || void 0;
      const storageAuthInfo = (yield this.localStorageGetItem(constants.LOCAL_STORAGE_AUTH_INFO)) || void 0;
      const stringExternalWallets = yield this.localStorageGetItem(constants.LOCAL_STORAGE_EXTERNAL_WALLETS);
      const _externalWallets = JSON.parse(stringExternalWallets || "{}");
      yield this.setExternalWallets(_externalWallets);
      let authInfo = jsonParse(storageAuthInfo);
      if (!authInfo) {
        const authParams = {
          email: (yield this.localStorageGetItem(constants.LOCAL_STORAGE_EMAIL)) || void 0,
          phone: (yield this.localStorageGetItem(constants.LOCAL_STORAGE_PHONE)) || void 0,
          countryCode: (yield this.localStorageGetItem(constants.LOCAL_STORAGE_COUNTRY_CODE)) || void 0,
          farcasterUsername: (yield this.localStorageGetItem(constants.LOCAL_STORAGE_FARCASTER_USERNAME)) || void 0,
          telegramUserId: (yield this.localStorageGetItem(constants.LOCAL_STORAGE_TELEGRAM_USER_ID)) || void 0,
          // Using id here since we store the bech32 address for cosmos in the address field of the wallet
          externalWalletAddress: ((_a = this.externalWalletWithParaAuth) == null ? void 0 : _a.id) || void 0
        };
        authInfo = __privateMethod(this, _ParaCore_instances, toAuthInfo_fn).call(this, authParams);
      }
      __privateSet(this, _authInfo, authInfo);
      const stringWallets = this.platformUtils.secureStorage ? yield this.platformUtils.secureStorage.get(constants.LOCAL_STORAGE_WALLETS) : yield this.localStorageGetItem(constants.LOCAL_STORAGE_WALLETS);
      const _wallets = JSON.parse(stringWallets || "{}");
      const stringEd25519Wallets = this.platformUtils.secureStorage ? yield this.platformUtils.secureStorage.get(constants.LOCAL_STORAGE_ED25519_WALLETS) : yield this.localStorageGetItem(constants.LOCAL_STORAGE_ED25519_WALLETS);
      const _ed25519Wallets = JSON.parse(stringEd25519Wallets || "{}");
      const wallets = __spreadValues(__spreadValues({}, Object.keys(_wallets).reduce((res, key) => {
        return __spreadProps(__spreadValues({}, res), {
          [key]: migrateWallet(_wallets[key])
        });
      }, {})), Object.keys(_ed25519Wallets).reduce((res, key) => {
        return __spreadValues(__spreadValues({}, res), !res[key] ? { [key]: migrateWallet(_ed25519Wallets[key]) } : {});
      }, {}));
      yield this.setWallets(wallets);
      const _currentWalletIds = (_b = yield this.localStorageGetItem(constants.LOCAL_STORAGE_CURRENT_WALLET_IDS)) != null ? _b : void 0;
      const currentWalletIds = [void 0, null, "undefined", "null"].includes(_currentWalletIds) ? {} : (() => {
        const fromJson = JSON.parse(_currentWalletIds);
        return Array.isArray(fromJson) ? WALLET_TYPES.reduce((acc, type) => {
          const wallet = Object.values(this.wallets).find(
            (w) => fromJson.includes(w.id) && WalletSchemeTypeMap[w.scheme][type]
          );
          return __spreadValues(__spreadValues({}, acc), wallet && !acc[type] ? { [type]: [wallet.id] } : {});
        }, {}) : fromJson;
      })();
      yield this.setCurrentWalletIds(currentWalletIds);
      this.sessionCookie = (yield this.localStorageGetItem(constants.LOCAL_STORAGE_SESSION_COOKIE)) || (yield this.sessionStorageGetItem(constants.LOCAL_STORAGE_SESSION_COOKIE)) || void 0;
      if (Object.values(this.wallets).filter((w) => this.isWalletOwned(w)).length > 0 && this.currentWalletIdsArray.length === 0) {
        this.findWalletId(void 0, { forbidPregen: true });
      }
      const loginEncryptionKey = yield this.sessionStorageGetItem(constants.SESSION_STORAGE_LOGIN_ENCRYPTION_KEY_PAIR);
      if (loginEncryptionKey && loginEncryptionKey !== "undefined") {
        this.loginEncryptionKeyPair = this.convertEncryptionKeyPair(JSON.parse(loginEncryptionKey));
      }
      setupListeners.bind(this)();
      yield this.touchSession();
    });
  }
  setAuth(_0) {
    return __async(this, arguments, function* (auth, { extras = {}, userId } = {}) {
      const authInfo = __spreadValues(__spreadValues({}, extractAuthInfo(auth, { isRequired: true })), extras || {});
      yield __privateMethod(this, _ParaCore_instances, setAuthInfo_fn).call(this, authInfo);
      if (!!userId) {
        yield this.setUserId(userId);
      }
      return __privateGet(this, _authInfo);
    });
  }
  assertUserId({ allowGuestMode = false } = {}) {
    if (!this.userId || !allowGuestMode && this.isGuestMode) {
      throw new Error("no userId is set");
    }
    return this.userId;
  }
  assertIsAuthSet(allowed) {
    if (!__privateGet(this, _authInfo)) {
      throw new Error("auth is not set");
    }
    if (allowed && !allowed.includes(__privateGet(this, _authInfo).authType)) {
      throw new Error(`invalid auth type, expected ${allowed.join(", ")}`);
    }
    return __privateGet(this, _authInfo);
  }
  /**
   * Sets the email associated with the `ParaCore` instance.
   * @param email - Email to set.
   */
  setEmail(email) {
    return __async(this, null, function* () {
      yield this.setAuth({ email });
    });
  }
  /**
   * Sets the Telegram user ID associated with the `ParaCore` instance.
   * @param telegramUserId - Telegram user ID to set.
   */
  setTelegramUserId(telegramUserId) {
    return __async(this, null, function* () {
      yield this.setAuth({ telegramUserId });
    });
  }
  /**
   * Sets the phone number associated with the `ParaCore` instance.
   * @param phone - Phone number to set.
   * @param countryCode - Country Code to set.
   */
  setPhoneNumber(phone, countryCode) {
    return __async(this, null, function* () {
      yield this.setAuth({ phone: formatPhoneNumber(phone, countryCode) });
    });
  }
  /**
   * Sets the farcaster username associated with the `ParaCore` instance.
   * @param farcasterUsername - Farcaster Username to set.
   */
  setFarcasterUsername(farcasterUsername) {
    return __async(this, null, function* () {
      yield this.setAuth({ farcasterUsername });
    });
  }
  /**
   * Sets the external wallet address and type associated with the `ParaCore` instance.
   * @param externalAddress - External wallet address to set.
   * @param externalType - Type of external wallet to set.
   */
  setExternalWallet(externalWallet) {
    return __async(this, null, function* () {
      const { id: partnerId, supportedWalletTypes } = yield __privateMethod(this, _ParaCore_instances, assertPartner_fn).call(this);
      this.externalWallets = (Array.isArray(externalWallet) ? externalWallet : [externalWallet]).reduce(
        (acc, {
          partnerId: wPartnerId,
          address,
          type,
          provider,
          providerId,
          addressBech32,
          withFullParaAuth,
          isConnectionOnly,
          withVerification
        }) => {
          if (partnerId === wPartnerId && supportedWalletTypes.some(({ type: supportedType }) => supportedType === type)) {
            return __spreadProps(__spreadValues({}, acc), {
              [address]: {
                id: address,
                partnerId,
                address: addressBech32 != null ? addressBech32 : address,
                type,
                name: provider,
                isExternal: true,
                isExternalWithParaAuth: withFullParaAuth,
                externalProviderId: providerId,
                signer: "",
                isExternalConnectionOnly: isConnectionOnly,
                isExternalWithVerification: withVerification
              }
            });
          }
          return acc;
        },
        {}
      ), this.setExternalWallets(this.externalWallets);
      dispatchEvent(ParaEvent.EXTERNAL_WALLET_CHANGE_EVENT, null);
    });
  }
  addExternalWallets(externalWallets) {
    return __async(this, null, function* () {
      const { id: partnerId, supportedWalletTypes } = yield __privateMethod(this, _ParaCore_instances, assertPartner_fn).call(this);
      this.externalWallets = __spreadValues(__spreadValues({}, Object.entries(this.externalWallets).reduce((acc, [address, wallet]) => {
        if (partnerId === wallet.partnerId && supportedWalletTypes.some(({ type }) => type === wallet.type)) {
          return __spreadProps(__spreadValues({}, acc), {
            [address]: wallet
          });
        }
        return acc;
      }, {})), externalWallets.reduce(
        (acc, { address, type, provider, providerId, addressBech32, withFullParaAuth, isConnectionOnly, withVerification }) => {
          return __spreadProps(__spreadValues({}, acc), {
            [address]: {
              id: address,
              partnerId,
              address: addressBech32 != null ? addressBech32 : address,
              type,
              name: provider,
              isExternal: true,
              isExternalWithParaAuth: withFullParaAuth,
              externalProviderId: providerId,
              signer: "",
              isExternalConnectionOnly: isConnectionOnly,
              isExternalWithVerification: withVerification
            }
          });
        },
        {}
      ));
      this.setExternalWallets(this.externalWallets);
      dispatchEvent(ParaEvent.EXTERNAL_WALLET_CHANGE_EVENT, null);
    });
  }
  /**
   * Sets the user id associated with the `ParaCore` instance.
   * @param userId - User id to set.
   */
  setUserId(userId) {
    return __async(this, null, function* () {
      this.userId = userId;
      yield this.localStorageSetItem(constants.LOCAL_STORAGE_USER_ID, userId);
    });
  }
  /**
   * Sets the wallets associated with the `ParaCore` instance.
   * @param wallets - Wallets to set.
   */
  setWallets(wallets) {
    return __async(this, null, function* () {
      this.wallets = wallets;
      if (this.platformUtils.secureStorage) {
        yield this.platformUtils.secureStorage.set(constants.LOCAL_STORAGE_WALLETS, JSON.stringify(wallets));
        return;
      }
      yield this.localStorageSetItem(constants.LOCAL_STORAGE_WALLETS, JSON.stringify(wallets));
    });
  }
  /**
   * Sets the external wallets associated with the `ParaCore` instance.
   * @param externalWallets - External wallets to set.
   */
  setExternalWallets(externalWallets) {
    return __async(this, null, function* () {
      this.externalWallets = externalWallets;
      yield this.localStorageSetItem(constants.LOCAL_STORAGE_EXTERNAL_WALLETS, JSON.stringify(externalWallets));
    });
  }
  /**
   * Sets the login encryption key pair associated with the `ParaCore` instance.
   * @param keyPair - Encryption key pair generated from loginEncryptionKey.
   */
  setLoginEncryptionKeyPair(keyPair) {
    return __async(this, null, function* () {
      if (!keyPair) {
        keyPair = yield getAsymmetricKeyPair(this.ctx);
      }
      this.loginEncryptionKeyPair = keyPair;
      yield this.sessionStorageSetItem(constants.SESSION_STORAGE_LOGIN_ENCRYPTION_KEY_PAIR, JSON.stringify(keyPair));
    });
  }
  deleteLoginEncryptionKeyPair() {
    return __async(this, null, function* () {
      this.loginEncryptionKeyPair = void 0;
      yield this.sessionStorageRemoveItem(constants.SESSION_STORAGE_LOGIN_ENCRYPTION_KEY_PAIR);
    });
  }
  /**
   * Gets the userId associated with the `ParaCore` instance.
   * @returns - userId associated with the `ParaCore` instance.
   */
  getUserId() {
    return this.userId;
  }
  getAuthInfo() {
    return this.authInfo;
  }
  /**
   * Gets the email associated with the `ParaCore` instance.
   * @returns - email associated with the `ParaCore` instance.
   */
  getEmail() {
    return this.email;
  }
  /**
   * Gets the formatted phone number associated with the `ParaCore` instance.
   * @returns - formatted phone number associated with the `ParaCore` instance.
   */
  getPhoneNumber() {
    return this.phone;
  }
  /**
   * Gets the farcaster username associated with the `ParaCore` instance.
   * @returns - farcaster username associated with the `ParaCore` instance.
   */
  getFarcasterUsername() {
    return this.farcasterUsername;
  }
  setCurrentWalletIds(_0) {
    return __async(this, arguments, function* (currentWalletIds, {
      needsWallet = false,
      sessionLookupId,
      newDeviceSessionLookupId
    } = {}) {
      this.currentWalletIds = currentWalletIds;
      yield this.localStorageSetItem(constants.LOCAL_STORAGE_CURRENT_WALLET_IDS, JSON.stringify(this.currentWalletIds));
      if (sessionLookupId) {
        yield this.ctx.client.setCurrentWalletIds(
          this.getUserId(),
          this.currentWalletIds,
          needsWallet,
          sessionLookupId,
          newDeviceSessionLookupId
        );
      }
      dispatchEvent(ParaEvent.WALLETS_CHANGE_EVENT, null);
    });
  }
  /**
   * Fetches the most recent OAuth account metadata for the signed-in user.
   * If applicable, this will include the user's most recent metadata from their Google, Apple, Facebook, X, Discord, Farcaster, or Telegram account, the last time they signed in to your app.
   * @deprecated use `para.getLinkedAccounts({ withMetadata: true })` instead.
   * @returns {Promise<AccountMetadata>} the user's account metadata.
   */
  getAccountMetadata() {
    return __async(this, null, function* () {
      if (!(yield this.isSessionActive()) || !this.userId) {
        throw new Error("no signed-in user");
      }
      const { partnerId } = yield this.touchSession();
      const { accountMetadata } = yield this.ctx.client.getAccountMetadata(this.userId, partnerId);
      return accountMetadata;
    });
  }
  /**
   * Validates that a wallet ID is present on the instance, usable, and matches the desired filters.
   * If no ID is passed, this will instead return the first valid, usable wallet ID that matches the filters.
   * @param {string} [walletId] the wallet ID to validate.
   * @param {WalletFilters} [filter={}] a `WalletFilters` object specifying allowed types, schemes, and whether to forbid unclaimed pregen wallets.
   * @returns {string} the wallet ID originally passed, or the one found.
   */
  findWalletId(walletId, filter = {}) {
    if (walletId) {
      this.assertIsValidWalletId(walletId, filter);
    } else {
      for (const id of [...this.currentWalletIdsUnique, ...Object.keys(this.wallets)]) {
        if (this.isWalletUsable(id, filter)) {
          walletId = id;
          break;
        }
      }
      if (!walletId) {
        throw new Error(`no valid wallet id found`);
      }
    }
    return walletId;
  }
  /**
   * Retrieves a wallet with the given address, if present.
   * If no ID is passed, this will instead return the first valid, usable wallet ID that matches the filters.
   * @param {string} [walletId] the wallet ID to validate.
   * @param {WalletFilters} [filter={}] a `WalletFilters` object specifying allowed types, schemes, and whether to forbid unclaimed pregen wallets.
   * @returns {string} the wallet ID originally passed, or the one found.
   */
  findWalletByAddress(address, filter) {
    if (this.externalWallets[address]) {
      return this.externalWallets[address];
    }
    let wallet;
    Object.entries(this.currentWalletIds).forEach(([type, walletIds]) => {
      const pregenWalletIds = Object.keys(this.wallets).filter(
        (id) => this.wallets[id].type === type && this.isPregenWalletClaimable(this.wallets[id])
      );
      [...walletIds, ...pregenWalletIds].forEach((id) => {
        if (address.toLowerCase() === this.getDisplayAddress(id, { addressType: type }).toLowerCase()) {
          wallet = this.wallets[id];
        }
      });
    });
    if (!wallet) {
      throw new Error(`wallet with address ${address} not found`);
    }
    this.assertIsValidWalletId(wallet.id, filter);
    return wallet;
  }
  findWallet(idOrAddress, overrideType, filter = {}) {
    var _a, _c, _d;
    if (!this.isExternalWalletAuth) {
      if (!idOrAddress && Object.keys(this.externalWallets).length > 0) {
        return Object.values(this.externalWallets)[0];
      }
    }
    if ((_a = this.externalWallets) == null ? void 0 : _a[idOrAddress]) {
      return this.externalWallets[idOrAddress];
    }
    try {
      const walletId = this.findWalletId(idOrAddress, filter);
      if (walletId && !!this.wallets[walletId]) {
        const _b = this.wallets[walletId], { signer: _signer } = _b, wallet = __objRest(_b, ["signer"]);
        const type = (_d = overrideType != null ? overrideType : (_c = this.currentWalletIdsArray.find(([id]) => id === walletId)) == null ? void 0 : _c[1]) != null ? _d : wallet.type;
        return __spreadProps(__spreadValues({}, wallet), {
          type
        });
      }
    } catch (e) {
      return void 0;
    }
  }
  get availableWallets() {
    var _a;
    return [
      ...[...this.currentWalletIdsArray, ...__privateGet(this, _ParaCore_instances, guestWalletIdsArray_get)].map(([address, type]) => [address, type, false]).map(([id, type]) => {
        const wallet = this.findWallet(id, type);
        if (!wallet) return null;
        return {
          id: wallet.id,
          type,
          address: this.getDisplayAddress(id, { addressType: type }),
          name: wallet.name
        };
      }).filter((obj) => obj !== null),
      ...Object.values((_a = this.externalWallets) != null ? _a : {})
    ];
  }
  /**
   * Retrieves all usable wallets with the provided type (`'EVM' | 'COSMOS' | 'SOLANA'`)
   * @param {string} type the wallet type to filter by.
   * @returns {Wallet[]} an array of matching wallets.
   */
  getWalletsByType(type) {
    return Object.values(this.wallets).filter((w) => this.isWalletUsable(w.id, { type: [type] }));
  }
  assertIsValidWalletId(walletId, condition = {}) {
    this.isWalletUsable(walletId, condition, true);
  }
  assertIsValidWalletType(type, walletTypes) {
    return __async(this, null, function* () {
      const { supportedWalletTypes } = yield __privateMethod(this, _ParaCore_instances, assertPartner_fn).call(this);
      if (!type || !WALLET_TYPES.includes(type) || !(walletTypes != null ? walletTypes : supportedWalletTypes.map(({ type: type2 }) => type2)).includes(type)) {
        throw new Error(`wallet type ${type} is not supported`);
      }
      return type;
    });
  }
  getMissingTypes() {
    return __async(this, null, function* () {
      const { supportedWalletTypes } = yield __privateMethod(this, _ParaCore_instances, assertPartner_fn).call(this);
      return supportedWalletTypes.filter(
        ({ type: t, optional }) => !optional && Object.values(this.wallets).every((w) => !this.isWalletOwned(w) || !WalletSchemeTypeMap[w.scheme][t])
      ).map(({ type }) => type);
    });
  }
  getTypesToCreate(types) {
    return __async(this, null, function* () {
      const { supportedWalletTypes } = yield __privateMethod(this, _ParaCore_instances, assertPartner_fn).call(this);
      return getSchemes(types != null ? types : yield this.getMissingTypes()).map((scheme) => {
        switch (scheme) {
          case "ED25519":
            return "SOLANA";
          default:
            return supportedWalletTypes.some(({ type, optional }) => type === "COSMOS" && !optional) ? "COSMOS" : "EVM";
        }
      });
    });
  }
  getPartnerURL() {
    return __async(this, null, function* () {
      try {
        const { portalUrl } = yield __privateMethod(this, _ParaCore_instances, assertPartner_fn).call(this);
        return portalUrl;
      } catch (e) {
        if (this.isPartnerOptional) {
          return void 0;
        }
        throw e;
      }
    });
  }
  /**
   * URL of the portal, which can be associated with a partner id
   * @param partnerId: string - id of the partner to get the portal URL for
   * @returns - portal URL
   */
  getPortalURL() {
    return __async(this, null, function* () {
      return (yield this.getPartnerURL()) || getPortalBaseURL(this.ctx);
    });
  }
  /**
   * Gets the private key for the given wallet.
   * @param {string } [walletId] id of the wallet to get the private key for. Will default to the first wallet if not provided.
   * @returns - the private key string.
   */
  getPrivateKey(walletId) {
    return __async(this, null, function* () {
      const wallets = Object.values(this.wallets);
      const wallet = walletId ? this.wallets[walletId] : wallets == null ? void 0 : wallets[0];
      if (!wallet) {
        throw new Error("wallet not found");
      }
      if (wallet.scheme !== "DKLS") {
        throw new Error("invalid wallet scheme");
      }
      return yield this.platformUtils.getPrivateKey(
        this.ctx,
        this.userId,
        wallet.id,
        wallet.signer,
        this.retrieveSessionCookie()
      );
    });
  }
  /**
   * Fetches the wallets associated with the user.
   * @returns {WalletEntity[]} wallets that were fetched.
   */
  fetchWallets() {
    return __async(this, null, function* () {
      const res = yield this.isPortal() || this.isParaConnect() ? this.ctx.client.getAllWallets(this.userId) : this.ctx.client.getWallets(this.userId, true);
      return res.data.wallets.filter(
        (wallet) => !!wallet.address && (this.isParaConnect() || !this.isParaConnect() && this.isWalletSupported(entityToWallet(wallet)))
      );
    });
  }
  populateWalletAddresses() {
    return __async(this, null, function* () {
      const res = yield this.ctx.client.getWallets(this.userId, true);
      const wallets = res.data.wallets;
      wallets.forEach((entity) => {
        if (this.wallets[entity.id]) {
          this.wallets[entity.id] = __spreadValues(__spreadValues({}, entityToWallet(entity)), this.wallets[entity.id]);
        }
      });
      yield this.setWallets(this.wallets);
    });
  }
  populatePregenWalletAddresses() {
    return __async(this, null, function* () {
      const res = yield this.getPregenWallets();
      res.forEach((entity) => {
        if (this.wallets[entity.id]) {
          this.wallets[entity.id] = __spreadValues(__spreadValues({}, entityToWallet(entity)), this.wallets[entity.id]);
        }
      });
      yield this.setWallets(this.wallets);
    });
  }
  /**
   * Logs in or creates a new user using an external wallet address.
   * @param {Object} opts the options object
   * @param {string} opts.address the external wallet address to use for identification.
   * @param {TWalletType} opts.type type of external wallet to use for identification.
   * @param {string} opts.provider the name of the provider for the external wallet.
   */
  loginExternalWallet(_a) {
    return __async(this, null, function* () {
      var _b = _a, {
        externalWallet
      } = _b, urlOptions = __objRest(_b, [
        "externalWallet"
      ]);
      const externalWallets = Array.isArray(externalWallet) ? externalWallet : [externalWallet];
      if (this.externalWalletConnectionOnly || externalWallets.every((wallet) => wallet.isConnectionOnly)) {
        yield this.addExternalWallets(
          externalWallets.map((wallet) => __spreadProps(__spreadValues({}, wallet), {
            withFullParaAuth: false
          }))
        );
        return Promise.resolve({
          userId: constants.EXTERNAL_WALLET_CONNECTION_ONLY_USER_ID
        });
      }
      if (Array.isArray(externalWallet)) {
        throw new Error(
          "Cannot authenticate multiple external wallets at once. To connect multiple wallets at once, use CONNECTION_ONLY mode."
        );
      }
      this.requireApiKey();
      const serverAuthState = yield this.ctx.client.loginExternalWallet({ externalWallet });
      if (!externalWallet.withFullParaAuth && externalWallet.withVerification) {
        yield this.touchSession(true);
      }
      return __privateMethod(this, _ParaCore_instances, prepareAuthState_fn).call(this, serverAuthState, urlOptions);
    });
  }
  verifyExternalWallet(_c) {
    return __async(this, null, function* () {
      var _d = _c, {
        externalWallet,
        signedMessage,
        cosmosPublicKeyHex,
        cosmosSigner
      } = _d, urlOptions = __objRest(_d, [
        "externalWallet",
        "signedMessage",
        "cosmosPublicKeyHex",
        "cosmosSigner"
      ]);
      var _a;
      const serverAuthState = yield this.ctx.client.verifyExternalWallet(this.userId, {
        externalWallet,
        signedMessage,
        cosmosPublicKeyHex,
        cosmosSigner
      });
      if (serverAuthState.stage === "login" && ((_a = serverAuthState.loginAuthMethods) == null ? void 0 : _a.includes(AuthMethod.PIN))) {
        const { sessionLookupId } = yield this.touchSession();
        return __privateMethod(this, _ParaCore_instances, prepareLoginState_fn).call(this, serverAuthState, __spreadProps(__spreadValues({}, urlOptions), { sessionLookupId }));
      }
      return __privateMethod(this, _ParaCore_instances, prepareAuthState_fn).call(this, serverAuthState, urlOptions);
    });
  }
  verifyExternalWalletLink(opts) {
    return __async(this, null, function* () {
      const accountLinkInProgress = yield __privateMethod(this, _ParaCore_instances, assertIsLinkingAccount_fn).call(this, ["EXTERNAL_WALLET"]);
      if (!accountLinkInProgress.externalWallet) {
        throw new Error("no external wallet account link in progress");
      }
      const accounts = yield this.verifyLink(__spreadValues({
        accountLinkInProgress,
        externalWallet: accountLinkInProgress.externalWallet
      }, opts));
      return accounts;
    });
  }
  /**
   * Validates the response received from an attempted Telegram login for authenticity, then
   * creates or retrieves the corresponding Para user and prepares the Para instance to sign in with that user.
   * @param authResponse - the response JSON object received from the Telegram widget.
   * @returns `{ isValid: boolean; telegramUserId?: string; userId?: string; isNewUser?: boolean; supportedAuthMethods?: AuthMethod[]; biometricHints?: BiometricLocationHint[] }`
   */
  verifyTelegramProcess(_e) {
    return __async(this, null, function* () {
      var _f = _e, {
        telegramAuthResponse,
        isLinkAccount
      } = _f, urlOptions = __objRest(_f, [
        "telegramAuthResponse",
        "isLinkAccount"
      ]);
      try {
        switch (isLinkAccount) {
          case false: {
            const serverAuthState = yield this.ctx.client.verifyTelegram(telegramAuthResponse);
            return __privateMethod(this, _ParaCore_instances, prepareAuthState_fn).call(this, serverAuthState, urlOptions);
          }
          case true: {
            const accountLinkInProgress = yield __privateMethod(this, _ParaCore_instances, assertIsLinkingAccountOrStart_fn).call(this, "TELEGRAM");
            const accounts = yield this.verifyLink({
              accountLinkInProgress,
              telegramAuthResponse
            });
            return accounts;
          }
        }
      } catch (e) {
        throw new Error(e.message);
      }
    });
  }
  verifyTelegram(opts) {
    return __async(this, null, function* () {
      return yield this.verifyTelegramProcess(__spreadProps(__spreadValues({}, opts), { isLinkAccount: false }));
    });
  }
  verifyTelegramLink(opts) {
    return __async(this, null, function* () {
      return yield this.verifyTelegramProcess(__spreadProps(__spreadValues({}, opts), { isLinkAccount: true }));
    });
  }
  /**
   * Performs 2FA verification.
   * @param {Object} opts the options object
   * @param {string} opts.email the email to use for performing a 2FA verification.
   * @param {string} opts.verificationCode the verification code to received via 2FA.
   * @returns {Object} `{ address, initiatedAt, status, userId, walletId }`
   */
  verify2fa(_0) {
    return __async(this, arguments, function* ({ auth, verificationCode }) {
      const res = yield this.ctx.client.verify2FA(auth, verificationCode);
      return {
        initiatedAt: res.data.initiatedAt,
        status: res.data.status,
        userId: res.data.userId,
        wallets: res.data.wallets
      };
    });
  }
  /**
   * Sets up two-factor authentication for the current user.
   * @returns {string} uri - uri to use for setting up 2FA
   * */
  setup2fa() {
    return __async(this, null, function* () {
      const userId = this.assertUserId();
      const res = yield this.ctx.client.setup2FA(userId);
      return res;
    });
  }
  /**
   * Enables 2FA.
   * @param {Object} opts the options object
   * @param {string} opts.verificationCode - the verification code received via 2FA.
   */
  enable2fa(_0) {
    return __async(this, arguments, function* ({ verificationCode }) {
      const userId = this.assertUserId();
      yield this.ctx.client.enable2FA(userId, verificationCode);
    });
  }
  /**
   * Resend a verification email for the current user.
   */
  resendVerificationCode(_0) {
    return __async(this, arguments, function* ({
      type: reason = "SIGNUP"
    }) {
      let type, linkedAccountId;
      switch (reason) {
        case "SIGNUP":
        case "LOGIN":
          {
            const authInfo = this.assertIsAuthSet(["email", "phone"]);
            type = authInfo.authType.toUpperCase();
          }
          break;
        case "LINK_ACCOUNT":
          {
            const accountLinkInProgress = __privateMethod(this, _ParaCore_instances, assertIsLinkingAccount_fn).call(this, ["EMAIL", "PHONE"]);
            linkedAccountId = accountLinkInProgress.id;
            type = accountLinkInProgress.type;
          }
          break;
      }
      const userId = this.assertUserId({ allowGuestMode: true });
      if (type !== "EMAIL" && type !== "PHONE") {
        throw new Error("invalid auth type for verification code");
      }
      yield this.ctx.client.resendVerificationCode(__spreadValues({
        userId,
        type,
        linkedAccountId
      }, this.getVerificationEmailProps()));
    });
  }
  /**
   * Checks if the current session is active.
   * @returns `true` if active, `false` otherwise
   */
  isSessionActive() {
    return __async(this, null, function* () {
      if (this.externalWalletConnectionType === "CONNECTION_ONLY") {
        return true;
      }
      const { isAuthenticated, verifiedExternalWalletAddresses } = yield this.touchSession();
      if (this.externalWalletConnectionType === "VERIFICATION") {
        if (!verifiedExternalWalletAddresses) {
          return false;
        }
        const externalAddresses = Object.values(this.externalWallets).map((w) => w.id);
        return externalAddresses.every((address) => verifiedExternalWalletAddresses.includes(address));
      }
      return !!isAuthenticated;
    });
  }
  /**
   * Checks if a session is active and a wallet exists.
   * @returns `true` if active, `false` otherwise
   **/
  isFullyLoggedIn() {
    return __async(this, null, function* () {
      if (this.externalWalletConnectionType === "CONNECTION_ONLY") {
        if (!this.isReady) {
          yield this.ready();
        }
        return true;
      }
      if (this.isGuestMode) {
        return true;
      }
      const isSessionActive = yield this.isSessionActive();
      if (this.externalWalletConnectionType === "VERIFICATION") {
        return isSessionActive;
      }
      return isSessionActive && (this.isNoWalletConfig || this.currentWalletIdsArray.length > 0 && this.currentWalletIdsArray.reduce((acc, [id]) => acc && !!this.wallets[id], true));
    });
  }
  get isGuestMode() {
    return __privateGet(this, _ParaCore_instances, guestWalletIdsArray_get).length > 0 && Object.values(this.wallets).every(
      ({ userId, partnerId }) => {
        var _a;
        return partnerId === ((_a = this.partner) == null ? void 0 : _a.id) && (!userId || userId !== this.userId);
      }
    );
  }
  /**
   * Get the auth methods available to an existing user
   */
  supportedAuthMethods(auth) {
    return __async(this, null, function* () {
      const { supportedAuthMethods } = yield this.ctx.client.getSupportedAuthMethods(auth);
      const authMethods = /* @__PURE__ */ new Set();
      for (const type of supportedAuthMethods) {
        switch (type) {
          case "PASSWORD":
            authMethods.add(AuthMethod.PASSWORD);
            break;
          case "BIOMETRIC":
            authMethods.add(AuthMethod.PASSKEY);
            break;
        }
      }
      return authMethods;
    });
  }
  /**
   * Get hints associated with the users stored biometrics.
   * @deprecated
   * @returns Array containing useragents and AAGuids for stored biometrics
   */
  getUserBiometricLocationHints() {
    return __async(this, null, function* () {
      const { auth } = this.assertIsAuthSet();
      return yield this.ctx.client.getBiometricLocationHints(auth);
    });
  }
  /**
   * Waits for the session to be active.
   **/
  waitForSignup(_0) {
    return __async(this, arguments, function* ({
      isCanceled = () => false,
      onCancel,
      onPoll
    }) {
      const startedAt = Date.now();
      return new Promise((resolve, reject) => {
        (() => __async(this, null, function* () {
          yield this.touchSession();
          if (!this.isExternalWalletAuth) {
            this.externalWallets = {};
          }
          while (true) {
            try {
              if (isCanceled() || Date.now() - startedAt > constants.POLLING_TIMEOUT_MS) {
                onCancel == null ? void 0 : onCancel();
                dispatchEvent(ParaEvent.ACCOUNT_CREATION_EVENT, false, "failed to sign up user");
                return reject("canceled");
              }
              yield new Promise((_resolve) => setTimeout(_resolve, constants.POLLING_INTERVAL_MS));
              if (yield this.isSessionActive()) {
                dispatchEvent(ParaEvent.ACCOUNT_CREATION_EVENT, true);
                return resolve(true);
              }
              onPoll == null ? void 0 : onPoll();
            } catch (err) {
              console.error(err);
              onPoll == null ? void 0 : onPoll();
            }
          }
        }))();
      });
    });
  }
  waitForWalletCreation() {
    return __async(this, arguments, function* ({
      isCanceled = () => false,
      onCancel
    } = {}) {
      yield this.waitForSignup({ isCanceled, onCancel });
      const { supportedWalletTypes } = yield __privateMethod(this, _ParaCore_instances, assertPartner_fn).call(this);
      const pregenWallets = yield this.getPregenWallets();
      let recoverySecret, walletIds = {};
      if (pregenWallets.length > 0) {
        recoverySecret = yield this.claimPregenWallets();
        walletIds = supportedWalletTypes.reduce((acc, { type }) => {
          var _a;
          return __spreadProps(__spreadValues({}, acc), {
            [type]: [(_a = pregenWallets.find((w) => !!WalletSchemeTypeMap[w.scheme][type])) == null ? void 0 : _a.id]
          });
        }, {});
      }
      const created = yield this.createWalletPerType();
      recoverySecret = recoverySecret != null ? recoverySecret : created.recoverySecret;
      walletIds = __spreadValues(__spreadValues({}, walletIds), created.walletIds);
      const resp = { walletIds, recoverySecret };
      dispatchEvent(ParaEvent.ACCOUNT_SETUP_EVENT, resp);
      return resp;
    });
  }
  /**
   * Initiates a Farcaster login attempt and returns the URL for the user to connect.
   * You can create a QR code with this URI that works with Farcaster's mobile app.
   * @return {string} the Farcaster connect URI
   */
  getFarcasterConnectUri() {
    return __async(this, arguments, function* ({ appScheme } = {}) {
      const { connect_uri: connectUri } = yield this.ctx.client.initializeFarcasterLogin({ appScheme });
      return connectUri;
    });
  }
  /**
   * Awaits the response from a user's attempt to log in with Farcaster.
   * If successful, this returns the user's Farcaster username and profile picture and indicates whether the user already exists.
   * @return {Object} `{userExists: boolean; username: string; pfpUrl?: string | null }` - the user's information and whether the user already exists.
   */
  verifyFarcasterProcess(_g) {
    return __async(this, null, function* () {
      var _h = _g, {
        isCanceled = () => false,
        onConnectUri,
        onCancel,
        onPoll,
        isLinkAccount
      } = _h, urlOptions = __objRest(_h, [
        "isCanceled",
        "onConnectUri",
        "onCancel",
        "onPoll",
        "isLinkAccount"
      ]);
      let accountLinkInProgress;
      if (isLinkAccount) {
        accountLinkInProgress = yield __privateMethod(this, _ParaCore_instances, assertIsLinkingAccountOrStart_fn).call(this, "FARCASTER");
      }
      if (onConnectUri) {
        const connectUri = yield this.getFarcasterConnectUri();
        onConnectUri(connectUri);
      }
      return new Promise((resolve, reject) => {
        (() => __async(this, null, function* () {
          const startedAt = Date.now();
          while (true) {
            try {
              if (isCanceled() || Date.now() - startedAt > constants.POLLING_TIMEOUT_MS) {
                onCancel == null ? void 0 : onCancel();
                return reject("CANCELED");
              }
              yield new Promise((_resolve) => setTimeout(_resolve, constants.POLLING_INTERVAL_MS));
              switch (isLinkAccount) {
                case false:
                  {
                    const serverAuthState = yield this.ctx.client.getFarcasterAuthStatus();
                    if (isServerAuthState(serverAuthState)) {
                      const authState = yield __privateMethod(this, _ParaCore_instances, prepareAuthState_fn).call(this, serverAuthState, urlOptions);
                      return resolve(authState);
                    }
                  }
                  break;
                case true: {
                  const result = yield this.verifyLink({
                    accountLinkInProgress
                  });
                  if ("isConflict" in result) {
                    throw new Error(AccountLinkError.Conflict);
                  }
                  return resolve(result);
                }
              }
              onPoll == null ? void 0 : onPoll();
            } catch (e) {
              if (!isLinkAccount || e.message === AccountLinkError.Conflict) {
                return reject(e.message);
              }
            }
          }
        }))();
      });
    });
  }
  verifyFarcaster(opts) {
    return __async(this, null, function* () {
      return yield this.verifyFarcasterProcess(__spreadProps(__spreadValues({}, opts), { isLinkAccount: false }));
    });
  }
  verifyFarcasterLink(opts) {
    return __async(this, null, function* () {
      return yield this.verifyFarcasterProcess(__spreadProps(__spreadValues({}, opts), { isLinkAccount: true }));
    });
  }
  getOAuthUrl(opts) {
    return __async(this, null, function* () {
      var _a;
      const sessionLookupId = (_a = opts.sessionLookupId) != null ? _a : yield this.prepareLogin();
      return __privateMethod(this, _ParaCore_instances, getOAuthUrl_fn).call(this, __spreadProps(__spreadValues({}, opts), { sessionLookupId }));
    });
  }
  /**
   * Awaits the response from a user's attempt to log in with OAuth.
   * If successful, this returns the user's email address and indicates whether the user already exists.
   *
   * @param {Object} opts the options object.
   * @param {Window} [opts.popupWindow] the popup window being used for login.
   * @return {Object} `{ email?: string; isError?: boolean; userExists: boolean; }` the result data
   */
  verifyOAuthProcess(_i) {
    return __async(this, null, function* () {
      var _j = _i, {
        method,
        appScheme,
        isCanceled = () => false,
        onCancel,
        onPoll,
        onOAuthUrl,
        onOAuthPopup,
        isLinkAccount
      } = _j, urlOptions = __objRest(_j, [
        "method",
        "appScheme",
        "isCanceled",
        "onCancel",
        "onPoll",
        "onOAuthUrl",
        "onOAuthPopup",
        "isLinkAccount"
      ]);
      let popupWindow;
      if (onOAuthPopup) {
        try {
          popupWindow = yield this.platformUtils.openPopup("about:blank", { type: PopupType.OAUTH });
        } catch (error) {
          throw new Error(`Failed to open OAuth popup: ${error}`);
        }
      }
      let sessionLookupId, accountLinkInProgress;
      if (onOAuthUrl || onOAuthPopup) {
        if (isLinkAccount) {
          accountLinkInProgress = yield __privateMethod(this, _ParaCore_instances, assertIsLinkingAccountOrStart_fn).call(this, method);
          sessionLookupId = (yield this.touchSession()).sessionLookupId;
        } else {
          sessionLookupId = yield this.prepareLogin();
        }
        const oAuthUrl = yield __privateMethod(this, _ParaCore_instances, getOAuthUrl_fn).call(this, { method, appScheme, sessionLookupId, accountLinkInProgress });
        switch (true) {
          case !!onOAuthUrl: {
            onOAuthUrl(oAuthUrl);
            break;
          }
          case (!!onOAuthPopup && !!popupWindow): {
            popupWindow.location.href = oAuthUrl;
            onOAuthPopup(popupWindow);
            break;
          }
        }
      } else {
        ({ sessionLookupId } = yield this.touchSession());
      }
      const startedAt = Date.now();
      return new Promise((resolve, reject) => {
        (() => __async(this, null, function* () {
          while (true) {
            try {
              if (isCanceled() || Date.now() - startedAt > constants.POLLING_TIMEOUT_MS) {
                onCancel == null ? void 0 : onCancel();
                return reject(AccountLinkError.Canceled);
              }
              yield new Promise((_resolve) => setTimeout(_resolve, constants.POLLING_INTERVAL_MS));
              switch (isLinkAccount) {
                case false:
                  {
                    const serverAuthState = yield this.ctx.client.verifyOAuth();
                    if (isServerAuthState(serverAuthState)) {
                      const authState = yield __privateMethod(this, _ParaCore_instances, prepareAuthState_fn).call(this, serverAuthState, __spreadProps(__spreadValues({}, urlOptions), { sessionLookupId }));
                      return resolve(authState);
                    }
                  }
                  break;
                case true: {
                  const accounts = yield this.verifyLink({ accountLinkInProgress });
                  return resolve(accounts);
                }
              }
              onPoll == null ? void 0 : onPoll();
            } catch (err) {
              if (isLinkAccount && err.message === AccountLinkError.Conflict) {
                return reject(err.message);
              }
              onPoll == null ? void 0 : onPoll();
            }
          }
        }))();
      });
    });
  }
  verifyOAuth(opts) {
    return __async(this, null, function* () {
      return yield this.verifyOAuthProcess(__spreadProps(__spreadValues({}, opts), { isLinkAccount: false }));
    });
  }
  verifyOAuthLink(opts) {
    return __async(this, null, function* () {
      return yield this.verifyOAuthProcess(__spreadProps(__spreadValues({}, opts), { isLinkAccount: true }));
    });
  }
  /**
   * Waits for the session to be active and sets up the user.
   *
   * @param {Object} opts the options object
   * @param {Window} [opts.popupWindow] the popup window being used for login.
   * @param {boolean} [opts.skipSessionRefresh] whether to skip refreshing the session.
   * @returns {Object} `{ isComplete: boolean; isError: boolean; needsWallet: boolean; partnerId: string; }` the result data
   **/
  waitForLogin() {
    return __async(this, arguments, function* ({
      isCanceled = () => false,
      onCancel,
      onPoll,
      skipSessionRefresh = false
    } = {}) {
      const startedAt = Date.now();
      return new Promise((resolve, reject) => {
        (() => __async(this, null, function* () {
          var _a;
          if (!this.isExternalWalletAuth) {
            this.externalWallets = {};
          }
          while (true) {
            if (isCanceled() || Date.now() - startedAt > constants.POLLING_TIMEOUT_MS) {
              dispatchEvent(ParaEvent.LOGIN_EVENT, { isComplete: false }, "failed to setup user");
              onCancel == null ? void 0 : onCancel();
              return reject("canceled");
            }
            yield new Promise((resolve2) => setTimeout(resolve2, constants.POLLING_INTERVAL_MS));
            try {
              let session = yield this.touchSession();
              if (!session.isAuthenticated) {
                onPoll == null ? void 0 : onPoll();
                continue;
              }
              session = yield this.userSetupAfterLogin();
              const needsWallet = (_a = session.needsWallet) != null ? _a : false;
              if (!needsWallet) {
                if (this.currentWalletIdsArray.length === 0) {
                  onPoll == null ? void 0 : onPoll();
                  continue;
                }
              }
              const fetchedWallets = yield this.fetchWallets();
              const tempSharesRes = yield this.getTransmissionKeyShares();
              if (tempSharesRes.data.temporaryShares.length === fetchedWallets.length) {
                yield this.setupAfterLogin({ temporaryShares: tempSharesRes.data.temporaryShares, skipSessionRefresh });
                yield this.claimPregenWallets();
                const resp = {
                  needsWallet: needsWallet || Object.values(this.wallets).length === 0,
                  partnerId: session.partnerId
                };
                dispatchEvent(ParaEvent.LOGIN_EVENT, resp);
                return resolve(resp);
              }
              onPoll == null ? void 0 : onPoll();
            } catch (err) {
              console.error(err);
              onPoll == null ? void 0 : onPoll();
            }
          }
        }))();
      });
    });
  }
  /**
   * Updates the session with the user management server, possibly
   * opening a popup to refresh the session.
   *
   * @param {Object} opts the options object.
   * @param {boolean} [shouldOpenPopup] - if `true`, the running device will open a popup to reauthenticate the user.
   * @returns a URL for the user to reauthenticate.
   **/
  refreshSession() {
    return __async(this, arguments, function* ({
      shouldOpenPopup = false
    } = {}) {
      const { sessionId } = yield this.touchSession(true);
      if (!this.loginEncryptionKeyPair) {
        yield this.setLoginEncryptionKeyPair();
      }
      const link = yield this.getLoginUrl({
        sessionId
      });
      if (shouldOpenPopup) {
        yield this.platformUtils.openPopup(link);
      }
      return link;
    });
  }
  /**
   * Call this method after login to ensure that the user ID is set
   * internally.
   **/
  userSetupAfterLogin() {
    return __async(this, null, function* () {
      const session = yield this.touchSession();
      yield this.setUserId(session.userId);
      if (session.currentWalletIds && session.currentWalletIds !== this.currentWalletIds)
        yield this.setCurrentWalletIds(session.currentWalletIds, {
          sessionLookupId: this.isPortal() ? session.sessionLookupId : void 0
        });
      return session;
    });
  }
  /**
   * Get transmission shares associated with session.
   * @param {Object} opts the options object.
   * @param {boolean} opts.isForNewDevice - true if this device is registering.
   * @returns - transmission keyshares.
   **/
  getTransmissionKeyShares() {
    return __async(this, arguments, function* ({ isForNewDevice = false } = {}) {
      const session = yield this.touchSession();
      const sessionLookupId = isForNewDevice ? `${session.sessionLookupId}-new-device` : session.sessionLookupId;
      return this.ctx.client.getTransmissionKeyshares(this.userId, sessionLookupId);
    });
  }
  /**
   * Call this method after login to perform setup.
   * @param {Object} opts the options object.
   * @param {any[]} opts.temporaryShares optional temporary shares to use for decryption.
   * @param {boolean} [opts.skipSessionRefresh] - whether or not to skip refreshing the session.
   **/
  setupAfterLogin() {
    return __async(this, arguments, function* ({
      temporaryShares,
      skipSessionRefresh = false
    } = {}) {
      if (!temporaryShares) {
        temporaryShares = (yield this.getTransmissionKeyShares()).data.temporaryShares;
      }
      temporaryShares.forEach((share) => {
        const signer = decryptWithPrivateKey(this.loginEncryptionKeyPair.privateKey, share.encryptedShare, share.encryptedKey);
        this.wallets[share.walletId] = {
          id: share.walletId,
          signer
        };
      });
      yield this.deleteLoginEncryptionKeyPair();
      yield this.populateWalletAddresses();
      yield this.touchSession(!skipSessionRefresh);
    });
  }
  /**
   * Distributes a new wallet recovery share.
   * @param {Object} opts the options object.
   * @param {string} opts.walletId the wallet to distribute the recovery share for.
   * @param {string} opts.userShare optional user share generate the recovery share from. Defaults to the signer from the passed in walletId
   * @param {boolean} opts.skipBiometricShareCreation whether or not to skip biometric share creation. Used when regenerating recovery shares.
   * @param {boolean} opts.forceRefreshRecovery whether or not to force recovery secret regeneration. Used when regenerating recovery shares.
   * @returns {string} the recovery share.
   **/
  distributeNewWalletShare(_0) {
    return __async(this, arguments, function* ({
      walletId,
      userShare,
      skipBiometricShareCreation = false,
      forceRefresh = false
    }) {
      let userSigner = userShare;
      if (!userSigner) {
        userSigner = this.wallets[walletId].signer;
      }
      const recoveryShare = skipBiometricShareCreation ? yield sendRecoveryForShare({
        ctx: this.ctx,
        userId: this.userId,
        walletId,
        userSigner,
        emailProps: this.getBackupKitEmailProps(),
        forceRefresh
      }) : yield distributeNewShare({
        ctx: this.ctx,
        userId: this.userId,
        walletId,
        userShare: userSigner,
        emailProps: this.getBackupKitEmailProps()
      });
      return recoveryShare;
    });
  }
  waitForWalletAddress(walletId) {
    return __async(this, null, function* () {
      let maxPolls = 0;
      while (true) {
        try {
          if (maxPolls === 10) {
            break;
          }
          ++maxPolls;
          const res = yield this.ctx.client.getWallets(this.userId);
          const wallet = res.data.wallets.find((w) => w.id === walletId);
          if (wallet && wallet.address) {
            return;
          }
          yield new Promise((resolve) => setTimeout(resolve, constants.SHORT_POLLING_INTERVAL_MS));
        } catch (err) {
          console.error(err);
        }
      }
      throw new Error("timed out waiting for wallet address");
    });
  }
  /**
   * Waits for a pregen wallet address to be created.
   *
   * @param pregenIdentifier - the identifier of the user the pregen wallet is associated with.
   * @param walletId - the wallet id
   * @param pregenIdentifierType - the identifier type of the user the pregen wallet is associated with.
   * @returns - recovery share.
   **/
  waitForPregenWalletAddress(walletId) {
    return __async(this, null, function* () {
      let maxPolls = 0;
      while (true) {
        try {
          if (maxPolls === 10) {
            break;
          }
          ++maxPolls;
          const res = yield this.getPregenWallets();
          const wallet = res.find((w) => w.id === walletId);
          if (wallet && wallet.address) {
            return;
          }
          yield new Promise((resolve) => setTimeout(resolve, constants.SHORT_POLLING_INTERVAL_MS));
        } catch (err) {
          console.error(err);
        }
      }
      throw new Error("timed out waiting for wallet address");
    });
  }
  /**
   * Creates several new wallets with the desired types. If no types are provided, this method
   * will create one for each of the non-optional types specified in the instance's `supportedWalletTypes`
   * object that are not already present. This is automatically called upon account creation to ensure that
   * the user has a wallet of each required type.
   *
   * @param {Object} [opts] the options object.
   * @param {boolean} [opts.skipDistribute] if `true`, the wallets' recovery share will not be distributed.
   * @param {TWalletType[]} [opts.types] the types of wallets to create.
   * @returns {Object} the wallets created, their ids, and the recovery secret.
   **/
  createWalletPerType() {
    return __async(this, arguments, function* ({
      skipDistribute = false,
      types
    } = {}) {
      const wallets = [];
      const walletIds = {};
      let recoverySecret;
      for (const type of yield this.getTypesToCreate(types)) {
        const [wallet, recoveryShare] = yield this.createWallet({ type, skipDistribute });
        wallets.push(wallet);
        getEquivalentTypes(type).filter((t) => !!this.isWalletTypeEnabled[t]).forEach((t) => {
          walletIds[t] = [wallet.id];
        });
        if (recoveryShare) {
          recoverySecret = recoveryShare;
        }
      }
      return { wallets, walletIds, recoverySecret };
    });
  }
  /**
   * Refresh the current user share for a wallet.
   *
   * @param {Object} opts the options object.
   * @param {string} opts.walletId the wallet id to refresh.
   * @param {string} opts.share the current user share.
   * @param {string} [opts.oldPartnerId] the current partner id.
   * @param {string} [opts.newPartnerId] the new partner id to set, if any.
   * @param {string} [opts.keyShareProtocolId]
   * @param {boolean} [opts.redistributeBackupEncryptedShares] whether or not to redistribute backup encrypted shares.
   * @returns {Object} the new user share and recovery secret.
   **/
  refreshShare(_0) {
    return __async(this, arguments, function* ({
      walletId,
      share,
      oldPartnerId,
      newPartnerId,
      keyShareProtocolId,
      redistributeBackupEncryptedShares
    }) {
      const { signer, protocolId } = yield this.platformUtils.refresh(
        this.ctx,
        this.retrieveSessionCookie(),
        this.userId,
        walletId,
        share,
        oldPartnerId,
        newPartnerId,
        keyShareProtocolId
      );
      const recoverySecret = yield distributeNewShare({
        ctx: this.ctx,
        userId: this.userId,
        walletId,
        userShare: signer,
        ignoreRedistributingBackupEncryptedShare: !redistributeBackupEncryptedShares,
        emailProps: this.getBackupKitEmailProps(),
        partnerId: newPartnerId,
        protocolId
      });
      return { signer, recoverySecret, protocolId };
    });
  }
  /**
   * Creates a new wallet.
   * @param {Object} opts the options object.
   * @param {TWalletType} opts.type the type of wallet to create.
   * @param {boolean} opts.skipDistribute - if true, recovery share will not be distributed.
   * @returns {[Wallet, string | null]} `[wallet, recoveryShare]` - the wallet object and the new recovery share.
   **/
  createWallet() {
    return __async(this, arguments, function* ({
      type: _type,
      skipDistribute = false
    } = {}) {
      var _a, _b;
      this.requireApiKey();
      const { supportedWalletTypes } = yield __privateMethod(this, _ParaCore_instances, assertPartner_fn).call(this);
      const walletType = yield this.assertIsValidWalletType(
        _type != null ? _type : (_a = supportedWalletTypes.find(({ optional }) => !optional)) == null ? void 0 : _a.type
      );
      let signer;
      let wallet;
      let keygenRes;
      switch (walletType) {
        case "SOLANA": {
          keygenRes = yield this.platformUtils.ed25519Keygen(
            this.ctx,
            this.userId,
            this.retrieveSessionCookie(),
            this.getBackupKitEmailProps()
          );
          break;
        }
        default: {
          keygenRes = yield this.platformUtils.keygen(
            this.ctx,
            this.userId,
            walletType,
            null,
            this.retrieveSessionCookie(),
            this.getBackupKitEmailProps()
          );
          break;
        }
      }
      const walletId = keygenRes.walletId;
      signer = keygenRes.signer;
      this.wallets[walletId] = {
        id: walletId,
        signer,
        scheme: walletType === "SOLANA" ? "ED25519" : "DKLS",
        type: walletType
      };
      wallet = this.wallets[walletId];
      yield this.waitForWalletAddress(wallet.id);
      yield this.populateWalletAddresses();
      let recoveryShare = null;
      if (!skipDistribute) {
        recoveryShare = yield distributeNewShare({
          ctx: this.ctx,
          userId: this.userId,
          walletId: wallet.id,
          userShare: signer,
          emailProps: this.getBackupKitEmailProps()
        });
      }
      yield this.setCurrentWalletIds(__spreadProps(__spreadValues({}, this.currentWalletIds), {
        [walletType]: [.../* @__PURE__ */ new Set([...(_b = this.currentWalletIds[walletType]) != null ? _b : [], walletId])]
      }));
      const walletNoSigner = __spreadValues({}, wallet);
      delete walletNoSigner.signer;
      dispatchEvent(ParaEvent.WALLET_CREATED, {
        wallet: walletNoSigner,
        recoverySecret: recoveryShare
      });
      return [wallet, recoveryShare];
    });
  }
  createPregenWallet(opts) {
    return __async(this, null, function* () {
      return yield __privateMethod(this, _ParaCore_instances, createPregenWallet_fn).call(this, opts);
    });
  }
  /**
   * Creates new pregenerated wallets for each desired type.
   * If no types are provided, this method will create one for each of the non-optional types
   * specified in the instance's `supportedWalletTypes` array that are not already present.
   * @param {Object} opts the options object.
   * @param {string} opts.pregenIdentifier the identifier to associate each wallet with.
   * @param {TPregenIdentifierType} opts.pregenIdentifierType - either `'EMAIL'` or `'PHONE'`.
   * @param {TWalletType[]} [opts.types] the wallet types to create. Defaults to any types the instance supports that are not already present.
   * @returns {Wallet[]} an array containing the created wallets.
   **/
  createPregenWalletPerType(_0) {
    return __async(this, arguments, function* ({
      types,
      pregenId
    }) {
      const wallets = [];
      for (const type of yield this.getTypesToCreate(types)) {
        const wallet = yield this.createPregenWallet({ type, pregenId });
        wallets.push(wallet);
      }
      return wallets;
    });
  }
  /**
   * Claims a pregenerated wallet.
   * @param {Object} opts the options object.
   * @param {string} opts.pregenIdentifier string the identifier of the user claiming the wallet
   * @param {TPregenIdentifierType} opts.pregenIdentifierType type of the identifier of the user claiming the wallet
   * @returns {[Wallet, string | null]} `[wallet, recoveryShare]` - the wallet object and the new recovery share.
   **/
  claimPregenWallets() {
    return __async(this, arguments, function* ({
      pregenId
    } = {}) {
      var _a;
      this.requireApiKey();
      const pregenWallets = pregenId ? yield this.getPregenWallets({ pregenId }) : yield this.getPregenWallets();
      if (pregenWallets.length === 0) {
        return void 0;
      }
      const missingWallets = pregenWallets.filter((wallet) => !this.wallets[wallet.id]);
      if (missingWallets.length > 0) {
        throw new Error(
          `Cannot claim pregen wallets because wallet data is missing. Please call setUserShare first to load the wallet data for the following wallet IDs: ${missingWallets.map((w) => w.id).join(", ")}`
        );
      }
      let newRecoverySecret;
      const { walletIds } = yield this.ctx.client.claimPregenWallets({
        userId: this.userId,
        walletIds: pregenWallets.map((w) => w.id)
      });
      for (const walletId of walletIds) {
        const wallet = this.wallets[walletId];
        let refreshedShare;
        if (wallet.scheme === "ED25519") {
          const distributeRes = yield distributeNewShare({
            ctx: this.ctx,
            userId: this.userId,
            walletId: wallet.id,
            userShare: this.wallets[wallet.id].signer,
            emailProps: this.getBackupKitEmailProps(),
            partnerId: wallet.partnerId
          });
          if (distributeRes.length > 0) {
            newRecoverySecret = distributeRes;
          }
        } else {
          refreshedShare = yield this.refreshShare({
            walletId: wallet.id,
            share: this.wallets[wallet.id].signer,
            oldPartnerId: wallet.partnerId,
            newPartnerId: wallet.partnerId,
            redistributeBackupEncryptedShares: true
          });
          if (refreshedShare.recoverySecret) {
            newRecoverySecret = refreshedShare.recoverySecret;
          }
        }
        this.wallets[wallet.id] = __spreadProps(__spreadValues({}, this.wallets[wallet.id]), {
          signer: (_a = refreshedShare == null ? void 0 : refreshedShare.signer) != null ? _a : wallet.signer,
          userId: this.userId,
          pregenIdentifier: void 0,
          pregenIdentifierType: void 0
        });
        const walletNoSigner = __spreadValues({}, this.wallets[wallet.id]);
        delete walletNoSigner.signer;
        dispatchEvent(ParaEvent.PREGEN_WALLET_CLAIMED, {
          wallet: walletNoSigner,
          recoverySecret: newRecoverySecret
        });
      }
      yield this.setWallets(this.wallets);
      return newRecoverySecret;
    });
  }
  /**
   * Updates the identifier for a pregen wallet.
   * @param {Object} opts the options object.
   * @param {string} opts.walletId the pregen wallet ID
   * @param {string} opts.newPregenIdentifier the new identtifier
   * @param {TPregenIdentifierType} opts.newPregenIdentifierType: the new identifier type
   **/
  updatePregenWalletIdentifier(_0) {
    return __async(this, arguments, function* ({
      walletId,
      newPregenId
    }) {
      this.requireApiKey();
      const [newPregenIdentifierType, newPregenIdentifier] = toPregenTypeAndId(newPregenId);
      yield this.ctx.client.updatePregenWallet(walletId, {
        pregenIdentifier: newPregenIdentifier,
        pregenIdentifierType: newPregenIdentifierType
      });
      if (!!this.wallets[walletId]) {
        this.wallets[walletId] = __spreadProps(__spreadValues({}, this.wallets[walletId]), {
          pregenIdentifier: newPregenIdentifier,
          pregenIdentifierType: newPregenIdentifierType
        });
        yield this.setWallets(this.wallets);
      }
    });
  }
  /**
   * Checks if a pregen Wallet exists for the given identifier with the current partner.
   * @param {Object} opts the options object.
   * @param {string} opts.pregenIdentifier string the identifier of the user claiming the wallet
   * @param {TPregenIdentifierType} opts.pregenIdentifierType type of the string of the identifier of the user claiming the wallet
   * @returns {boolean} whether the pregen wallet exists
   **/
  hasPregenWallet(_0) {
    return __async(this, arguments, function* ({ pregenId }) {
      this.requireApiKey();
      const [pregenIdentifierType, pregenIdentifier] = toPregenTypeAndId(pregenId);
      const wallets = yield this.getPregenWallets({ pregenId });
      const wallet = wallets.find(
        (w) => w.pregenIdentifier === pregenIdentifier && w.pregenIdentifierType === pregenIdentifierType
      );
      if (!wallet) {
        return false;
      }
      return true;
    });
  }
  /**
   * Get pregen wallets for the given identifier.
   * @param {Object} opts the options object.
   * @param {string} opts.pregenIdentifier - the identifier of the user claiming the wallet
   * @param {TPregenIdentifierType} opts.pregenIdentifierType - type of the identifier of the user claiming the wallet
   * @returns {Promise<WalletEntity[]>} the array of found wallets
   **/
  getPregenWallets() {
    return __async(this, arguments, function* ({ pregenId } = {}) {
      this.requireApiKey();
      const res = yield this.ctx.client.getPregenWallets(
        pregenId ? toPregenIds(pregenId) : this.pregenIds,
        this.isPortal(),
        this.userId
      );
      return res.wallets.filter((w) => this.isWalletSupported(entityToWallet(w)));
    });
  }
  createGuestWallets() {
    return __async(this, null, function* () {
      let error;
      if (__privateGet(this, _isCreateGuestWalletsPending)) {
        error = new Error("Guest wallets creation already in progress");
        dispatchEvent(ParaEvent.GUEST_WALLETS_CREATED, null, error.message);
        throw error;
      }
      if (this.isGuestMode) {
        error = new Error("Guest wallets already created");
        dispatchEvent(ParaEvent.GUEST_WALLETS_CREATED, null, error.message);
        throw error;
      }
      try {
        __privateSet(this, _isCreateGuestWalletsPending, true);
        const { supportedWalletTypes } = yield __privateMethod(this, _ParaCore_instances, assertPartner_fn).call(this);
        const wallets = [];
        const guestId = newUuid();
        for (const type of yield this.getTypesToCreate(
          supportedWalletTypes.filter(({ optional }) => !optional).map(({ type: type2 }) => type2)
        )) {
          const wallet = yield __privateMethod(this, _ParaCore_instances, createPregenWallet_fn).call(this, { type, pregenId: { guestId } });
          wallets.push(wallet);
        }
        dispatchEvent(ParaEvent.GUEST_WALLETS_CREATED, wallets);
        __privateSet(this, _isCreateGuestWalletsPending, false);
        return wallets;
      } catch (e) {
        dispatchEvent(ParaEvent.GUEST_WALLETS_CREATED, null, error == null ? void 0 : error.message);
        __privateSet(this, _isCreateGuestWalletsPending, false);
        throw error;
      }
    });
  }
  encodeWalletBase64(wallet) {
    const walletJson = JSON.stringify(wallet);
    const base64Wallet = Buffer.from(walletJson).toString("base64");
    return base64Wallet;
  }
  /**
   * Encodes the current wallets encoded in Base 64.
   * @returns {string} the encoded wallet string
   **/
  getUserShare() {
    if (Object.values(this.wallets).length === 0) {
      return null;
    }
    return Object.values(this.wallets).map((wallet) => this.encodeWalletBase64(wallet)).join("-");
  }
  /**
   * Sets the current wallets from a Base 64 string.
   * @param {string} base64Wallet the encoded wallet string
   **/
  setUserShare(base64Wallets) {
    return __async(this, null, function* () {
      if (!base64Wallets) {
        return;
      }
      const base64WalletsSplit = base64Wallets.split("-");
      for (const base64Wallet of base64WalletsSplit) {
        const walletJson = Buffer.from(base64Wallet, "base64").toString();
        const wallet = migrateWallet(JSON.parse(walletJson));
        this.wallets[wallet.id] = wallet;
        yield this.setWallets(this.wallets);
      }
    });
  }
  getTransactionReviewUrl(transactionId, timeoutMs) {
    return __async(this, null, function* () {
      return this.constructPortalUrl("txReview", {
        pathId: transactionId,
        params: {
          email: this.email,
          timeoutMs: timeoutMs == null ? void 0 : timeoutMs.toString()
        }
      });
    });
  }
  getOnRampTransactionUrl(_0) {
    return __async(this, arguments, function* ({
      purchaseId
    }) {
      return this.constructPortalUrl("onRamp", {
        pathId: purchaseId
      });
    });
  }
  /**
   * Signs a message using one of the current wallets.
   *
   * If you want to sign the keccak256 hash of a message, hash the
   * message first and then pass in the base64 encoded hash.
   * @param {Object} opts the options object.
   * @param {string} opts.walletId the id of the wallet to sign with.
   * @param {string} opts.messageBase64 the base64 encoding of exact message that should be signed
   * @param {number} [opts.timeout] optional timeout in milliseconds. If not present, defaults to 30 seconds.
   * @param {string} [opts.cosmosSignDocBase64] the Cosmos `SignDoc` in base64, if applicable
   **/
  signMessage(_0) {
    return __async(this, arguments, function* ({
      walletId,
      messageBase64,
      timeoutMs = 3e4,
      cosmosSignDocBase64,
      isCanceled = () => false,
      onCancel,
      onPoll
    }) {
      this.assertIsValidWalletId(walletId);
      const wallet = this.wallets[walletId];
      let signerId = this.userId;
      if (wallet.partnerId && !wallet.userId) {
        signerId = wallet.partnerId;
      }
      let signRes = yield this.signMessageInner({ wallet, signerId, messageBase64, cosmosSignDocBase64 });
      let timeStart = Date.now();
      if (signRes.pendingTransactionId) {
        yield this.platformUtils.openPopup(
          yield this.getTransactionReviewUrl(signRes.pendingTransactionId, timeoutMs),
          { type: cosmosSignDocBase64 ? PopupType.SIGN_TRANSACTION_REVIEW : PopupType.SIGN_MESSAGE_REVIEW }
        );
      } else {
        dispatchEvent(ParaEvent.SIGN_MESSAGE_EVENT, signRes);
        return signRes;
      }
      while (true) {
        if (isCanceled() || Date.now() - timeStart > timeoutMs) {
          onCancel == null ? void 0 : onCancel();
          break;
        }
        yield new Promise((resolve) => setTimeout(resolve, constants.POLLING_INTERVAL_MS));
        try {
          yield this.ctx.client.getPendingTransaction(this.userId, signRes.pendingTransactionId);
        } catch (err) {
          const error = new TransactionReviewDenied();
          dispatchEvent(ParaEvent.SIGN_MESSAGE_EVENT, signRes, error.message);
          throw error;
        }
        signRes = yield this.signMessageInner({ wallet, signerId, messageBase64, cosmosSignDocBase64 });
        if (signRes.pendingTransactionId) {
          onPoll == null ? void 0 : onPoll();
          continue;
        } else {
          break;
        }
      }
      if (signRes.pendingTransactionId) {
        const error = new TransactionReviewTimeout(
          yield this.getTransactionReviewUrl(signRes.pendingTransactionId),
          signRes.pendingTransactionId
        );
        dispatchEvent(ParaEvent.SIGN_MESSAGE_EVENT, signRes, error.message);
        throw error;
      }
      dispatchEvent(ParaEvent.SIGN_MESSAGE_EVENT, signRes);
      return signRes;
    });
  }
  signMessageInner(_0) {
    return __async(this, arguments, function* ({
      wallet,
      signerId,
      messageBase64,
      cosmosSignDocBase64
    }) {
      let signRes;
      switch (wallet.scheme) {
        case "ED25519":
          signRes = yield this.platformUtils.ed25519Sign(
            this.ctx,
            signerId,
            wallet.id,
            wallet.signer,
            messageBase64,
            this.retrieveSessionCookie()
          );
          break;
        default:
          signRes = yield this.platformUtils.signMessage(
            this.ctx,
            signerId,
            wallet.id,
            wallet.signer,
            messageBase64,
            this.retrieveSessionCookie(),
            wallet.scheme === "DKLS",
            cosmosSignDocBase64
          );
          break;
      }
      return signRes;
    });
  }
  /**
   * Signs a transaction.
   * @param {Object} opts the options object.
   * @param {string} opts.walletId the id of the wallet to sign with.
   * @param {string} opts.rlpEncodedTxBase64 the transaction to sign, in RLP base64 encoding
   * @param {string} [opts.chainId] the EVM chain id of the chain the transaction is being sent on, if applicable
   * @param {number} [opts.timeoutMs] the amount of time to wait for the user to sign the transaction, in milliseconds
   **/
  signTransaction(_0) {
    return __async(this, arguments, function* ({
      walletId,
      rlpEncodedTxBase64,
      chainId,
      timeoutMs = 3e4,
      isCanceled = () => false,
      onCancel,
      onPoll
    }) {
      this.assertIsValidWalletId(walletId);
      const wallet = this.wallets[walletId];
      let signerId = this.userId;
      if (wallet.partnerId && !wallet.userId) {
        signerId = wallet.partnerId;
      }
      let signRes = yield this.platformUtils.signTransaction(
        this.ctx,
        signerId,
        walletId,
        this.wallets[walletId].signer,
        rlpEncodedTxBase64,
        chainId,
        this.retrieveSessionCookie(),
        wallet.scheme === "DKLS"
      );
      let timeStart = Date.now();
      if (signRes.pendingTransactionId) {
        yield this.platformUtils.openPopup(
          yield this.getTransactionReviewUrl(signRes.pendingTransactionId, timeoutMs),
          { type: PopupType.SIGN_TRANSACTION_REVIEW }
        );
      } else {
        dispatchEvent(ParaEvent.SIGN_TRANSACTION_EVENT, signRes);
        return signRes;
      }
      while (true) {
        if (isCanceled() || Date.now() - timeStart > timeoutMs) {
          onCancel == null ? void 0 : onCancel();
          break;
        }
        yield new Promise((resolve) => setTimeout(resolve, constants.POLLING_INTERVAL_MS));
        try {
          yield this.ctx.client.getPendingTransaction(this.userId, signRes.pendingTransactionId);
        } catch (err) {
          const error = new TransactionReviewDenied();
          dispatchEvent(ParaEvent.SIGN_TRANSACTION_EVENT, signRes, error.message);
          throw error;
        }
        signRes = yield this.platformUtils.signTransaction(
          this.ctx,
          signerId,
          walletId,
          this.wallets[walletId].signer,
          rlpEncodedTxBase64,
          chainId,
          this.retrieveSessionCookie(),
          wallet.scheme === "DKLS"
        );
        if (signRes.pendingTransactionId) {
          onPoll == null ? void 0 : onPoll();
          continue;
        } else {
          break;
        }
      }
      if (signRes.pendingTransactionId) {
        const error = new TransactionReviewTimeout(
          yield this.getTransactionReviewUrl(signRes.pendingTransactionId),
          signRes.pendingTransactionId
        );
        dispatchEvent(ParaEvent.SIGN_TRANSACTION_EVENT, signRes, error.message);
        throw error;
      }
      dispatchEvent(ParaEvent.SIGN_TRANSACTION_EVENT, signRes);
      return signRes;
    });
  }
  isProviderModalDisabled() {
    return !!this.disableProviderModal;
  }
  /**
   * Starts a on-ramp or off-ramp transaction and returns the Para Portal link for the user to finalize and complete it.
   * @param {Object} opts the options object
   * @param {OnRampPurchaseCreateParams} opts.params the transaction settings.
   * @param {boolean} opts.shouldOpenPopup if `true`, a popup window with the link will be opened.
   * @param {string} opts.walletId the wallet ID to use for the transaction, where funds will be sent or withdrawn.
   * @param {string} opts.externalWalletAddress the external wallet address to send funds to or withdraw funds from, if using an external wallet.
   **/
  initiateOnRampTransaction(options) {
    return __async(this, null, function* () {
      var _b;
      const _a = options, { params, shouldOpenPopup } = _a, walletParams = __objRest(_a, ["params", "shouldOpenPopup"]);
      const onRampPurchase = yield this.ctx.client.createOnRampPurchase(__spreadValues({
        userId: this.userId,
        params: __spreadProps(__spreadValues({}, params), {
          address: (_b = walletParams.externalWalletAddress) != null ? _b : this.getDisplayAddress(walletParams.walletId, { addressType: params.walletType })
        })
      }, walletParams));
      const portalUrl = yield this.getOnRampTransactionUrl(__spreadValues({
        purchaseId: onRampPurchase.id,
        providerKey: onRampPurchase.providerKey
      }, walletParams));
      if (shouldOpenPopup) {
        const onRampWindow = yield this.platformUtils.openPopup(portalUrl, { type: PopupType.ON_RAMP_TRANSACTION });
        this.onRampPopup = { window: onRampWindow, onRampPurchase };
      }
      return { onRampPurchase, portalUrl };
    });
  }
  /**
   * Returns `true` if session was successfully kept alive, `false` otherwise.
   **/
  keepSessionAlive() {
    return __async(this, null, function* () {
      try {
        yield this.ctx.client.keepSessionAlive(this.userId);
        return true;
      } catch (err) {
        return false;
      }
    });
  }
  /**
   * Serialize the current session for import by another Para instance.
   * @param {boolean} excludeSigners - whether or not to exclude the signer from the exported wallets.
   * @returns {string} the serialized session
   */
  exportSession({ excludeSigners = false } = {}) {
    const sessionInfo = {
      authInfo: __privateGet(this, _authInfo),
      userId: this.userId,
      wallets: structuredClone(this.wallets),
      currentWalletIds: this.currentWalletIds,
      sessionCookie: this.retrieveSessionCookie(),
      externalWallets: this.externalWallets
    };
    if (excludeSigners) {
      for (const wallet of Object.values(sessionInfo.wallets)) {
        delete wallet.signer;
      }
    }
    return Buffer.from(JSON.stringify(sessionInfo)).toString("base64");
  }
  /**
   * Imports a session serialized by another Para instance.
   * @param {string} serializedInstanceBase64 the serialized session
   */
  importSession(serializedInstanceBase64) {
    return __async(this, null, function* () {
      var _a, _b;
      const serializedInstance = Buffer.from(serializedInstanceBase64, "base64").toString("utf8");
      const sessionInfo = jsonParse(serializedInstance);
      const authInfo = (_a = sessionInfo.authInfo) != null ? _a : __privateMethod(this, _ParaCore_instances, toAuthInfo_fn).call(this, sessionInfo);
      yield __privateMethod(this, _ParaCore_instances, setAuthInfo_fn).call(this, authInfo);
      yield this.setUserId(sessionInfo.userId);
      yield this.setWallets(sessionInfo.wallets);
      yield this.setExternalWallets(sessionInfo.externalWallets || {});
      for (const walletId of Object.keys(this.wallets)) {
        if (!this.wallets[walletId].userId) {
          this.wallets[walletId].userId = this.userId;
        }
      }
      if (Object.keys(sessionInfo.currentWalletIds).length !== 0) {
        yield this.setCurrentWalletIds(sessionInfo.currentWalletIds);
      } else {
        const currentWalletIds = {};
        for (const walletId of Object.keys(sessionInfo.wallets)) {
          currentWalletIds[sessionInfo.wallets[walletId].type] = [
            ...(_b = currentWalletIds[sessionInfo.wallets[walletId].type]) != null ? _b : [],
            walletId
          ];
        }
        yield this.setCurrentWalletIds(currentWalletIds);
      }
      this.persistSessionCookie(sessionInfo.sessionCookie);
    });
  }
  /**
   * Retrieves a token to verify the current session.
   * @returns {Promise<string>} the ID
   **/
  getVerificationToken() {
    return __async(this, null, function* () {
      const { sessionLookupId } = yield this.touchSession();
      return sessionLookupId;
    });
  }
  issueJwt() {
    return __async(this, arguments, function* ({ keyIndex = 0 } = {}) {
      const res = yield this.ctx.client.issueJwt({ keyIndex });
      return res;
    });
  }
  /**
   * Logs the user out.
   * @param {Object} opts the options object.
   * @param {boolean} opts.clearPregenWallets if `true`, will remove all pregen wallets from storage
   **/
  logout() {
    return __async(this, arguments, function* ({ clearPregenWallets = false } = {}) {
      const shouldDispatchLogoutEvent = yield this.isSessionActive();
      yield this.ctx.client.logout();
      yield this.clearStorage();
      if (!clearPregenWallets) {
        Object.entries(this.wallets).forEach(([id, wallet]) => {
          if (!wallet.pregenIdentifier) {
            delete this.wallets[id];
          }
        });
        yield this.setWallets(this.wallets);
      } else {
        this.wallets = {};
      }
      this.currentWalletIds = {};
      this.externalWallets = {};
      this.loginEncryptionKeyPair = void 0;
      __privateSet(this, _authInfo, void 0);
      this.accountLinkInProgress = void 0;
      this.userId = void 0;
      this.sessionCookie = void 0;
      if (shouldDispatchLogoutEvent) {
        dispatchEvent(ParaEvent.LOGOUT_EVENT, null);
      }
    });
  }
  get toStringAdditions() {
    return {};
  }
  /**
   * Converts to a string, removing sensitive data when logging this class.
   *
   * Doesn't work for all types of logging.
   **/
  toString() {
    var _a, _b, _c;
    const redactedWallets = Object.keys(this.wallets).reduce(
      (acc, walletId) => __spreadProps(__spreadValues({}, acc), {
        [walletId]: __spreadProps(__spreadValues({}, this.wallets[walletId]), {
          signer: this.wallets[walletId].signer ? "[REDACTED]" : void 0
        })
      }),
      {}
    );
    const redactedExternalWallets = Object.keys(this.externalWallets).reduce(
      (acc, walletId) => __spreadProps(__spreadValues({}, acc), {
        [walletId]: __spreadProps(__spreadValues({}, this.externalWallets[walletId]), {
          signer: this.externalWallets[walletId].signer ? "[REDACTED]" : void 0
        })
      }),
      {}
    );
    const obj = __spreadProps(__spreadValues({
      partnerId: (_a = this.partner) == null ? void 0 : _a.id,
      supportedWalletTypes: (_b = this.partner) == null ? void 0 : _b.supportedWalletTypes,
      cosmosPrefix: (_c = this.partner) == null ? void 0 : _c.cosmosPrefix,
      authInfo: __privateGet(this, _authInfo),
      isGuestMode: this.isGuestMode,
      userId: this.userId,
      pregenIds: this.pregenIds,
      currentWalletIds: this.currentWalletIds,
      guestWalletIds: __privateGet(this, _ParaCore_instances, guestWalletIds_get),
      wallets: redactedWallets,
      externalWallets: redactedExternalWallets,
      loginEncryptionKeyPair: this.loginEncryptionKeyPair ? "[REDACTED]" : void 0,
      isReady: this.isReady
    }, this.toStringAdditions), {
      ctx: {
        apiKey: this.ctx.apiKey,
        disableWorkers: this.ctx.disableWorkers,
        disableWebSockets: this.ctx.disableWebSockets,
        env: this.ctx.env,
        offloadMPCComputationURL: this.ctx.offloadMPCComputationURL,
        useLocalFiles: this.ctx.useLocalFiles,
        useDKLS: this.ctx.useDKLS,
        cosmosPrefix: this.ctx.cosmosPrefix
      }
    });
    return `Para ${JSON.stringify(obj, null, 2)}`;
  }
  devLog(...s) {
    if (this.ctx.env === Environment.DEV || this.ctx.env === Environment.SANDBOX) {
      console.log(...s);
    }
  }
  getNewCredentialAndUrl() {
    return __async(this, arguments, function* ({
      authMethod = "PASSKEY",
      isForNewDevice = false,
      portalTheme,
      shorten = false
    } = {}) {
      this.assertIsAuthSet();
      let credentialId, urlType;
      switch (authMethod) {
        case "PASSKEY":
          ({
            data: { id: credentialId }
          } = yield this.ctx.client.addSessionPublicKey(this.userId, {
            status: PublicKeyStatus.PENDING,
            type: PublicKeyType.WEB
          }));
          urlType = "createAuth";
          break;
        case "PASSWORD":
          ({
            data: { id: credentialId }
          } = yield this.ctx.client.addSessionPasswordPublicKey(this.userId, {
            status: PasswordStatus.PENDING
          }));
          urlType = "createPassword";
          break;
        case "PIN":
          ({
            data: { id: credentialId }
          } = yield this.ctx.client.addSessionPasswordPublicKey(this.userId, {
            status: PasswordStatus.PENDING
          }));
          urlType = "createPIN";
          break;
      }
      const url = this.isNativePasskey && urlType === "createAuth" ? void 0 : yield this.constructPortalUrl(urlType, {
        isForNewDevice,
        pathId: credentialId,
        portalTheme,
        shorten
      });
      return __spreadValues({ credentialId }, url ? { url } : {});
    });
  }
  /**
   * Returns a Para Portal URL for logging in with a WebAuth passkey, password or PIN.
   * @param {Object} opts the options object
   * @param {String} opts.auth - the user auth to sign up or log in with, in the form ` { email: string } | { phone: `+${number}` } `
   * @param {boolean} opts.useShortUrls - whether to shorten the generated portal URLs
   * @param {Theme} opts.portalTheme the Para Portal theme to apply to the password creation URL, if other than the default theme
   * @returns {SignUpOrLogInResponse} an object in the form of either: `{ stage: 'verify' }` or `{ stage: 'login'; passkeyUrl?: string; passwordUrl?: string; biometricHints?: BiometricLocationHint[] }`
   */
  getLoginUrl(_0) {
    return __async(this, arguments, function* ({
      authMethod = "PASSKEY",
      shorten = false,
      portalTheme,
      sessionId
    }) {
      if (!sessionId) {
        sessionId = (yield this.touchSession()).sessionLookupId;
      }
      this.assertIsAuthSet();
      let urlType;
      switch (authMethod) {
        case "PASSKEY":
          urlType = "loginAuth";
          break;
        case "PASSWORD":
          urlType = "loginPassword";
          break;
        case "PIN":
          urlType = "loginPIN";
          break;
        default:
          throw new Error(`invalid authentication method: '${authMethod}'`);
      }
      return this.constructPortalUrl(urlType, {
        sessionId,
        shorten,
        portalTheme
      });
    });
  }
  prepareLogin() {
    return __async(this, null, function* () {
      yield this.logout();
      const { sessionLookupId } = yield this.touchSession(true);
      if (!this.loginEncryptionKeyPair) {
        yield this.setLoginEncryptionKeyPair();
      }
      return sessionLookupId;
    });
  }
  signUpOrLogIn(_k) {
    return __async(this, null, function* () {
      var _l = _k, { auth } = _l, urlOptions = __objRest(_l, ["auth"]);
      const serverAuthState = yield this.ctx.client.signUpOrLogIn(__spreadValues(__spreadValues({}, auth), this.getVerificationEmailProps()));
      const authInfo = serverAuthState.auth;
      if (this.fetchPregenWalletsOverride && isPregenAuth(authInfo)) {
        const { userShare } = yield this.fetchPregenWalletsOverride({ pregenId: authInfo });
        if (userShare) {
          yield this.setUserShare(userShare);
        }
      }
      return __privateMethod(this, _ParaCore_instances, prepareAuthState_fn).call(this, serverAuthState, urlOptions);
    });
  }
  verifyNewAccount(_m) {
    return __async(this, null, function* () {
      var _n = _m, {
        verificationCode
      } = _n, urlOptions = __objRest(_n, [
        "verificationCode"
      ]);
      this.assertIsAuthSet(["email", "phone"]);
      const userId = this.assertUserId({ allowGuestMode: true });
      const serverAuthState = yield this.ctx.client.verifyAccount(userId, {
        verificationCode
      });
      if (serverAuthState.stage === "login") {
        throw new Error("Account already exists.");
      }
      return __privateMethod(this, _ParaCore_instances, prepareAuthState_fn).call(this, serverAuthState, urlOptions);
    });
  }
  getLinkedAccounts() {
    return __async(this, arguments, function* ({
      withMetadata = false
    } = {}) {
      const userId = this.assertUserId();
      const { accounts } = yield this.ctx.client.getLinkedAccounts({ userId, withMetadata });
      return __spreadValues({
        userId
      }, accounts);
    });
  }
  linkAccount(opts) {
    return __async(this, null, function* () {
      const { supportedAccountLinks = [...LINKED_ACCOUNT_TYPES] } = yield __privateMethod(this, _ParaCore_instances, assertPartner_fn).call(this);
      let type, identifier, externalWallet, isPermitted;
      switch (true) {
        case "auth" in opts:
          {
            const authInfo = extractAuthInfo(opts.auth, { isRequired: true });
            if (authInfo.auth === this.authInfo.auth) {
              throw new Error(AccountLinkError.Conflict);
            }
            type = authInfo.authType.toUpperCase();
            identifier = authInfo.identifier;
            isPermitted = supportedAccountLinks.includes(type);
          }
          break;
        case "externalWallet" in opts:
          {
            externalWallet = opts.externalWallet;
            type = "EXTERNAL_WALLET";
            isPermitted = supportedAccountLinks.includes("EXTERNAL_WALLET") || supportedAccountLinks.includes(externalWallet.providerId);
          }
          break;
        case "type" in opts:
          {
            type = opts.type;
            if (type === "X") {
              type = "TWITTER";
            }
            isPermitted = supportedAccountLinks.includes(type);
          }
          break;
        default:
          throw new Error("Invalid parameters for linking account, must pass `auth` or `type` or `externalWallet");
      }
      if (!isPermitted) {
        throw new Error(`Account linking for type '${type}' is not supported by the current API key configuration`);
      }
      const userId = this.assertUserId();
      const result = yield this.ctx.client.linkAccount(__spreadValues(__spreadValues({
        userId,
        type
      }, identifier ? { identifier } : {}), externalWallet ? { externalWallet } : {}));
      if ("isConflict" in result) {
        throw new Error(AccountLinkError.Conflict);
      }
      const { linkedAccountId, signatureVerificationMessage } = result;
      this.accountLinkInProgress = __spreadValues(__spreadValues({
        id: linkedAccountId,
        type,
        isComplete: false
      }, identifier ? { identifier } : {}), signatureVerificationMessage && externalWallet ? {
        externalWallet: __spreadProps(__spreadValues({}, externalWallet), {
          signatureVerificationMessage
        })
      } : {});
      return this.accountLinkInProgress;
    });
  }
  unlinkAccount(_0) {
    return __async(this, arguments, function* ({
      linkedAccountId
    }) {
      if (!linkedAccountId) {
        throw new Error("No linked account ID provided");
      }
      const userId = this.assertUserId();
      const accounts = yield this.ctx.client.unlinkAccount({ linkedAccountId, userId });
      return accounts;
    });
  }
  verifyLink() {
    return __async(this, arguments, function* (_o = {}) {
      var _p = _o, {
        accountLinkInProgress = __privateMethod(this, _ParaCore_instances, assertIsLinkingAccount_fn).call(this)
      } = _p, opts = __objRest(_p, [
        "accountLinkInProgress"
      ]);
      try {
        const userId = this.assertUserId(), result = yield this.ctx.client.verifyLink(__spreadValues({
          linkedAccountId: accountLinkInProgress.id,
          userId
        }, opts));
        if ("isConflict" in result) {
          throw new Error(AccountLinkError.Conflict);
        }
        this.accountLinkInProgress = void 0;
        return result.accounts;
      } catch (e) {
        throw new Error(e.message === AccountLinkError.Conflict ? AccountLinkError.Conflict : e.message);
      }
    });
  }
  verifyEmailOrPhoneLink(_0) {
    return __async(this, arguments, function* ({
      verificationCode
    }) {
      const accounts = yield this.verifyLink({
        accountLinkInProgress: __privateMethod(this, _ParaCore_instances, assertIsLinkingAccount_fn).call(this, ["EMAIL", "PHONE"]),
        verificationCode
      });
      return accounts;
    });
  }
  sendLoginCode() {
    return __async(this, null, function* () {
      const { userId } = yield this.ctx.client.sendLoginVerificationCode(this.authInfo);
      this.setUserId(userId);
    });
  }
};
_authInfo = new WeakMap();
_ParaCore_instances = new WeakSet();
assertPartner_fn = function() {
  return __async(this, null, function* () {
    var _a, _b;
    if (!this.partner) {
      yield this.touchSession();
    }
    if (((_a = this.partner) == null ? void 0 : _a.cosmosPrefix) && this.ctx.cosmosPrefix !== this.partner.cosmosPrefix) {
      this.ctx.cosmosPrefix = (_b = this.partner) == null ? void 0 : _b.cosmosPrefix;
    }
    return this.partner;
  });
};
guestWalletIds_get = function() {
  var _a, _b, _c;
  if (!((_a = this.partner) == null ? void 0 : _a.supportedWalletTypes)) {
    return {};
  }
  const guestId = (_c = (_b = this.pregenIds) == null ? void 0 : _b.GUEST_ID) == null ? void 0 : _c[0];
  return !!guestId ? Object.entries(this.wallets).reduce((acc, [id, wallet]) => {
    if (wallet.isPregen && !wallet.userId && wallet.pregenIdentifierType === "GUEST_ID" && wallet.pregenIdentifier === guestId) {
      return __spreadValues(__spreadValues({}, acc), getEquivalentTypes(wallet.type).filter((type) => this.partner.supportedWalletTypes.some((entry) => entry.type === type)).reduce((acc2, eqType) => {
        var _a2;
        return __spreadProps(__spreadValues({}, acc2), { [eqType]: [.../* @__PURE__ */ new Set([...(_a2 = acc2[eqType]) != null ? _a2 : [], id])] });
      }, {}));
    }
    return acc;
  }, {}) : {};
};
guestWalletIdsArray_get = function() {
  return Object.entries(__privateGet(this, _ParaCore_instances, guestWalletIds_get)).reduce((acc, [type, ids]) => {
    return [...acc, ...ids.map((id) => [id, type])];
  }, []);
};
toAuthInfo_fn = function({
  email,
  phone,
  countryCode,
  farcasterUsername,
  telegramUserId,
  externalWalletAddress
}) {
  let auth;
  switch (true) {
    case !!email:
      auth = { email };
      break;
    case !!phone:
      {
        const validPhone = formatPhoneNumber(phone, countryCode);
        if (validPhone) auth = { phone: formatPhoneNumber(phone, countryCode) };
      }
      break;
    case !!farcasterUsername:
      auth = { farcasterUsername };
      break;
    case !!telegramUserId:
      auth = { telegramUserId };
      break;
    case !!externalWalletAddress:
      auth = { externalWalletAddress };
      break;
  }
  return extractAuthInfo(auth);
};
setAuthInfo_fn = function(authInfo) {
  return __async(this, null, function* () {
    __privateSet(this, _authInfo, authInfo);
    yield this.localStorageSetItem(constants.LOCAL_STORAGE_AUTH_INFO, JSON.stringify(authInfo));
    yield this.localStorageRemoveItem(constants.LOCAL_STORAGE_EMAIL);
    yield this.localStorageRemoveItem(constants.LOCAL_STORAGE_PHONE);
    yield this.localStorageRemoveItem(constants.LOCAL_STORAGE_COUNTRY_CODE);
    yield this.localStorageRemoveItem(constants.LOCAL_STORAGE_FARCASTER_USERNAME);
    yield this.localStorageRemoveItem(constants.LOCAL_STORAGE_TELEGRAM_USER_ID);
  });
};
getPartner_fn = function(partnerId) {
  return __async(this, null, function* () {
    if (this.isPartnerOptional && !partnerId) {
      return void 0;
    }
    const res = yield this.ctx.client.getPartner(partnerId);
    this.partner = res.data.partner;
    return this.partner;
  });
};
assertIsLinkingAccount_fn = function(types) {
  if (!this.accountLinkInProgress || this.accountLinkInProgress.isComplete) {
    throw new Error("no account linking in progress");
  }
  if (types && !types.includes(this.accountLinkInProgress.type)) {
    throw new Error(
      `account linking in progress for type ${this.accountLinkInProgress.type}, expected one of ${types.join(", ")}`
    );
  }
  return this.accountLinkInProgress;
};
assertIsLinkingAccountOrStart_fn = function(type) {
  return __async(this, null, function* () {
    if (this.accountLinkInProgress && !this.accountLinkInProgress.isComplete) {
      return __privateMethod(this, _ParaCore_instances, assertIsLinkingAccount_fn).call(this, [type]);
    }
    return yield this.linkAccount({ type });
  });
};
/**
 * Generates a URL for the user to log in with OAuth using a desire method.
 *
 * @param {Object} opts the options object
 * @param {TOAuthMethod} opts.method the third-party service to use for OAuth.
 * @param {string} [opts.appScheme] the app scheme to redirect to after the OAuth flow. This is for mobile only.
 * @returns {string} the URL for the user to log in with OAuth.
 */
getOAuthUrl_fn = function({
  method,
  appScheme,
  accountLinkInProgress,
  sessionLookupId
}) {
  return constructUrl({
    base: getBaseOAuthUrl(this.ctx.env),
    path: `/auth/${method}`,
    params: __spreadValues({
      apiKey: this.ctx.apiKey,
      sessionLookupId,
      appScheme
    }, accountLinkInProgress ? {
      linkedAccountId: this.accountLinkInProgress.id
    } : {})
  });
};
createPregenWallet_fn = function(opts) {
  return __async(this, null, function* () {
    var _a, _b;
    const { supportedWalletTypes } = yield __privateMethod(this, _ParaCore_instances, assertPartner_fn).call(this);
    const { type: _type = (_a = supportedWalletTypes.find(({ optional }) => !optional)) == null ? void 0 : _a.type, pregenId } = opts;
    this.requireApiKey();
    const walletType = yield this.assertIsValidWalletType(
      _type != null ? _type : (_b = supportedWalletTypes.find(({ optional }) => !optional)) == null ? void 0 : _b.type
    );
    const [pregenIdentifierType, pregenIdentifier] = toPregenTypeAndId(pregenId);
    let keygenRes;
    switch (walletType) {
      case "SOLANA":
        keygenRes = yield this.platformUtils.ed25519PreKeygen(
          this.ctx,
          pregenIdentifier,
          pregenIdentifierType,
          this.retrieveSessionCookie()
        );
        break;
      default:
        keygenRes = yield this.platformUtils.preKeygen(
          this.ctx,
          void 0,
          pregenIdentifier,
          pregenIdentifierType,
          walletType,
          null,
          this.retrieveSessionCookie()
        );
        break;
    }
    const { signer, walletId } = keygenRes;
    this.wallets[walletId] = {
      id: walletId,
      signer,
      scheme: walletType === "SOLANA" ? "ED25519" : "DKLS",
      type: walletType,
      isPregen: true,
      pregenIdentifier,
      pregenIdentifierType
    };
    yield this.waitForPregenWalletAddress(walletId);
    yield this.populatePregenWalletAddresses();
    return this.wallets[walletId];
  });
};
_isCreateGuestWalletsPending = new WeakMap();
prepareAuthState_fn = function(_0) {
  return __async(this, arguments, function* (serverAuthState, opts = {}) {
    var _a, _b;
    if (!opts.sessionLookupId && serverAuthState.stage === "login" && (!serverAuthState.externalWallet || !(((_a = serverAuthState.externalWallet) == null ? void 0 : _a.withFullParaAuth) && ((_b = serverAuthState.loginAuthMethods) == null ? void 0 : _b.includes(AuthMethod.PIN))))) {
      opts.sessionLookupId = yield this.prepareLogin();
    }
    const { auth, externalWallet, userId, displayName, pfpUrl, username } = serverAuthState;
    const authInfo = __spreadValues(__spreadValues({}, extractAuthInfo(auth, { isRequired: true })), Object.fromEntries(
      Object.entries({
        displayName,
        pfpUrl,
        username,
        externalWallet
      }).filter(([_, v]) => !!v)
    ));
    yield __privateMethod(this, _ParaCore_instances, setAuthInfo_fn).call(this, authInfo);
    yield this.assertIsAuthSet();
    if (!!externalWallet) {
      yield this.setExternalWallet([externalWallet]);
    }
    if (!!userId) {
      yield this.setUserId(userId);
    }
    let authState;
    switch (serverAuthState.stage) {
      case "verify":
        authState = serverAuthState;
        break;
      case "login":
        if (externalWallet && !(externalWallet == null ? void 0 : externalWallet.withFullParaAuth)) {
          authState = serverAuthState;
          break;
        }
        authState = yield __privateMethod(this, _ParaCore_instances, prepareLoginState_fn).call(this, serverAuthState, __spreadProps(__spreadValues({}, opts), { sessionLookupId: opts.sessionLookupId }));
        break;
      case "signup":
        if (externalWallet && !(externalWallet == null ? void 0 : externalWallet.withFullParaAuth)) {
          authState = serverAuthState;
          break;
        }
        authState = yield __privateMethod(this, _ParaCore_instances, prepareSignUpState_fn).call(this, serverAuthState, opts);
        break;
    }
    return authState;
  });
};
prepareLoginState_fn = function(_0, _1) {
  return __async(this, arguments, function* (loginState, {
    useShortUrls: shorten = false,
    portalTheme,
    sessionLookupId
  }) {
    const _a = loginState, { loginAuthMethods, hasPasswordWithoutPIN } = _a, authState = __objRest(_a, ["loginAuthMethods", "hasPasswordWithoutPIN"]);
    const isPasskeySupported = yield this.isPasskeySupported(), isPasskeyPossible = loginAuthMethods.includes(AuthMethod.PASSKEY) && !this.isNativePasskey, isPasswordPossible = loginAuthMethods.includes(AuthMethod.PASSWORD) && hasPasswordWithoutPIN, isPINPossible = loginAuthMethods.includes(AuthMethod.PIN);
    return __spreadValues(__spreadValues(__spreadValues(__spreadProps(__spreadValues({}, authState), {
      isPasskeySupported
    }), isPasskeyPossible ? {
      passkeyUrl: yield this.getLoginUrl({ sessionId: sessionLookupId, shorten, portalTheme }),
      passkeyKnownDeviceUrl: yield this.constructPortalUrl("loginAuth", {
        sessionId: sessionLookupId,
        newDevice: {
          sessionId: sessionLookupId,
          encryptionKey: getPublicKeyHex(this.loginEncryptionKeyPair)
        },
        shorten,
        portalTheme
      })
    } : {}), isPasswordPossible ? {
      passwordUrl: yield this.constructPortalUrl("loginPassword", {
        sessionId: sessionLookupId,
        shorten,
        portalTheme,
        params: { isEmbedded: `${!loginState.isWalletSelectionNeeded}` }
      })
    } : {}), isPINPossible ? {
      pinUrl: yield this.constructPortalUrl("loginPIN", {
        sessionId: sessionLookupId,
        shorten,
        portalTheme,
        params: { isEmbedded: `${!loginState.isWalletSelectionNeeded}` }
      })
    } : {});
  });
};
prepareSignUpState_fn = function(_0, _1) {
  return __async(this, arguments, function* (serverSignupState, { useShortUrls: shorten = false, portalTheme }) {
    const _a = serverSignupState, { signupAuthMethods } = _a, authState = __objRest(_a, ["signupAuthMethods"]);
    const isPasskeySupported = yield this.isPasskeySupported();
    const [isPasskey, isPassword, isPIN] = [
      signupAuthMethods.includes(AuthMethod.PASSKEY),
      signupAuthMethods.includes(AuthMethod.PASSWORD) || !isPasskeySupported,
      signupAuthMethods.includes(AuthMethod.PIN)
    ];
    if (!isPasskey && !isPassword && !isPIN) {
      throw new Error(
        "No supported authentication methods found. Please ensure you have enabled either WebAuth passkeys, passwords or PINs in your Developer Portal settings."
      );
    }
    const signupState = __spreadProps(__spreadValues({}, authState), { isPasskeySupported });
    if (isPasskey) {
      const { url: passkeyUrl, credentialId: passkeyId } = yield this.getNewCredentialAndUrl({
        authMethod: "PASSKEY",
        shorten
      });
      if (passkeyUrl) signupState.passkeyUrl = passkeyUrl;
      signupState.passkeyId = passkeyId;
    }
    if (isPassword) {
      const { url: passwordUrl, credentialId: passwordId } = yield this.getNewCredentialAndUrl({
        authMethod: "PASSWORD",
        portalTheme,
        shorten
      });
      signupState.passwordUrl = passwordUrl;
      signupState.passwordId = passwordId;
    }
    if (isPIN) {
      const { url: pinUrl, credentialId: pinId } = yield this.getNewCredentialAndUrl({
        authMethod: "PIN",
        portalTheme,
        shorten
      });
      signupState.pinUrl = pinUrl;
      signupState.pinId = pinId;
    }
    return signupState;
  });
};
_ParaCore.version = constants.PARA_CORE_VERSION;
let ParaCore = _ParaCore;
export {
  ParaCore
};

import {
  __async
} from "../chunk-7B52C2XE.js";
import base64url from "base64url";
import forge from "node-forge";
import { getPortalBaseURL } from "../utils/index.js";
const rsa = forge.pki.rsa;
const RSA_ENCRYPTION_SCHEME = "RSA-OAEP";
const CONSTANT_IV = "794241bc819a125a7b78ea313decc0bc";
const CONSTANT_IV_AES = new Uint8Array([23, 66, 157, 146, 179, 158, 117, 120, 184, 73, 123, 81]);
function getSHA256HashHex(str) {
  const md = forge.md.sha256.create();
  md.update(str);
  return md.digest().toHex();
}
function getPublicKeyHex(keyPair) {
  const pem = forge.pki.publicKeyToRSAPublicKeyPem(keyPair.publicKey);
  return Buffer.from(pem, "utf-8").toString("hex");
}
function publicKeyFromHex(publicKeyHex) {
  const pem = publicKeyHexToPem(publicKeyHex);
  return forge.pki.publicKeyFromPem(pem);
}
function publicKeyHexToPem(publicKeyHex) {
  return Buffer.from(publicKeyHex, "hex").toString("utf-8");
}
function encodePrivateKeyToPemHex(keyPair) {
  const pem = forge.pki.privateKeyToPem(keyPair.privateKey);
  return Buffer.from(pem, "utf-8").toString("hex");
}
function decodePrivateKeyPemHex(privateKeyPemHex) {
  const pem = Buffer.from(privateKeyPemHex, "hex").toString("utf-8");
  return forge.pki.privateKeyFromPem(pem);
}
function encryptPrivateKey(keyPair, key) {
  return __async(this, null, function* () {
    const privateKeyPemHex = encodePrivateKeyToPemHex(keyPair);
    const cryptoKey = yield window.crypto.subtle.importKey(
      "raw",
      Buffer.from(key, "base64"),
      {
        name: "AES-GCM",
        length: 256
      },
      true,
      ["encrypt", "decrypt"]
    );
    const encodedPlaintext = new TextEncoder().encode(privateKeyPemHex);
    const ciphertext = yield window.crypto.subtle.encrypt(
      { name: "AES-GCM", iv: CONSTANT_IV_AES },
      cryptoKey,
      encodedPlaintext
    );
    return Buffer.from(ciphertext).toString("base64");
  });
}
function decryptPrivateKey(encryptedPrivateKeyPemHex, key) {
  return __async(this, null, function* () {
    const secretKey = yield crypto.subtle.importKey(
      "raw",
      Buffer.from(key, "base64"),
      {
        name: "AES-GCM",
        length: 256
      },
      true,
      ["encrypt", "decrypt"]
    );
    const cleartext = yield crypto.subtle.decrypt(
      { name: "AES-GCM", iv: CONSTANT_IV_AES },
      secretKey,
      Buffer.from(encryptedPrivateKeyPemHex, "base64")
    );
    const privateKeyPemHex = new TextDecoder().decode(cleartext);
    const privateKey = decodePrivateKeyPemHex(privateKeyPemHex);
    return privateKey;
  });
}
function getAsymmetricKeyPair(ctx, seedValue) {
  return __async(this, null, function* () {
    const prng = forge.random.createInstance();
    if (seedValue) {
      prng.seedFileSync = (_n) => seedValue;
      prng.seedFile = (_n, cb) => {
        cb(null, seedValue);
      };
    }
    const options = {
      bits: 2048,
      e: 65537,
      prng
    };
    if (!ctx.disableWorkers) {
      options.workLoad = 100;
      options.workers = seedValue ? 1 : -1;
      const workerRes = yield fetch(`${getPortalBaseURL(ctx)}/static/js/prime.worker.min.js`);
      const workerBlob = new Blob([yield workerRes.text()], { type: "application/javascript" });
      options.workerScript = URL.createObjectURL(workerBlob);
    }
    return new Promise(
      (resolve, reject) => rsa.generateKeyPair(options, (err, keypair) => {
        if (err) {
          reject(err);
        }
        resolve(keypair);
      })
    );
  });
}
function getPublicKeyFromSignature(ctx, userHandle) {
  return __async(this, null, function* () {
    const encodedUserHandle = base64url.encode(userHandle);
    const keyPair = yield getAsymmetricKeyPair(ctx, encodedUserHandle);
    return getPublicKeyHex(keyPair);
  });
}
function symmetricKeyEncryptMessage(message) {
  const key = forge.random.getBytesSync(16);
  const cipher = forge.cipher.createCipher("AES-CBC", key);
  cipher.start({ iv: CONSTANT_IV });
  cipher.update(forge.util.createBuffer(message));
  cipher.finish();
  const encryptedMessageHex = cipher.output.toHex();
  return { key, encryptedMessageHex };
}
function decipherEncryptedMessageHex(key, encryptedMessageHex) {
  const decipher = forge.cipher.createDecipher("AES-CBC", key);
  decipher.start({ iv: CONSTANT_IV });
  decipher.update(forge.util.createBuffer(forge.util.hexToBytes(encryptedMessageHex)));
  decipher.finish();
  return decipher.output.toString();
}
function decryptWithKeyPair(keyPair, encryptedMessageHex, encryptedKeyHex) {
  const encryptedKey = Buffer.from(encryptedKeyHex, "hex").toString("utf-8");
  const key = keyPair.privateKey.decrypt(encryptedKey, RSA_ENCRYPTION_SCHEME);
  return decipherEncryptedMessageHex(key, encryptedMessageHex);
}
function decryptWithPrivateKey(privateKey, encryptedMessageHex, encryptedKeyHex) {
  const encryptedKey = Buffer.from(encryptedKeyHex, "hex").toString("utf-8");
  const key = privateKey.decrypt(encryptedKey, RSA_ENCRYPTION_SCHEME);
  return decipherEncryptedMessageHex(key, encryptedMessageHex);
}
function decryptWithDerivedPrivateKey(_0, _1) {
  return __async(this, arguments, function* (ctx, {
    seedValue,
    encryptedMessageHex,
    encryptedKeyHex
  }) {
    const keyPair = yield getAsymmetricKeyPair(ctx, seedValue);
    return decryptWithPrivateKey(keyPair.privateKey, encryptedMessageHex, encryptedKeyHex);
  });
}
function getDerivedPrivateKeyAndDecrypt(ctx, seedValue, encryptedShares) {
  return __async(this, null, function* () {
    return Promise.all(
      encryptedShares.map((share) => __async(this, null, function* () {
        return {
          walletId: share.walletId,
          walletScheme: share.walletScheme,
          partnerId: share.partnerId,
          signer: yield decryptWithDerivedPrivateKey(ctx, {
            seedValue,
            encryptedMessageHex: share.encryptedShare,
            encryptedKeyHex: share.encryptedKey
          }),
          protocolId: share.protocolId
        };
      }))
    );
  });
}
function decryptPrivateKeyAndDecryptShare(encryptionKey, encryptedShares, encryptedPrivateKey) {
  return __async(this, null, function* () {
    let privateKey;
    try {
      privateKey = yield decryptPrivateKey(encryptedPrivateKey, encryptionKey);
    } catch (e) {
    }
    try {
      privateKey = yield decryptPrivateKeyWithPassword(encryptedPrivateKey, encryptionKey);
    } catch (e) {
    }
    if (!privateKey) {
      throw new Error("Could not decrypt private key");
    }
    return encryptedShares.map((share) => ({
      walletId: share.walletId,
      walletScheme: share.walletScheme,
      partnerId: share.partnerId,
      signer: decryptWithPrivateKey(privateKey, share.encryptedShare, share.encryptedKey),
      protocolId: share.protocolId
    }));
  });
}
function encryptWithDerivedPublicKey(publicKeyHex, message) {
  const { key, encryptedMessageHex } = symmetricKeyEncryptMessage(message);
  const publicKeyPem = publicKeyHexToPem(publicKeyHex);
  const publicKey = forge.pki.publicKeyFromPem(publicKeyPem);
  const encryptedKey = publicKey.encrypt(key, RSA_ENCRYPTION_SCHEME);
  const encryptedKeyHex = Buffer.from(encryptedKey, "utf-8").toString("hex");
  return { encryptedMessageHex, encryptedKeyHex };
}
function hashPasswordWithSalt(password) {
  const salt = generateSalt();
  const saltedPassword = salt + password;
  const hash = getSHA256HashHex(saltedPassword);
  return { salt, hash };
}
function generateSalt(length = 16) {
  return forge.util.bytesToHex(forge.random.getBytesSync(length));
}
function deriveCryptoKeyFromPassword(hashedPassword) {
  return __async(this, null, function* () {
    const keyBuffer = Buffer.from(hashedPassword, "hex");
    return yield window.crypto.subtle.importKey(
      "raw",
      keyBuffer,
      {
        name: "AES-GCM",
        length: 256
      },
      true,
      ["encrypt", "decrypt"]
    );
  });
}
function encryptPrivateKeyWithPassword(keyPair, hashedPassword) {
  return __async(this, null, function* () {
    const cryptoKey = yield deriveCryptoKeyFromPassword(hashedPassword);
    const privateKeyPemHex = encodePrivateKeyToPemHex(keyPair);
    const encodedPlaintext = new TextEncoder().encode(privateKeyPemHex);
    const ciphertext = yield window.crypto.subtle.encrypt(
      { name: "AES-GCM", iv: CONSTANT_IV_AES },
      cryptoKey,
      encodedPlaintext
    );
    return Buffer.from(ciphertext).toString("base64");
  });
}
function decryptPrivateKeyWithPassword(encryptedPrivateKeyPemHex, hashedPassword) {
  return __async(this, null, function* () {
    const secretKey = yield crypto.subtle.importKey(
      "raw",
      Buffer.from(hashedPassword, "hex"),
      {
        name: "AES-GCM",
        length: 256
      },
      true,
      ["encrypt", "decrypt"]
    );
    const cleartext = yield crypto.subtle.decrypt(
      { name: "AES-GCM", iv: CONSTANT_IV_AES },
      secretKey,
      Buffer.from(encryptedPrivateKeyPemHex, "base64")
    );
    const privateKeyPemHex = new TextDecoder().decode(cleartext);
    const privateKey = decodePrivateKeyPemHex(privateKeyPemHex);
    return privateKey;
  });
}
export {
  decodePrivateKeyPemHex,
  decryptPrivateKey,
  decryptPrivateKeyAndDecryptShare,
  decryptPrivateKeyWithPassword,
  decryptWithKeyPair,
  decryptWithPrivateKey,
  encodePrivateKeyToPemHex,
  encryptPrivateKey,
  encryptPrivateKeyWithPassword,
  encryptWithDerivedPublicKey,
  getAsymmetricKeyPair,
  getDerivedPrivateKeyAndDecrypt,
  getPublicKeyFromSignature,
  getPublicKeyHex,
  getSHA256HashHex,
  hashPasswordWithSalt,
  publicKeyFromHex,
  publicKeyHexToPem,
  symmetricKeyEncryptMessage
};

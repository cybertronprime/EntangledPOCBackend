import "../chunk-7B52C2XE.js";
import { Encrypt as ECIESEncrypt, Decrypt as ECIESDecrypt } from "@celo/utils/lib/ecies.js";
import * as eutil from "@ethereumjs/util";
import * as forge from "node-forge";
class KeyContainer {
  constructor(walletId, keyshare, address) {
    this.walletId = walletId;
    this.keyshare = keyshare;
    this.address = address;
    this.backupDecryptionKey = Buffer.from(forge.random.getBytesSync(32), "binary").toString("hex");
  }
  static buildFrom(serializedContainer) {
    try {
      const parsedObject = JSON.parse(serializedContainer);
      return Object.assign(new KeyContainer("", "", ""), parsedObject);
    } catch (e) {
      const container = new KeyContainer("", "", "");
      container.backupDecryptionKey = serializedContainer.split("|")[0];
      return container;
    }
  }
  getPublicEncryptionKey() {
    return Buffer.from(eutil.privateToPublic(Buffer.from(this.backupDecryptionKey, "hex")));
  }
  getPublicEncryptionKeyHex() {
    return this.getPublicEncryptionKey().toString("hex");
  }
  encryptForSelf(backup) {
    try {
      const pubkey = this.getPublicEncryptionKey();
      const data = ECIESEncrypt(pubkey, Buffer.from(backup, "ucs2")).toString("base64");
      return data;
    } catch (error) {
      throw Error("Error encrypting backup");
    }
  }
  static encryptWithPublicKey(publicKey, backup) {
    try {
      const data = ECIESEncrypt(publicKey, Buffer.from(backup, "ucs2")).toString("base64");
      return data;
    } catch (error) {
      throw Error("Error encrypting backup");
    }
  }
  decrypt(encryptedBackup) {
    try {
      const buf = Buffer.from(encryptedBackup, "base64");
      const data = ECIESDecrypt(Buffer.from(this.backupDecryptionKey, "hex"), buf);
      return Buffer.from(data.buffer).toString("ucs2");
    } catch (error) {
      throw Error("Error decrypting backup");
    }
  }
}
export {
  KeyContainer
};

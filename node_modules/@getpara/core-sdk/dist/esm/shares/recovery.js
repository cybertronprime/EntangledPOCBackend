import {
  __async,
  __spreadValues
} from "../chunk-7B52C2XE.js";
import { EncryptorType, KeyShareType } from "@getpara/user-management-client";
import { KeyContainer } from "./KeyContainer.js";
function sendRecoveryForShare(_0) {
  return __async(this, arguments, function* ({
    ctx,
    userId,
    walletId,
    otherEncryptedShares = [],
    userSigner,
    ignoreRedistributingBackupEncryptedShare = false,
    emailProps = {},
    forceRefresh = false
  }) {
    if (ignoreRedistributingBackupEncryptedShare) {
      yield ctx.client.uploadUserKeyShares(
        userId,
        otherEncryptedShares.map((share) => __spreadValues({
          walletId
        }, share))
      );
      return "";
    }
    let userBackupKeyShareOptsArr;
    let recoveryPrivateKeyContainer;
    const { recoveryPublicKeys } = yield ctx.client.getRecoveryPublicKeys(userId);
    if (forceRefresh || !(recoveryPublicKeys == null ? void 0 : recoveryPublicKeys.length)) {
      recoveryPrivateKeyContainer = new KeyContainer(walletId, "", "");
      const { recoveryPublicKeys: recoveryPublicKeys2 } = yield ctx.client.persistRecoveryPublicKeys(userId, [
        recoveryPrivateKeyContainer.getPublicEncryptionKeyHex()
      ]);
      const encryptedUserBackup = recoveryPrivateKeyContainer.encryptForSelf(userSigner);
      userBackupKeyShareOptsArr = [
        {
          walletId,
          encryptedShare: encryptedUserBackup,
          type: KeyShareType.USER,
          encryptor: EncryptorType.RECOVERY,
          recoveryPublicKeyId: recoveryPublicKeys2[0].id
        }
      ];
    } else {
      userBackupKeyShareOptsArr = recoveryPublicKeys.map((recoveryPublicKey) => {
        const { id: recoveryPublicKeyId, publicKey } = recoveryPublicKey;
        const encryptedUserBackup = KeyContainer.encryptWithPublicKey(Buffer.from(publicKey, "hex"), userSigner);
        return {
          walletId,
          encryptedShare: encryptedUserBackup,
          type: KeyShareType.USER,
          encryptor: EncryptorType.RECOVERY,
          recoveryPublicKeyId
        };
      });
    }
    yield ctx.client.uploadUserKeyShares(userId, [
      ...otherEncryptedShares.map((share) => __spreadValues({
        walletId
      }, share)),
      ...ignoreRedistributingBackupEncryptedShare ? [] : userBackupKeyShareOptsArr
    ]);
    yield ctx.client.distributeParaShare(__spreadValues({
      userId,
      walletId,
      useDKLS: ctx.useDKLS
    }, emailProps));
    return recoveryPrivateKeyContainer ? JSON.stringify(recoveryPrivateKeyContainer) : "";
  });
}
export {
  sendRecoveryForShare
};

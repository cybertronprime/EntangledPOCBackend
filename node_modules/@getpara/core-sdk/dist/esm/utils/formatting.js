import "../chunk-7B52C2XE.js";
import { toBech32 } from "@cosmjs/encoding";
import { sha256 } from "@noble/hashes/sha256";
import { ripemd160 } from "@noble/hashes/ripemd160";
import elliptic from "elliptic";
const secp256k1 = new elliptic.ec("secp256k1");
function hexStringToBase64(hexString) {
  if (hexString.substring(0, 2) === "0x") {
    hexString = hexString.substring(2);
  }
  return Buffer.from(hexString, "hex").toString("base64");
}
function hexToSignature(hexSig) {
  return {
    r: `0x${hexSig.slice(2, 66)}`,
    s: `0x${hexSig.slice(66, 130)}`,
    v: BigInt(hexSig.slice(130, 132))
  };
}
function hexToUint8Array(hex) {
  if (hex.startsWith("0x")) {
    hex = hex.slice(2);
  }
  return new Uint8Array(Buffer.from(hex, "hex"));
}
function hexToDecimal(hex) {
  if (hex.startsWith("0x")) {
    hex = hex.slice(2);
  }
  return `${parseInt(hex, 16)}`;
}
function decimalToHex(decimal) {
  return `0x${parseInt(decimal).toString(16)}`;
}
function compressPubkey(pubkey) {
  switch (pubkey.length) {
    case 33:
      return pubkey;
    case 65:
      return Uint8Array.from(secp256k1.keyFromPublic(pubkey).getPublic(true, "array"));
    default:
      throw new Error("Invalid pubkey length");
  }
}
function rawSecp256k1PubkeyToRawAddress(pubkeyData) {
  if (pubkeyData.length !== 33) {
    throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);
  }
  return ripemd160(sha256(pubkeyData));
}
function getCosmosAddress(publicKey, prefix) {
  const uncompressedPublicKey = new Uint8Array(
    Buffer.from(publicKey.startsWith("0x") ? publicKey.slice(2) : publicKey, "hex")
  );
  const compressedPublicKey = compressPubkey(uncompressedPublicKey);
  return toBech32(prefix, rawSecp256k1PubkeyToRawAddress(compressedPublicKey));
}
function truncateAddress(str, addressType, {
  prefix = addressType === "COSMOS" ? "cosmos" : void 0,
  targetLength
} = {}) {
  const minimum = addressType === "COSMOS" ? prefix.length : addressType === "EVM" ? 2 : 0;
  const margin = targetLength !== void 0 ? (targetLength - minimum) / 2 : 4;
  return `${str.slice(0, minimum + margin)}...${str.slice(-1 * margin)}`;
}
export {
  compressPubkey,
  decimalToHex,
  getCosmosAddress,
  hexStringToBase64,
  hexToDecimal,
  hexToSignature,
  hexToUint8Array,
  rawSecp256k1PubkeyToRawAddress,
  truncateAddress
};

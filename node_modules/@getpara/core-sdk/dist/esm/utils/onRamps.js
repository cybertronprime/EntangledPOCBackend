import "../chunk-7B52C2XE.js";
import { Network } from "@getpara/user-management-client";
function toAssetInfoArray(data) {
  const result = [];
  Object.keys(data).forEach((walletType) => {
    const networks = data[walletType];
    Object.keys(networks).forEach((network) => {
      const assets = networks[network];
      Object.keys(assets).forEach((asset) => {
        const providerInfo = assets[asset];
        result.push([walletType, network, asset, providerInfo]);
      });
    });
  });
  return result;
}
function getOnRampNetworks(data, {
  walletType,
  allowed,
  assets,
  providers,
  action
} = {}) {
  return [
    ...new Set(
      toAssetInfoArray(data).filter(
        ([type, network, asset, providerInfo]) => (!walletType || type === walletType) && (!allowed || allowed.includes(network)) && (!assets || assets.includes(asset)) && (!providers || providers.some((provider) => {
          var _a;
          return ((_a = providerInfo[provider]) == null ? void 0 : _a[1]) && (!action || providerInfo[provider][1][action]);
        }))
      ).map(([_, network]) => network)
    )
  ];
}
function getOnRampAssets(data, {
  walletType,
  network,
  allowed,
  providers,
  action
} = {}) {
  return [
    ...new Set(
      toAssetInfoArray(data).filter(
        ([t, n, a, p]) => (!walletType || t === walletType) && (!network || n === network) && (!Array.isArray(allowed) || allowed.includes(a)) && (!providers || providers.some((provider) => {
          var _a;
          return ((_a = p[provider]) == null ? void 0 : _a[1]) && (!action || p[provider][1][action]);
        }))
      ).map(([, , asset]) => asset)
    )
  ];
}
const NETWORK_PREFIXES = {
  [Network.COSMOS]: "cosmos",
  [Network.NOBLE]: "noble"
};
function getNetworkPrefix(network) {
  return NETWORK_PREFIXES[network];
}
export {
  NETWORK_PREFIXES,
  getNetworkPrefix,
  getOnRampAssets,
  getOnRampNetworks,
  toAssetInfoArray
};

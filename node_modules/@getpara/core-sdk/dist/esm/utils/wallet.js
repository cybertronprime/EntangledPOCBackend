import {
  __spreadProps,
  __spreadValues
} from "../chunk-7B52C2XE.js";
import * as uuid from "uuid";
import { formatPhoneNumber } from "./phone.js";
const WalletSchemeTypeMap = {
  DKLS: {
    EVM: true,
    COSMOS: true
  },
  CGGMP: {
    EVM: true,
    COSMOS: true
  },
  ED25519: {
    SOLANA: true
  }
};
function isPregenIdentifierMatch(a, b, type) {
  if (!a || !b) {
    return false;
  }
  switch (type) {
    case "EMAIL":
      return a.toLowerCase() === b.toLowerCase();
    case "PHONE":
      return formatPhoneNumber(a) === formatPhoneNumber(b);
    case "CUSTOM_ID":
      return a === b;
    default:
      return a.replace(/^@/g, "").toLowerCase() === b.replace(/^@/g, "").toLowerCase();
  }
}
function isWalletSupported(types, wallet) {
  return types.some((walletType) => {
    var _a;
    return !!((_a = WalletSchemeTypeMap[wallet == null ? void 0 : wallet.scheme]) == null ? void 0 : _a[walletType]);
  });
}
function getSchemes(types) {
  return Object.keys(WalletSchemeTypeMap).filter((scheme) => {
    if (scheme === "CGGMP") {
      return false;
    }
    return (Array.isArray(types) ? types : Object.keys(types)).some((type) => WalletSchemeTypeMap[scheme][type]);
  });
}
function getWalletTypes(schemes) {
  return [
    ...new Set(
      schemes.reduce((acc, scheme) => {
        return [...acc, ...Object.keys(WalletSchemeTypeMap[scheme]).filter((type) => WalletSchemeTypeMap[scheme][type])];
      }, [])
    )
  ];
}
function getEquivalentTypes(types) {
  return getWalletTypes(getSchemes(Array.isArray(types) ? types : [types]));
}
function entityToWallet(w) {
  return __spreadProps(__spreadValues({}, w), {
    scheme: w.scheme,
    type: w.type,
    pregenIdentifierType: w.pregenIdentifierType
  });
}
function migrateWallet(obj) {
  if (["USER", "PREGEN"].includes(obj.type)) {
    obj.isPregen = obj.type === "PREGEN";
    obj.type = obj.scheme === "ED25519" ? "SOLANA" : "EVM";
  }
  if (!!obj.scheme && !obj.type) {
    obj.type = obj.scheme === "ED25519" ? "SOLANA" : "EVM";
  }
  return obj;
}
function supportedWalletTypesEq(a, b) {
  return a.length === b.length && a.every(({ type, optional }, index) => b[index].type === type && b[index].optional === optional);
}
function mergeCurrentWalletIds(original, additional) {
  return [.../* @__PURE__ */ new Set([...Object.keys(original), ...Object.keys(additional)])].reduce((acc, key) => {
    return __spreadProps(__spreadValues({}, acc), {
      [key]: [.../* @__PURE__ */ new Set([...original[key] || [], ...additional[key] || []])]
    });
  }, {});
}
function newUuid() {
  return uuid.v4();
}
export {
  WalletSchemeTypeMap,
  entityToWallet,
  getEquivalentTypes,
  getSchemes,
  getWalletTypes,
  isPregenIdentifierMatch,
  isWalletSupported,
  mergeCurrentWalletIds,
  migrateWallet,
  newUuid,
  supportedWalletTypesEq
};

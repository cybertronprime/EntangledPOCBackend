import { AuthMethod, AuthExtras, CurrentWalletIds, EmailTheme, PartnerEntity, TWalletType, PregenIds, BiometricLocationHint, Auth, SupportedWalletTypes, AuthIdentifier, AuthType, ExternalWalletInfo, PrimaryAuthInfo, SessionInfo, PrimaryAuth, PrimaryAuthType, AccountMetadata, LinkedAccounts, VerifyLinkParams, VerifyExternalWalletParams, SupportedAccountLinks, OnRampPurchase } from '@getpara/user-management-client';
import type { pki as pkiType } from 'node-forge';
import { Ctx, Environment, Theme, WalletFilters, Wallet, PortalUrlOptions, ConstructorOpts, CoreAuthInfo, PortalUrlType, CoreMethodParams, CoreMethodResponse, NewCredentialUrlParams, LoginUrlParams, CoreInterface, ExternalWalletConnectionType, AccountLinkInProgress, InternalMethodParams, InternalMethodResponse } from './types/index.js';
import { PlatformUtils } from './PlatformUtils.js';
export declare abstract class ParaCore implements CoreInterface {
    #private;
    static version?: string;
    ctx: Ctx;
    protected isNativePasskey: boolean;
    protected isPartnerOptional?: boolean;
    isReady: boolean;
    get authInfo(): CoreAuthInfo | undefined;
    get email(): AuthIdentifier<'email'> | undefined;
    get phone(): AuthIdentifier<'phone'> | undefined;
    get farcasterUsername(): AuthIdentifier<'farcaster'> | undefined;
    get telegramUserId(): AuthIdentifier<'telegram'> | undefined;
    get externalWalletWithParaAuth(): Wallet | undefined;
    get externalWalletConnectionType(): ExternalWalletConnectionType;
    protected partner?: PartnerEntity;
    userId?: string;
    accountLinkInProgress: AccountLinkInProgress | undefined;
    private sessionCookie?;
    private isAwaitingAccountCreation;
    private isAwaitingLogin;
    private isAwaitingFarcaster;
    private isAwaitingOAuth;
    private isWorkerInitialized;
    get isEmail(): boolean;
    get isPhone(): boolean;
    get isFarcaster(): boolean;
    get isTelegram(): boolean;
    get isExternalWalletAuth(): boolean;
    get isExternalWalletWithVerification(): boolean;
    get partnerId(): string | undefined;
    protected get partnerName(): string | undefined;
    protected get partnerLogo(): string | undefined;
    /**
     * The IDs of the currently active wallets, for each supported wallet type. Any signer integrations will default to the first viable wallet ID in this dictionary.
     */
    currentWalletIds: CurrentWalletIds;
    get currentWalletIdsArray(): [string, TWalletType][];
    get currentWalletIdsUnique(): string[];
    /**
     * Wallets associated with the `ParaCore` instance. Retrieve a particular wallet using `para.wallets[walletId]`.
     */
    wallets: Record<string, Wallet>;
    /**
     * Wallets associated with the `ParaCore` instance.
     */
    externalWallets: Record<string, Wallet>;
    /**
     * A map of pre-generated wallet identifiers that can be claimed in the current instance.
     */
    get pregenIds(): PregenIds;
    /**
     * Whether the instance has multiple wallets connected.
     */
    get isMultiWallet(): boolean;
    /**
     * Base theme for the emails sent from this Para instance.
     * @default - dark
     * @deprecated configure theming through the developer portal
     */
    emailTheme?: EmailTheme;
    /**
     * Hex color to use as the primary color in the emails.
     * @default - #FE452B
     * @deprecated configure theming through the developer portal
     */
    emailPrimaryColor?: string;
    /**
     * Linkedin URL to link to in the emails. Should be a secure URL string starting with https://www.linkedin.com/company/.
     * @deprecated configure this through the developer portal
     */
    linkedinUrl?: string;
    /**
     * Github URL to link to in the emails. Should be a secure URL string starting with https://github.com/.
     * @deprecated configure this through the developer portal
     */
    githubUrl?: string;
    /**
     * X (Twitter) URL to link to in the emails. Should be a secure URL string starting with https://twitter.com/.
     * @deprecated configure this through the developer portal
     */
    xUrl?: string;
    /**
     * Support URL to link to in the emails. This can be a secure https URL or a mailto: string. Will default to using the stored application URL is nothing is provided here.
     * @deprecated homepageUrl will be used for this, configure it through the developer portal
     */
    supportUrl?: string;
    /**
     * URL for your home landing page. Should be a secure URL string starting with https://.
     * @deprecated configure this through the developer portal
     */
    homepageUrl?: string;
    /**
     * Encryption key pair generated from loginEncryptionKey.
     */
    loginEncryptionKeyPair?: pkiType.rsa.KeyPair;
    /**
     * Hex color to use in the portal for the background color.
     * @deprecated use portalTheme instead
     */
    portalBackgroundColor?: string;
    /**
     * Hex color to use in the portal for the primary button.
     * @deprecated use portalTheme instead
     */
    portalPrimaryButtonColor?: string;
    /**
     * Hex text color to use in the portal.
     * @deprecated use portalTheme instead
     */
    portalTextColor?: string;
    /**
     * Hex color to use in the portal for the primary button text.
     * @deprecated use portalTheme instead
     */
    portalPrimaryButtonTextColor?: string;
    /**
     * Theme to use for the portal
     * @deprecated configure theming through the developer portal
     */
    portalTheme?: Theme;
    /**
     * Whether or not to treat external wallets as connections only, skipping all Para functionality.
     */
    externalWalletConnectionOnly?: boolean;
    private disableProviderModal?;
    private fetchPregenWalletsOverride?;
    get isNoWalletConfig(): boolean;
    get supportedWalletTypes(): SupportedWalletTypes;
    get cosmosPrefix(): string | undefined;
    get supportedAccountLinks(): SupportedAccountLinks;
    get isWalletTypeEnabled(): Partial<Record<TWalletType, boolean>>;
    protected onRampPopup: {
        window: Window;
        onRampPurchase: OnRampPurchase;
    } | undefined;
    protected platformUtils: PlatformUtils;
    private localStorageGetItem;
    private localStorageSetItem;
    private localStorageRemoveItem;
    private sessionStorageGetItem;
    private sessionStorageSetItem;
    private sessionStorageRemoveItem;
    retrieveSessionCookie: () => string | undefined;
    persistSessionCookie: (cookie: string) => void;
    /**
     * Remove all local storage and prefixed session storage.
     * @param {'local' | 'session' | 'secure' | 'all'} type - Type of storage to clear. Defaults to 'all'.
     */
    clearStorage: (type?: CoreMethodParams<"clearStorage">) => CoreMethodResponse<"clearStorage">;
    private convertBigInt;
    private convertEncryptionKeyPair;
    protected isPortal(envOverride?: Environment): boolean;
    private isParaConnect;
    private requireApiKey;
    private isWalletSupported;
    private isWalletOwned;
    private isPregenWalletUnclaimed;
    private isPregenWalletClaimable;
    private isWalletUsable;
    /**
     * Returns the formatted address for the desired wallet ID, depending on your app settings.
     * @param {string} walletId the ID of the wallet address to display.
     * @param {object} options additional options for formatting the address.
     * @param {boolean} options.truncate whether to truncate the address.
     * @param {TWalletType} options.addressType the type of address to display.
     * @returns the formatted address
     */
    getDisplayAddress(walletId: string, options?: {
        truncate?: boolean;
        addressType?: TWalletType | undefined;
        cosmosPrefix?: string;
        targetLength?: number;
    } | undefined): string;
    /**
     * Returns a unique hash for a wallet suitable for use as an identicon seed.
     * @param {string} walletId the ID of the wallet.
     * @param {boolean} options.addressType used to format the hash for another wallet type.
     * @returns the identicon hash string
     */
    getIdenticonHash(walletId: string, overrideType?: TWalletType): string | undefined;
    getWallets(): Record<string, Wallet>;
    getAddress(walletId?: string): string | undefined;
    protected abstract getPlatformUtils(): PlatformUtils;
    abstract isPasskeySupported(): Promise<boolean>;
    protected constructPortalUrl(type: PortalUrlType, opts?: PortalUrlOptions): Promise<string>;
    static resolveEnvironment(env: Environment | undefined, apiKey: string | undefined): Environment;
    /**
     * Constructs a new `ParaCore` instance.
     * @param env - `Environment` to use. Optional if the apiKey contains an environment prefix (e.g., "prod_your_api_key"). Updated API keys can be found at https://developer.getpara.com.
     * @param apiKey - API key to use.
     * @param opts - Additional constructor options; see `ConstructorOpts`.
     * @returns - A new ParaCore instance.
     */
    constructor(env: Environment | undefined, apiKey: string, opts?: ConstructorOpts);
    constructor(apiKey: string, opts?: ConstructorOpts);
    private trackError;
    private wrapMethodsWithErrorTracking;
    private initializeFromStorage;
    private updateAuthInfoFromStorage;
    private updateUserIdFromStorage;
    private updateWalletsFromStorage;
    private updateWalletIdsFromStorage;
    private updateSessionCookieFromStorage;
    private updateLoginEncryptionKeyPairFromStorage;
    private updateExternalWalletsFromStorage;
    protected initializeWorker: () => Promise<void>;
    touchSession(regenerate?: boolean): Promise<SessionInfo>;
    private getVerificationEmailProps;
    private getBackupKitEmailProps;
    /**
     * Initialize storage relating to a `ParaCore` instance.
     *
     * Init only needs to be called for storage that is async.
     */
    init(): Promise<void>;
    /**
     * Call this method to perform initial setup for the `ParaCore` instance.
     *
     * This method will be called automatically if you use the React `ParaProvider` or when you call any methods that request an updated session.
     */
    abstract ready(): Promise<void>;
    protected setAuth(auth: PrimaryAuth, { extras, userId }?: {
        extras?: AuthExtras;
        userId?: string;
    }): Promise<typeof this.authInfo>;
    protected assertUserId({ allowGuestMode }?: {
        allowGuestMode?: boolean;
    }): string;
    protected assertIsAuthSet(allowed?: AuthType[]): PrimaryAuthInfo;
    /**
     * Sets the email associated with the `ParaCore` instance.
     * @param email - Email to set.
     */
    setEmail(email: string): Promise<void>;
    /**
     * Sets the Telegram user ID associated with the `ParaCore` instance.
     * @param telegramUserId - Telegram user ID to set.
     */
    setTelegramUserId(telegramUserId: string): Promise<void>;
    /**
     * Sets the phone number associated with the `ParaCore` instance.
     * @param phone - Phone number to set.
     * @param countryCode - Country Code to set.
     */
    setPhoneNumber(phone: `+${number}` | string, countryCode?: string): Promise<void>;
    /**
     * Sets the farcaster username associated with the `ParaCore` instance.
     * @param farcasterUsername - Farcaster Username to set.
     */
    setFarcasterUsername(farcasterUsername: string): Promise<void>;
    /**
     * Sets the external wallet address and type associated with the `ParaCore` instance.
     * @param externalAddress - External wallet address to set.
     * @param externalType - Type of external wallet to set.
     */
    setExternalWallet(externalWallet: ExternalWalletInfo[] | ExternalWalletInfo): Promise<void>;
    protected addExternalWallets(externalWallets: ExternalWalletInfo[]): Promise<void>;
    /**
     * Sets the user id associated with the `ParaCore` instance.
     * @param userId - User id to set.
     */
    setUserId(userId: string): Promise<void>;
    /**
     * Sets the wallets associated with the `ParaCore` instance.
     * @param wallets - Wallets to set.
     */
    setWallets(wallets: Record<string, Wallet>): Promise<void>;
    /**
     * Sets the external wallets associated with the `ParaCore` instance.
     * @param externalWallets - External wallets to set.
     */
    setExternalWallets(externalWallets: Record<string, Wallet>): Promise<void>;
    /**
     * Sets the login encryption key pair associated with the `ParaCore` instance.
     * @param keyPair - Encryption key pair generated from loginEncryptionKey.
     */
    protected setLoginEncryptionKeyPair(keyPair?: pkiType.rsa.KeyPair): Promise<void>;
    private deleteLoginEncryptionKeyPair;
    /**
     * Gets the userId associated with the `ParaCore` instance.
     * @returns - userId associated with the `ParaCore` instance.
     */
    getUserId(): string | undefined;
    getAuthInfo(): CoreAuthInfo | undefined;
    /**
     * Gets the email associated with the `ParaCore` instance.
     * @returns - email associated with the `ParaCore` instance.
     */
    getEmail(): string | undefined;
    /**
     * Gets the formatted phone number associated with the `ParaCore` instance.
     * @returns - formatted phone number associated with the `ParaCore` instance.
     */
    getPhoneNumber(): `+${number}` | undefined;
    /**
     * Gets the farcaster username associated with the `ParaCore` instance.
     * @returns - farcaster username associated with the `ParaCore` instance.
     */
    getFarcasterUsername(): string | undefined;
    setCurrentWalletIds(currentWalletIds: CurrentWalletIds, { needsWallet, sessionLookupId, newDeviceSessionLookupId, }?: {
        needsWallet?: boolean;
        sessionLookupId?: string;
        newDeviceSessionLookupId?: string;
    }): Promise<void>;
    /**
     * Fetches the most recent OAuth account metadata for the signed-in user.
     * If applicable, this will include the user's most recent metadata from their Google, Apple, Facebook, X, Discord, Farcaster, or Telegram account, the last time they signed in to your app.
     * @deprecated use `para.getLinkedAccounts({ withMetadata: true })` instead.
     * @returns {Promise<AccountMetadata>} the user's account metadata.
     */
    getAccountMetadata(): Promise<AccountMetadata>;
    /**
     * Validates that a wallet ID is present on the instance, usable, and matches the desired filters.
     * If no ID is passed, this will instead return the first valid, usable wallet ID that matches the filters.
     * @param {string} [walletId] the wallet ID to validate.
     * @param {WalletFilters} [filter={}] a `WalletFilters` object specifying allowed types, schemes, and whether to forbid unclaimed pregen wallets.
     * @returns {string} the wallet ID originally passed, or the one found.
     */
    findWalletId(walletId?: string, filter?: WalletFilters): string;
    /**
     * Retrieves a wallet with the given address, if present.
     * If no ID is passed, this will instead return the first valid, usable wallet ID that matches the filters.
     * @param {string} [walletId] the wallet ID to validate.
     * @param {WalletFilters} [filter={}] a `WalletFilters` object specifying allowed types, schemes, and whether to forbid unclaimed pregen wallets.
     * @returns {string} the wallet ID originally passed, or the one found.
     */
    findWalletByAddress(address: string, filter?: WalletFilters | undefined): any;
    findWallet(idOrAddress?: string, overrideType?: TWalletType, filter?: WalletFilters): Omit<Wallet, 'signer'> | undefined;
    get availableWallets(): Pick<Wallet, 'id' | 'type' | 'name' | 'address' | 'isExternal' | 'externalProviderId' | 'isExternalConnectionOnly'>[];
    /**
     * Retrieves all usable wallets with the provided type (`'EVM' | 'COSMOS' | 'SOLANA'`)
     * @param {string} type the wallet type to filter by.
     * @returns {Wallet[]} an array of matching wallets.
     */
    getWalletsByType(type: CoreMethodParams<'getWalletsByType'>): CoreMethodResponse<'getWalletsByType'>;
    private assertIsValidWalletId;
    private assertIsValidWalletType;
    private getMissingTypes;
    private getTypesToCreate;
    private getPartnerURL;
    /**
     * URL of the portal, which can be associated with a partner id
     * @param partnerId: string - id of the partner to get the portal URL for
     * @returns - portal URL
     */
    protected getPortalURL(): Promise<string>;
    /**
     * Gets the private key for the given wallet.
     * @param {string } [walletId] id of the wallet to get the private key for. Will default to the first wallet if not provided.
     * @returns - the private key string.
     */
    protected getPrivateKey(walletId?: string): Promise<string>;
    /**
     * Fetches the wallets associated with the user.
     * @returns {WalletEntity[]} wallets that were fetched.
     */
    fetchWallets(): CoreMethodResponse<'fetchWallets'>;
    private populateWalletAddresses;
    private populatePregenWalletAddresses;
    /**
     * Logs in or creates a new user using an external wallet address.
     * @param {Object} opts the options object
     * @param {string} opts.address the external wallet address to use for identification.
     * @param {TWalletType} opts.type type of external wallet to use for identification.
     * @param {string} opts.provider the name of the provider for the external wallet.
     */
    loginExternalWallet({ externalWallet, ...urlOptions }: CoreMethodParams<'loginExternalWallet'>): CoreMethodResponse<'loginExternalWallet'>;
    verifyExternalWallet({ externalWallet, signedMessage, cosmosPublicKeyHex, cosmosSigner, ...urlOptions }: CoreMethodParams<'verifyExternalWallet'>): CoreMethodResponse<'verifyExternalWallet'>;
    protected verifyExternalWalletLink(opts: InternalMethodParams<'verifyExternalWalletLink'>): InternalMethodResponse<'verifyExternalWalletLink'>;
    protected verifyTelegramProcess(opts: CoreMethodParams<'verifyTelegram'> & {
        isLinkAccount: false;
    }): CoreMethodResponse<'verifyTelegram'>;
    protected verifyTelegramProcess(opts: InternalMethodParams<'verifyTelegramLink'> & {
        isLinkAccount: true;
    }): InternalMethodResponse<'verifyTelegramLink'>;
    verifyTelegram(opts: CoreMethodParams<'verifyTelegram'>): CoreMethodResponse<'verifyTelegram'>;
    protected verifyTelegramLink(opts: InternalMethodParams<'verifyTelegramLink'>): InternalMethodResponse<'verifyTelegramLink'>;
    /**
     * Performs 2FA verification.
     * @param {Object} opts the options object
     * @param {string} opts.email the email to use for performing a 2FA verification.
     * @param {string} opts.verificationCode the verification code to received via 2FA.
     * @returns {Object} `{ address, initiatedAt, status, userId, walletId }`
     */
    verify2fa({ auth, verificationCode }: CoreMethodParams<'verify2fa'>): CoreMethodResponse<'verify2fa'>;
    /**
     * Sets up two-factor authentication for the current user.
     * @returns {string} uri - uri to use for setting up 2FA
     * */
    setup2fa(): CoreMethodResponse<'setup2fa'>;
    /**
     * Enables 2FA.
     * @param {Object} opts the options object
     * @param {string} opts.verificationCode - the verification code received via 2FA.
     */
    enable2fa({ verificationCode }: CoreMethodParams<'enable2fa'>): CoreMethodResponse<'enable2fa'>;
    /**
     * Resend a verification email for the current user.
     */
    resendVerificationCode({ type: reason, }: CoreMethodParams<'resendVerificationCode'>): CoreMethodResponse<'resendVerificationCode'>;
    /**
     * Checks if the current session is active.
     * @returns `true` if active, `false` otherwise
     */
    isSessionActive(): CoreMethodResponse<'isSessionActive'>;
    /**
     * Checks if a session is active and a wallet exists.
     * @returns `true` if active, `false` otherwise
     **/
    isFullyLoggedIn(): CoreMethodResponse<'isFullyLoggedIn'>;
    get isGuestMode(): boolean;
    /**
     * Get the auth methods available to an existing user
     */
    protected supportedAuthMethods(auth: Auth<PrimaryAuthType | 'userId'>): Promise<Set<AuthMethod>>;
    /**
     * Get hints associated with the users stored biometrics.
     * @deprecated
     * @returns Array containing useragents and AAGuids for stored biometrics
     */
    protected getUserBiometricLocationHints(): Promise<BiometricLocationHint[]>;
    /**
     * Waits for the session to be active.
     **/
    waitForSignup({ isCanceled, onCancel, onPoll, }: CoreMethodParams<'waitForSignup'>): CoreMethodResponse<'waitForSignup'>;
    waitForWalletCreation({ isCanceled, onCancel, }?: CoreMethodParams<'waitForWalletCreation'>): CoreMethodResponse<'waitForWalletCreation'>;
    /**
     * Initiates a Farcaster login attempt and returns the URL for the user to connect.
     * You can create a QR code with this URI that works with Farcaster's mobile app.
     * @return {string} the Farcaster connect URI
     */
    getFarcasterConnectUri({ appScheme }?: {
        appScheme?: string;
    }): CoreMethodResponse<'getFarcasterConnectUri'>;
    protected verifyFarcasterProcess(opts: CoreMethodParams<'verifyFarcaster'> & {
        isLinkAccount: false;
    }): CoreMethodResponse<'verifyFarcaster'>;
    protected verifyFarcasterProcess(opts: InternalMethodParams<'verifyFarcasterLink'> & {
        isLinkAccount: true;
    }): InternalMethodResponse<'verifyFarcasterLink'>;
    verifyFarcaster(opts: CoreMethodParams<'verifyFarcaster'>): CoreMethodResponse<'verifyFarcaster'>;
    protected verifyFarcasterLink(opts: InternalMethodParams<'verifyFarcasterLink'>): InternalMethodResponse<'verifyFarcasterLink'>;
    getOAuthUrl(opts: CoreMethodParams<'getOAuthUrl'>): CoreMethodResponse<'getOAuthUrl'>;
    protected verifyOAuthProcess(_: InternalMethodParams<'verifyOAuthLink'> & {
        isLinkAccount: true;
    }): InternalMethodResponse<'verifyOAuthLink'>;
    protected verifyOAuthProcess(_: CoreMethodParams<'verifyOAuth'> & {
        isLinkAccount: false;
    }): CoreMethodResponse<'verifyOAuth'>;
    verifyOAuth(opts: CoreMethodParams<'verifyOAuth'>): CoreMethodResponse<'verifyOAuth'>;
    protected verifyOAuthLink(opts: InternalMethodParams<'verifyOAuthLink'>): InternalMethodResponse<'verifyOAuthLink'>;
    /**
     * Waits for the session to be active and sets up the user.
     *
     * @param {Object} opts the options object
     * @param {Window} [opts.popupWindow] the popup window being used for login.
     * @param {boolean} [opts.skipSessionRefresh] whether to skip refreshing the session.
     * @returns {Object} `{ isComplete: boolean; isError: boolean; needsWallet: boolean; partnerId: string; }` the result data
     **/
    waitForLogin({ isCanceled, onCancel, onPoll, skipSessionRefresh, }?: CoreMethodParams<'waitForLogin'>): CoreMethodResponse<'waitForLogin'>;
    /**
     * Updates the session with the user management server, possibly
     * opening a popup to refresh the session.
     *
     * @param {Object} opts the options object.
     * @param {boolean} [shouldOpenPopup] - if `true`, the running device will open a popup to reauthenticate the user.
     * @returns a URL for the user to reauthenticate.
     **/
    refreshSession({ shouldOpenPopup, }?: CoreMethodParams<'refreshSession'>): CoreMethodResponse<'refreshSession'>;
    /**
     * Call this method after login to ensure that the user ID is set
     * internally.
     **/
    protected userSetupAfterLogin(): Promise<SessionInfo>;
    /**
     * Get transmission shares associated with session.
     * @param {Object} opts the options object.
     * @param {boolean} opts.isForNewDevice - true if this device is registering.
     * @returns - transmission keyshares.
     **/
    protected getTransmissionKeyShares({ isForNewDevice }?: {
        isForNewDevice?: boolean;
    }): Promise<any>;
    /**
     * Call this method after login to perform setup.
     * @param {Object} opts the options object.
     * @param {any[]} opts.temporaryShares optional temporary shares to use for decryption.
     * @param {boolean} [opts.skipSessionRefresh] - whether or not to skip refreshing the session.
     **/
    protected setupAfterLogin({ temporaryShares, skipSessionRefresh, }?: {
        temporaryShares?: any[];
        skipSessionRefresh?: boolean;
    }): Promise<void>;
    /**
     * Distributes a new wallet recovery share.
     * @param {Object} opts the options object.
     * @param {string} opts.walletId the wallet to distribute the recovery share for.
     * @param {string} opts.userShare optional user share generate the recovery share from. Defaults to the signer from the passed in walletId
     * @param {boolean} opts.skipBiometricShareCreation whether or not to skip biometric share creation. Used when regenerating recovery shares.
     * @param {boolean} opts.forceRefreshRecovery whether or not to force recovery secret regeneration. Used when regenerating recovery shares.
     * @returns {string} the recovery share.
     **/
    distributeNewWalletShare({ walletId, userShare, skipBiometricShareCreation, forceRefresh, }: CoreMethodParams<'distributeNewWalletShare'>): CoreMethodResponse<'distributeNewWalletShare'>;
    private waitForWalletAddress;
    /**
     * Waits for a pregen wallet address to be created.
     *
     * @param pregenIdentifier - the identifier of the user the pregen wallet is associated with.
     * @param walletId - the wallet id
     * @param pregenIdentifierType - the identifier type of the user the pregen wallet is associated with.
     * @returns - recovery share.
     **/
    private waitForPregenWalletAddress;
    /**
     * Creates several new wallets with the desired types. If no types are provided, this method
     * will create one for each of the non-optional types specified in the instance's `supportedWalletTypes`
     * object that are not already present. This is automatically called upon account creation to ensure that
     * the user has a wallet of each required type.
     *
     * @deprecated alias for `createWalletPerType`
     **/
    createWalletPerMissingType: ({ skipDistribute, types, }?: CoreMethodParams<"createWalletPerType">) => CoreMethodResponse<"createWalletPerType">;
    /**
     * Creates several new wallets with the desired types. If no types are provided, this method
     * will create one for each of the non-optional types specified in the instance's `supportedWalletTypes`
     * object that are not already present. This is automatically called upon account creation to ensure that
     * the user has a wallet of each required type.
     *
     * @param {Object} [opts] the options object.
     * @param {boolean} [opts.skipDistribute] if `true`, the wallets' recovery share will not be distributed.
     * @param {TWalletType[]} [opts.types] the types of wallets to create.
     * @returns {Object} the wallets created, their ids, and the recovery secret.
     **/
    createWalletPerType({ skipDistribute, types, }?: CoreMethodParams<'createWalletPerType'>): CoreMethodResponse<'createWalletPerType'>;
    /**
     * Refresh the current user share for a wallet.
     *
     * @param {Object} opts the options object.
     * @param {string} opts.walletId the wallet id to refresh.
     * @param {string} opts.share the current user share.
     * @param {string} [opts.oldPartnerId] the current partner id.
     * @param {string} [opts.newPartnerId] the new partner id to set, if any.
     * @param {string} [opts.keyShareProtocolId]
     * @param {boolean} [opts.redistributeBackupEncryptedShares] whether or not to redistribute backup encrypted shares.
     * @returns {Object} the new user share and recovery secret.
     **/
    refreshShare({ walletId, share, oldPartnerId, newPartnerId, keyShareProtocolId, redistributeBackupEncryptedShares, }: CoreMethodParams<'refreshShare'>): CoreMethodResponse<'refreshShare'>;
    /**
     * Creates a new wallet.
     * @param {Object} opts the options object.
     * @param {TWalletType} opts.type the type of wallet to create.
     * @param {boolean} opts.skipDistribute - if true, recovery share will not be distributed.
     * @returns {[Wallet, string | null]} `[wallet, recoveryShare]` - the wallet object and the new recovery share.
     **/
    createWallet({ type: _type, skipDistribute, }?: CoreMethodParams<'createWallet'>): CoreMethodResponse<'createWallet'>;
    createPregenWallet(opts: CoreMethodParams<'createPregenWallet'>): CoreMethodResponse<'createPregenWallet'>;
    /**
     * Creates new pregenerated wallets for each desired type.
     * If no types are provided, this method will create one for each of the non-optional types
     * specified in the instance's `supportedWalletTypes` array that are not already present.
     * @param {Object} opts the options object.
     * @param {string} opts.pregenIdentifier the identifier to associate each wallet with.
     * @param {TPregenIdentifierType} opts.pregenIdentifierType - either `'EMAIL'` or `'PHONE'`.
     * @param {TWalletType[]} [opts.types] the wallet types to create. Defaults to any types the instance supports that are not already present.
     * @returns {Wallet[]} an array containing the created wallets.
     **/
    createPregenWalletPerType({ types, pregenId, }: CoreMethodParams<'createPregenWalletPerType'>): CoreMethodResponse<'createPregenWalletPerType'>;
    /**
     * Claims a pregenerated wallet.
     * @param {Object} opts the options object.
     * @param {string} opts.pregenIdentifier string the identifier of the user claiming the wallet
     * @param {TPregenIdentifierType} opts.pregenIdentifierType type of the identifier of the user claiming the wallet
     * @returns {[Wallet, string | null]} `[wallet, recoveryShare]` - the wallet object and the new recovery share.
     **/
    claimPregenWallets({ pregenId, }?: CoreMethodParams<'claimPregenWallets'>): CoreMethodResponse<'claimPregenWallets'>;
    /**
     * Updates the identifier for a pregen wallet.
     * @param {Object} opts the options object.
     * @param {string} opts.walletId the pregen wallet ID
     * @param {string} opts.newPregenIdentifier the new identtifier
     * @param {TPregenIdentifierType} opts.newPregenIdentifierType: the new identifier type
     **/
    updatePregenWalletIdentifier({ walletId, newPregenId, }: CoreMethodParams<'updatePregenWalletIdentifier'>): CoreMethodResponse<'updatePregenWalletIdentifier'>;
    /**
     * Checks if a pregen Wallet exists for the given identifier with the current partner.
     * @param {Object} opts the options object.
     * @param {string} opts.pregenIdentifier string the identifier of the user claiming the wallet
     * @param {TPregenIdentifierType} opts.pregenIdentifierType type of the string of the identifier of the user claiming the wallet
     * @returns {boolean} whether the pregen wallet exists
     **/
    hasPregenWallet({ pregenId }: CoreMethodParams<'hasPregenWallet'>): CoreMethodResponse<'hasPregenWallet'>;
    /**
     * Get pregen wallets for the given identifier.
     * @param {Object} opts the options object.
     * @param {string} opts.pregenIdentifier - the identifier of the user claiming the wallet
     * @param {TPregenIdentifierType} opts.pregenIdentifierType - type of the identifier of the user claiming the wallet
     * @returns {Promise<WalletEntity[]>} the array of found wallets
     **/
    getPregenWallets({ pregenId }?: CoreMethodParams<'getPregenWallets'>): CoreMethodResponse<'getPregenWallets'>;
    createGuestWallets(): CoreMethodResponse<'createGuestWallets'>;
    private encodeWalletBase64;
    /**
     * Encodes the current wallets encoded in Base 64.
     * @returns {string} the encoded wallet string
     **/
    getUserShare(): CoreMethodResponse<'getUserShare'>;
    /**
     * Sets the current wallets from a Base 64 string.
     * @param {string} base64Wallet the encoded wallet string
     **/
    setUserShare(base64Wallets: CoreMethodParams<'setUserShare'>): CoreMethodResponse<'setUserShare'>;
    private getTransactionReviewUrl;
    private getOnRampTransactionUrl;
    getWalletBalance: ({ walletId, rpcUrl, }: CoreMethodParams<"getWalletBalance">) => CoreMethodResponse<"getWalletBalance">;
    /**
     * Signs a message using one of the current wallets.
     *
     * If you want to sign the keccak256 hash of a message, hash the
     * message first and then pass in the base64 encoded hash.
     * @param {Object} opts the options object.
     * @param {string} opts.walletId the id of the wallet to sign with.
     * @param {string} opts.messageBase64 the base64 encoding of exact message that should be signed
     * @param {number} [opts.timeout] optional timeout in milliseconds. If not present, defaults to 30 seconds.
     * @param {string} [opts.cosmosSignDocBase64] the Cosmos `SignDoc` in base64, if applicable
     **/
    signMessage({ walletId, messageBase64, timeoutMs, cosmosSignDocBase64, isCanceled, onCancel, onPoll, }: CoreMethodParams<'signMessage'>): CoreMethodResponse<'signMessage'>;
    private signMessageInner;
    /**
     * Signs a transaction.
     * @param {Object} opts the options object.
     * @param {string} opts.walletId the id of the wallet to sign with.
     * @param {string} opts.rlpEncodedTxBase64 the transaction to sign, in RLP base64 encoding
     * @param {string} [opts.chainId] the EVM chain id of the chain the transaction is being sent on, if applicable
     * @param {number} [opts.timeoutMs] the amount of time to wait for the user to sign the transaction, in milliseconds
     **/
    signTransaction({ walletId, rlpEncodedTxBase64, chainId, timeoutMs, isCanceled, onCancel, onPoll, }: CoreMethodParams<'signTransaction'>): CoreMethodResponse<'signTransaction'>;
    protected isProviderModalDisabled(): boolean;
    /**
     * Starts a on-ramp or off-ramp transaction and returns the Para Portal link for the user to finalize and complete it.
     * @param {Object} opts the options object
     * @param {OnRampPurchaseCreateParams} opts.params the transaction settings.
     * @param {boolean} opts.shouldOpenPopup if `true`, a popup window with the link will be opened.
     * @param {string} opts.walletId the wallet ID to use for the transaction, where funds will be sent or withdrawn.
     * @param {string} opts.externalWalletAddress the external wallet address to send funds to or withdraw funds from, if using an external wallet.
     **/
    initiateOnRampTransaction(options: CoreMethodParams<'initiateOnRampTransaction'>): CoreMethodResponse<'initiateOnRampTransaction'>;
    /**
     * Returns `true` if session was successfully kept alive, `false` otherwise.
     **/
    keepSessionAlive(): Promise<boolean>;
    /**
     * Serialize the current session for import by another Para instance.
     * @param {boolean} excludeSigners - whether or not to exclude the signer from the exported wallets.
     * @returns {string} the serialized session
     */
    exportSession({ excludeSigners }?: CoreMethodParams<'exportSession'>): CoreMethodResponse<'exportSession'>;
    /**
     * Imports a session serialized by another Para instance.
     * @param {string} serializedInstanceBase64 the serialized session
     */
    importSession(serializedInstanceBase64: CoreMethodParams<'importSession'>): CoreMethodResponse<'importSession'>;
    /**
     * Retrieves a token to verify the current session.
     * @returns {Promise<string>} the ID
     **/
    getVerificationToken(): CoreMethodResponse<'getVerificationToken'>;
    issueJwt({ keyIndex }?: CoreMethodParams<'issueJwt'>): CoreMethodResponse<'issueJwt'>;
    /**
     * Logs the user out.
     * @param {Object} opts the options object.
     * @param {boolean} opts.clearPregenWallets if `true`, will remove all pregen wallets from storage
     **/
    logout({ clearPregenWallets }?: {
        clearPregenWallets?: boolean;
    }): Promise<void>;
    protected get toStringAdditions(): Record<string, unknown>;
    /**
     * Converts to a string, removing sensitive data when logging this class.
     *
     * Doesn't work for all types of logging.
     **/
    toString(): string;
    protected devLog(...s: string[]): void;
    protected getNewCredentialAndUrl({ authMethod, isForNewDevice, portalTheme, shorten, }?: NewCredentialUrlParams): Promise<{
        credentialId: string;
        url?: string;
    }>;
    /**
     * Returns a Para Portal URL for logging in with a WebAuth passkey, password or PIN.
     * @param {Object} opts the options object
     * @param {String} opts.auth - the user auth to sign up or log in with, in the form ` { email: string } | { phone: `+${number}` } `
     * @param {boolean} opts.useShortUrls - whether to shorten the generated portal URLs
     * @param {Theme} opts.portalTheme the Para Portal theme to apply to the password creation URL, if other than the default theme
     * @returns {SignUpOrLogInResponse} an object in the form of either: `{ stage: 'verify' }` or `{ stage: 'login'; passkeyUrl?: string; passwordUrl?: string; biometricHints?: BiometricLocationHint[] }`
     */
    protected getLoginUrl({ authMethod, shorten, portalTheme, sessionId, }: LoginUrlParams): Promise<string>;
    protected prepareLogin(): InternalMethodResponse<'prepareLogin'>;
    signUpOrLogIn({ auth, ...urlOptions }: CoreMethodParams<'signUpOrLogIn'>): CoreMethodResponse<'signUpOrLogIn'>;
    verifyNewAccount({ verificationCode, ...urlOptions }: CoreMethodParams<'verifyNewAccount'>): CoreMethodResponse<'verifyNewAccount'>;
    getLinkedAccounts({ withMetadata, }?: CoreMethodParams<'getLinkedAccounts'>): CoreMethodResponse<'getLinkedAccounts'>;
    protected linkAccount(opts: InternalMethodParams<'linkAccount'>): InternalMethodResponse<'linkAccount'>;
    protected unlinkAccount({ linkedAccountId, }: InternalMethodParams<'unlinkAccount'>): InternalMethodResponse<'unlinkAccount'>;
    protected verifyLink({ accountLinkInProgress, ...opts }?: {
        accountLinkInProgress?: AccountLinkInProgress;
    } & Partial<Pick<VerifyLinkParams, 'verificationCode' | 'telegramAuthResponse'> & VerifyExternalWalletParams>): Promise<LinkedAccounts>;
    protected verifyEmailOrPhoneLink({ verificationCode, }: InternalMethodParams<'verifyEmailOrPhoneLink'>): InternalMethodResponse<'verifyEmailOrPhoneLink'>;
    protected sendLoginCode(): Promise<void>;
}

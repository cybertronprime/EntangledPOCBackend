var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var walletUtils_exports = {};
__export(walletUtils_exports, {
  ed25519Keygen: () => ed25519Keygen,
  ed25519PreKeygen: () => ed25519PreKeygen,
  ed25519Sign: () => ed25519Sign,
  getPrivateKey: () => getPrivateKey,
  keygen: () => keygen,
  preKeygen: () => preKeygen,
  refresh: () => refresh,
  sendTransaction: () => sendTransaction,
  signMessage: () => signMessage,
  signTransaction: () => signTransaction
});
module.exports = __toCommonJS(walletUtils_exports);
var import_core_sdk = require("@getpara/core-sdk");
var uuid = __toESM(require("uuid"));
const configCGGMPBase = (serverUrl, walletId, id) => `{"ServerUrl":"${serverUrl}", "WalletId": "${walletId}", "Id":"${id}", "Ids":["USER","CAPSULE"], "Threshold":1}`;
const configDKLSBase = (walletId, id, disableWebSockets) => `{"walletId": "${walletId}", "id":"${id}", "otherId":"CAPSULE", "isReceiver": false, "disableWebSockets": ${disableWebSockets}}`;
function keygenRequest(ctx, userId, walletId, protocolId) {
  return __async(this, null, function* () {
    const { data } = yield ctx.mpcComputationClient.post("/wallets", {
      userId,
      walletId,
      protocolId
    });
    return data;
  });
}
function signMessageRequest(ctx, userId, walletId, protocolId, message, signer) {
  return __async(this, null, function* () {
    const { data } = yield ctx.mpcComputationClient.post(`/wallets/${walletId}/messages/sign`, {
      userId,
      protocolId,
      message,
      signer
    });
    return data;
  });
}
function sendTransactionRequest(ctx, userId, walletId, protocolId, transaction, signer, chainId) {
  return __async(this, null, function* () {
    const { data } = yield ctx.mpcComputationClient.post(`/wallets/${walletId}/transactions/send`, {
      userId,
      protocolId,
      transaction,
      signer,
      chainId
    });
    return data;
  });
}
function ed25519Keygen(ctx, userId) {
  return __async(this, null, function* () {
    const { walletId, protocolId } = yield ctx.client.createWallet(userId, {
      scheme: "ED25519",
      type: "SOLANA"
    });
    const serverUrl = (0, import_core_sdk.getBaseMPCNetworkUrl)(ctx.env, !ctx.disableWebSockets);
    try {
      const newSigner = yield new Promise(
        (resolve, reject) => global.ed25519CreateAccount(serverUrl, walletId, protocolId, (err, result) => {
          if (err) {
            reject(err);
          }
          resolve(result);
        })
      );
      return { signer: newSigner, walletId };
    } catch (e) {
      throw new Error(`error creating account of type SOLANA with userId ${userId} and walletId ${walletId}`);
    }
  });
}
function ed25519PreKeygen(ctx, pregenIdentifier, pregenIdentifierType) {
  return __async(this, null, function* () {
    const { walletId, protocolId } = yield ctx.client.createPregenWallet({
      pregenIdentifier,
      pregenIdentifierType,
      scheme: "ED25519",
      type: "SOLANA"
    });
    const serverUrl = (0, import_core_sdk.getBaseMPCNetworkUrl)(ctx.env, !ctx.disableWebSockets);
    try {
      const newSigner = yield new Promise(
        (resolve, reject) => global.ed25519CreateAccount(serverUrl, walletId, protocolId, (err, result) => {
          if (err) {
            reject(err);
          }
          resolve(result);
        })
      );
      return { signer: newSigner, walletId };
    } catch (e) {
      throw new Error(`error creating account of type SOLANA with walletId ${walletId}`);
    }
  });
}
function ed25519Sign(ctx, share, userId, walletId, base64Bytes) {
  return __async(this, null, function* () {
    const protocolId = uuid.v4();
    const preSignMessageRes = ctx.client.preSignMessage(userId, walletId, base64Bytes, "ED25519", void 0, protocolId);
    const signRes = function() {
      return __async(this, null, function* () {
        try {
          const base64Sig = yield new Promise(
            (resolve, reject) => global.ed25519Sign(share, protocolId, base64Bytes, (err, result) => {
              if (err) {
                reject(err);
              }
              resolve(result);
            })
          );
          return { signature: base64Sig };
        } catch (e) {
          throw new Error(`error signing for account of type SOLANA with userId ${userId} and walletId ${walletId}`);
        }
      });
    }();
    const { pendingTransactionId } = yield preSignMessageRes;
    if (pendingTransactionId) {
      return { pendingTransactionId };
    }
    return yield signRes;
  });
}
function keygen(ctx, userId, type, secretKey) {
  return __async(this, null, function* () {
    const { walletId, protocolId } = yield ctx.client.createWallet(userId, {
      useTwoSigners: true,
      scheme: ctx.useDKLS ? "DKLS" : "CGGMP",
      type,
      cosmosPrefix: type === "COSMOS" ? ctx.cosmosPrefix : void 0
    });
    if (ctx.offloadMPCComputationURL && !ctx.useDKLS) {
      return {
        signer: (yield keygenRequest(ctx, userId, walletId, protocolId)).signer,
        walletId
      };
    }
    const serverUrl = (0, import_core_sdk.getBaseMPCNetworkUrl)(ctx.env, !ctx.disableWebSockets);
    const signerConfigUser = ctx.useDKLS ? configDKLSBase(walletId, "USER", ctx.disableWebSockets) : configCGGMPBase(serverUrl, walletId, "USER");
    const createAccountFn = ctx.useDKLS ? global.dklsCreateAccount : global.createAccountV2;
    try {
      const newSigner = yield new Promise(
        (resolve, reject) => createAccountFn(
          signerConfigUser,
          serverUrl,
          protocolId,
          secretKey,
          () => {
          },
          // no-op for deprecated callback to update progress percentage
          (err, result) => {
            if (err) {
              reject(err);
            }
            resolve(result);
          }
        )
      );
      return { signer: newSigner, walletId };
    } catch (e) {
      throw new Error(`error creating account of type ${type} with userId ${userId} and walletId ${walletId}`);
    }
  });
}
function preKeygen(ctx, partnerId, pregenIdentifier, pregenIdentifierType, type, secretKey) {
  return __async(this, null, function* () {
    const { walletId, protocolId } = yield ctx.client.createPregenWallet({
      pregenIdentifier,
      pregenIdentifierType,
      type,
      cosmosPrefix: type === "COSMOS" ? ctx.cosmosPrefix : void 0
    });
    if (ctx.offloadMPCComputationURL && !ctx.useDKLS) {
      return {
        signer: (yield keygenRequest(ctx, partnerId, walletId, protocolId)).signer,
        walletId
      };
    }
    const serverUrl = (0, import_core_sdk.getBaseMPCNetworkUrl)(ctx.env, !ctx.disableWebSockets);
    const signerConfigUser = ctx.useDKLS ? configDKLSBase(walletId, "USER", ctx.disableWebSockets) : configCGGMPBase(serverUrl, walletId, "USER");
    const createAccountFn = ctx.useDKLS ? global.dklsCreateAccount : global.createAccountV2;
    try {
      const newSigner = yield new Promise(
        (resolve, reject) => createAccountFn(
          signerConfigUser,
          serverUrl,
          protocolId,
          secretKey,
          () => {
          },
          // no-op for deprecated callback to update progress percentage
          (err, result) => {
            if (err) {
              reject(err);
            }
            resolve(result);
          }
        )
      );
      return { signer: newSigner, walletId };
    } catch (e) {
      throw new Error(`error creating account of type ${type} with walletId ${walletId}`);
    }
  });
}
function signMessage(ctx, share, walletId, userId, message) {
  return __async(this, null, function* () {
    const protocolId = uuid.v4();
    const preSignMessageRes = ctx.client.preSignMessage(userId, walletId, message, null, null, protocolId);
    if (ctx.offloadMPCComputationURL && !ctx.useDKLS) {
      return signMessageRequest(ctx, userId, walletId, protocolId, message, share);
    }
    const serverUrl = (0, import_core_sdk.getBaseMPCNetworkUrl)(ctx.env, !ctx.disableWebSockets);
    const signMessageFn = ctx.useDKLS ? global.dklsSignMessage : global.signMessage;
    const signMessageRes = function() {
      return __async(this, null, function* () {
        try {
          return yield new Promise(
            (resolve, reject) => signMessageFn(share, serverUrl, message, protocolId, (err, result) => {
              if (err) {
                reject(err);
              }
              resolve({ signature: result });
            })
          );
        } catch (e) {
          throw new Error(`error signing for account with userId ${userId} and walletId ${walletId}`);
        }
      });
    }();
    const { pendingTransactionId } = yield preSignMessageRes;
    if (pendingTransactionId) {
      return { pendingTransactionId };
    }
    return yield signMessageRes;
  });
}
function signTransaction(ctx, share, walletId, userId, tx, chainId) {
  return __async(this, null, function* () {
    const protocolId = uuid.v4();
    const signTransactionRes = ctx.client.signTransaction(userId, walletId, { transaction: tx, chainId, protocolId });
    if (ctx.offloadMPCComputationURL && !ctx.useDKLS) {
      return sendTransactionRequest(ctx, userId, walletId, protocolId, tx, share, chainId);
    }
    const serverUrl = (0, import_core_sdk.getBaseMPCNetworkUrl)(ctx.env, !ctx.disableWebSockets);
    const signTransactionFn = ctx.useDKLS ? global.dklsSendTransaction : global.sendTransaction;
    const signTxRes = function() {
      return __async(this, null, function* () {
        try {
          return yield new Promise(
            (resolve, reject) => signTransactionFn(share, serverUrl, tx, chainId, protocolId, (err, result) => {
              if (err) {
                reject(err);
              }
              resolve({ signature: result });
            })
          );
        } catch (e) {
          throw new Error(`error signing transaction for account with userId ${userId} and walletId ${walletId}`);
        }
      });
    }();
    const {
      data: { pendingTransactionId }
    } = yield signTransactionRes;
    if (pendingTransactionId) {
      return { pendingTransactionId };
    }
    return yield signTxRes;
  });
}
function sendTransaction(ctx, share, walletId, userId, tx, chainId) {
  return __async(this, null, function* () {
    const protocolId = uuid.v4();
    const sendTransactionRes = ctx.client.sendTransaction(userId, walletId, { transaction: tx, chainId, protocolId });
    if (ctx.offloadMPCComputationURL && !ctx.useDKLS) {
      return sendTransactionRequest(ctx, userId, walletId, protocolId, tx, share, chainId);
    }
    const serverUrl = (0, import_core_sdk.getBaseMPCNetworkUrl)(ctx.env, !ctx.disableWebSockets);
    const sendTransactionFn = ctx.useDKLS ? global.dklsSendTransaction : global.sendTransaction;
    const sendTxRes = function() {
      return __async(this, null, function* () {
        try {
          return yield new Promise(
            (resolve, reject) => sendTransactionFn(share, serverUrl, tx, chainId, protocolId, (err, result) => {
              if (err) {
                reject(err);
              }
              resolve({ signature: result });
            })
          );
        } catch (e) {
          throw new Error(`error signing transaction to send for account with userId ${userId} and walletId ${walletId}`);
        }
      });
    }();
    const {
      data: { pendingTransactionId }
    } = yield sendTransactionRes;
    if (pendingTransactionId) {
      return { pendingTransactionId };
    }
    return yield sendTxRes;
  });
}
function refresh(ctx, share, walletId, userId) {
  return __async(this, null, function* () {
    const {
      data: { protocolId }
    } = yield ctx.client.refreshKeys(userId, walletId);
    const serverUrl = (0, import_core_sdk.getBaseMPCNetworkUrl)(ctx.env, !ctx.disableWebSockets);
    const refreshFn = ctx.useDKLS ? global.dklsRefresh : global.refresh;
    try {
      return yield new Promise(
        (resolve, reject) => refreshFn(share, serverUrl, protocolId, (err, result) => {
          if (err) {
            reject(err);
          }
          resolve(result);
        })
      );
    } catch (e) {
      throw new Error(`error refreshing keys for account with userId ${userId} and walletId ${walletId}`);
    }
  });
}
function getPrivateKey(ctx, share, walletId, userId) {
  return __async(this, null, function* () {
    const paraShare = yield ctx.client.getParaShare(userId, walletId);
    if (!paraShare) {
      console.error("unable to retrieve Para share");
      return "";
    }
    try {
      return yield new Promise(
        (resolve, reject) => global.getPrivateKey(share, paraShare, (err, result) => {
          if (err) {
            reject(err);
          }
          resolve(result);
        })
      );
    } catch (e) {
      throw new Error(`error getting private key for account with userId ${userId} and walletId ${walletId}`);
    }
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ed25519Keygen,
  ed25519PreKeygen,
  ed25519Sign,
  getPrivateKey,
  keygen,
  preKeygen,
  refresh,
  sendTransaction,
  signMessage,
  signTransaction
});

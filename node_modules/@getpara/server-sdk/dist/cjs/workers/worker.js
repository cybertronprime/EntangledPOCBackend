var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var worker_exports = {};
__export(worker_exports, {
  handleMessage: () => handleMessage,
  requestWasmWithRetries: () => requestWasmWithRetries,
  withRetry: () => withRetry
});
module.exports = __toCommonJS(worker_exports);
var import_axios = __toESM(require("axios"));
var import_core_sdk = require("@getpara/core-sdk");
var walletUtils = __toESM(require("./walletUtils.js"));
let rawWasm;
let wasmLoaded = false;
function requestWasmWithRetries(ctx, retries = 3) {
  return __async(this, null, function* () {
    for (let i = 0; i < retries; i++) {
      try {
        return yield import_axios.default.get(`${(0, import_core_sdk.getPortalBaseURL)(ctx, true, true)}/static/js/main.wasm`, { responseType: "arraybuffer" });
      } catch (e) {
        if (i === retries - 1) {
          throw e;
        }
      }
    }
  });
}
function loadWasm(ctx) {
  return __async(this, null, function* () {
    yield import("../wasm/wasm_exec.js");
    global.WebSocket = require("ws");
    const goWasm = new global.Go();
    if (!rawWasm) {
      rawWasm = (yield requestWasmWithRetries(ctx)).data;
    }
    const wasmBuffer = new Uint8Array(rawWasm);
    const webAssemblySource = yield WebAssembly.instantiate(wasmBuffer, goWasm.importObject);
    goWasm.run(webAssemblySource.instance);
  });
}
function executeMessage(ctx, message) {
  return __async(this, null, function* () {
    const { functionType, params } = message;
    switch (functionType) {
      case "INIT": {
        return {};
      }
      case "KEYGEN": {
        const { userId, secretKey, type = "EVM" } = params;
        return walletUtils.keygen(ctx, userId, type, secretKey);
      }
      case "SIGN_TRANSACTION": {
        const { share, walletId, userId, tx, chainId } = params;
        return withRetry(() => walletUtils.signTransaction(ctx, share, walletId, userId, tx, chainId));
      }
      case "SEND_TRANSACTION": {
        const { share, walletId, userId, tx, chainId } = params;
        return withRetry(() => walletUtils.sendTransaction(ctx, share, walletId, userId, tx, chainId));
      }
      case "SIGN_MESSAGE": {
        const { share, walletId, userId, message: message2 } = params;
        return withRetry(() => walletUtils.signMessage(ctx, share, walletId, userId, message2));
      }
      case "REFRESH": {
        const { share, walletId, userId } = params;
        const signer = yield walletUtils.refresh(ctx, share, walletId, userId);
        return { signer };
      }
      case "PREKEYGEN": {
        const { email, partnerId, secretKey, type = "EVM" } = params;
        let { pregenIdentifier, pregenIdentifierType } = params;
        if (email !== "null" && email !== "undefined" && email !== "" && email != null) {
          pregenIdentifier = email;
          pregenIdentifierType = "EMAIL";
        }
        const keygenRes = yield walletUtils.preKeygen(ctx, partnerId, pregenIdentifier, pregenIdentifierType, type, secretKey);
        return keygenRes;
      }
      case "GET_PRIVATE_KEY": {
        const { share, walletId, userId } = params;
        const privateKey = yield walletUtils.getPrivateKey(ctx, share, walletId, userId);
        return { privateKey };
      }
      case "ED25519_KEYGEN": {
        const { userId } = params;
        return walletUtils.ed25519Keygen(ctx, userId);
      }
      case "ED25519_SIGN": {
        const { share, walletId, userId, base64Bytes } = params;
        return walletUtils.ed25519Sign(ctx, share, userId, walletId, base64Bytes);
      }
      case "ED25519_PREKEYGEN": {
        const { email } = params;
        let { pregenIdentifier, pregenIdentifierType } = params;
        if (email !== "null" && email !== "undefined" && email !== "" && email != null) {
          pregenIdentifier = email;
          pregenIdentifierType = "EMAIL";
        }
        return walletUtils.ed25519PreKeygen(ctx, pregenIdentifier, pregenIdentifierType);
      }
      default: {
        throw new Error(`functionType: ${functionType} not supported`);
      }
    }
  });
}
function withRetry(operation, maxRetries = 2, timeoutMs = 1e4) {
  return __async(this, null, function* () {
    let retries = 0;
    while (true) {
      try {
        const operationPromise = operation();
        const timeoutPromise = new Promise((_, reject) => {
          const timeoutId = setTimeout(() => {
            reject(new Error(`Operation timed out after ${timeoutMs}ms`));
          }, timeoutMs);
          operationPromise.finally(() => clearTimeout(timeoutId));
        });
        return yield Promise.race([operationPromise, timeoutPromise]);
      } catch (error) {
        retries++;
        if (retries > maxRetries) {
          throw error;
        }
        console.warn(`Operation failed (attempt ${retries}/${maxRetries}), retrying...`, error);
      }
    }
  });
}
function handleMessage(e) {
  return __async(this, null, function* () {
    const {
      env,
      apiKey,
      cosmosPrefix = "cosmos",
      offloadMPCComputationURL,
      disableWorkers,
      sessionCookie,
      useDKLS,
      disableWebSockets,
      workId
    } = e.data;
    const ctx = {
      env,
      apiKey,
      client: (0, import_core_sdk.initClient)({ env, version: import_core_sdk.paraVersion, apiKey, retrieveSessionCookie: () => sessionCookie }),
      offloadMPCComputationURL,
      mpcComputationClient: offloadMPCComputationURL ? import_core_sdk.mpcComputationClient.initClient(offloadMPCComputationURL, !!disableWorkers) : void 0,
      useDKLS,
      disableWebSockets: !!disableWebSockets,
      cosmosPrefix
    };
    if (!wasmLoaded && (!ctx.offloadMPCComputationURL || ctx.useDKLS)) {
      yield loadWasm(ctx);
      if (global.initWasm) {
        const serverUrl = (0, import_core_sdk.getBaseMPCNetworkUrl)(ctx.env, !ctx.disableWebSockets);
        yield new Promise(
          (resolve, reject) => global.initWasm((err, result2) => {
            if (err) {
              reject(err);
            }
            resolve(result2);
          }, serverUrl)
        );
      }
      wasmLoaded = true;
    }
    const result = yield executeMessage(ctx, e.data);
    result.workId = workId;
    return result;
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handleMessage,
  requestWasmWithRetries,
  withRetry
});

import "../chunk-FTA5RKYX.js";
import * as uuid from "uuid";
import { waitUntilTrue } from "@getpara/core-sdk";
import { setupWorker } from "../workers/workerWrapper.js";
async function isKeygenComplete(ctx, userId, walletId) {
  const wallets = await ctx.client.getWallets(userId);
  const wallet = wallets.data.wallets.find((w) => w.id === walletId);
  return !!wallet?.address;
}
async function isPreKeygenComplete(ctx, pregenIdentifier, pregenIdentifierType, walletId) {
  const wallets = await ctx.client.getPregenWallets({ [pregenIdentifierType]: [pregenIdentifier] });
  const wallet = wallets.wallets.find((w) => w.id === walletId);
  return !!wallet?.address;
}
function keygen(ctx, userId, type, secretKey, sessionCookie, _emailProps = {}) {
  return new Promise(async (resolve, reject) => {
    const workId = uuid.v4();
    try {
      const worker = await setupWorker(
        ctx,
        async (res) => {
          try {
            await waitUntilTrue(async () => isKeygenComplete(ctx, userId, res.walletId), 15e3, 1e3);
            resolve({
              signer: res.signer,
              walletId: res.walletId,
              recoveryShare: null
            });
          } catch (error) {
            reject(error);
          }
        },
        (error) => {
          reject(error);
        },
        workId,
        {
          userId,
          type,
          functionType: "KEYGEN",
          disableWorkers: ctx.disableWorkers,
          disableWebSockets: ctx.disableWebSockets
        }
      );
      worker.postMessage({
        env: ctx.env,
        apiKey: ctx.apiKey,
        cosmosPrefix: ctx.cosmosPrefix,
        params: { userId, secretKey, type },
        functionType: "KEYGEN",
        offloadMPCComputationURL: ctx.offloadMPCComputationURL,
        disableWorkers: ctx.disableWorkers,
        sessionCookie,
        useDKLS: ctx.useDKLS,
        disableWebSockets: ctx.disableWebSockets,
        wasmOverride: ctx.wasmOverride,
        workId
      });
    } catch (error) {
      reject(error);
    }
  });
}
function preKeygen(ctx, pregenIdentifier, pregenIdentifierType, type, secretKey, _skipDistribute = false, partnerId, sessionCookie) {
  return new Promise(async (resolve, reject) => {
    const workId = uuid.v4();
    try {
      const email = void 0;
      const params = { pregenIdentifier, pregenIdentifierType, secretKey, partnerId, email, type };
      if (pregenIdentifierType === "EMAIL") {
        params.email = pregenIdentifier;
      }
      const worker = await setupWorker(
        ctx,
        async (res) => {
          try {
            await waitUntilTrue(
              async () => isPreKeygenComplete(ctx, pregenIdentifier, pregenIdentifierType, res.walletId),
              15e3,
              1e3
            );
            resolve({
              signer: res.signer,
              walletId: res.walletId,
              recoveryShare: null
            });
          } catch (error) {
            reject(error);
          }
        },
        (error) => {
          reject(error);
        },
        workId,
        {
          ...params,
          secretKey: null,
          functionType: "PREKEYGEN",
          disableWorkers: ctx.disableWorkers,
          disableWebSockets: ctx.disableWebSockets
        }
      );
      worker.postMessage({
        env: ctx.env,
        apiKey: ctx.apiKey,
        cosmosPrefix: ctx.cosmosPrefix,
        params,
        functionType: "PREKEYGEN",
        offloadMPCComputationURL: ctx.offloadMPCComputationURL,
        disableWorkers: ctx.disableWorkers,
        sessionCookie,
        useDKLS: ctx.useDKLS,
        disableWebSockets: ctx.disableWebSockets,
        wasmOverride: ctx.wasmOverride,
        workId
      });
    } catch (error) {
      reject(error);
    }
  });
}
function ed25519Keygen(ctx, userId, sessionCookie, _emailProps = {}) {
  return new Promise(async (resolve, reject) => {
    const workId = uuid.v4();
    try {
      const worker = await setupWorker(
        ctx,
        async (res) => {
          try {
            await waitUntilTrue(async () => isKeygenComplete(ctx, userId, res.walletId), 15e3, 1e3);
            resolve({
              signer: res.signer,
              walletId: res.walletId,
              recoveryShare: null
            });
          } catch (error) {
            reject(error);
          }
        },
        (error) => {
          reject(error);
        },
        workId,
        {
          userId,
          functionType: "ED25519_KEYGEN",
          disableWorkers: ctx.disableWorkers,
          disableWebSockets: ctx.disableWebSockets
        }
      );
      worker.postMessage({
        env: ctx.env,
        apiKey: ctx.apiKey,
        cosmosPrefix: ctx.cosmosPrefix,
        params: { userId },
        functionType: "ED25519_KEYGEN",
        disableWorkers: ctx.disableWorkers,
        sessionCookie,
        disableWebSockets: ctx.disableWebSockets,
        wasmOverride: ctx.wasmOverride,
        workId
      });
    } catch (error) {
      reject(error);
    }
  });
}
function ed25519PreKeygen(ctx, pregenIdentifier, pregenIdentifierType, sessionCookie) {
  return new Promise(async (resolve, reject) => {
    const workId = uuid.v4();
    try {
      const email = void 0;
      const params = { pregenIdentifier, pregenIdentifierType, email };
      if (pregenIdentifierType === "EMAIL") {
        params.email = pregenIdentifier;
      }
      const worker = await setupWorker(
        ctx,
        async (res) => {
          try {
            await waitUntilTrue(
              async () => isPreKeygenComplete(ctx, pregenIdentifier, pregenIdentifierType, res.walletId),
              15e3,
              1e3
            );
            resolve({
              signer: res.signer,
              walletId: res.walletId,
              recoveryShare: null
            });
          } catch (error) {
            reject(error);
          }
        },
        (error) => {
          reject(error);
        },
        workId,
        {
          params,
          functionType: "ED25519_PREKEYGEN",
          disableWorkers: ctx.disableWorkers,
          disableWebSockets: ctx.disableWebSockets
        }
      );
      worker.postMessage({
        env: ctx.env,
        apiKey: ctx.apiKey,
        cosmosPrefix: ctx.cosmosPrefix,
        params,
        functionType: "ED25519_PREKEYGEN",
        disableWorkers: ctx.disableWorkers,
        sessionCookie,
        disableWebSockets: ctx.disableWebSockets,
        wasmOverride: ctx.wasmOverride,
        workId
      });
    } catch (error) {
      reject(error);
    }
  });
}
async function initializeWorker(ctx) {
  return new Promise(async (resolve, reject) => {
    const workId = uuid.v4();
    try {
      const worker = await setupWorker(
        ctx,
        async () => {
          resolve();
        },
        (error) => {
          reject(error);
        },
        workId,
        {
          functionType: "INIT",
          disableWorkers: ctx.disableWorkers,
          disableWebSockets: ctx.disableWebSockets
        }
      );
      worker.postMessage({
        env: ctx.env,
        apiKey: ctx.apiKey,
        functionType: "INIT",
        workId
      });
    } catch (error) {
      reject(error);
    }
  });
}
export {
  ed25519Keygen,
  ed25519PreKeygen,
  initializeWorker,
  isKeygenComplete,
  isPreKeygenComplete,
  keygen,
  preKeygen
};

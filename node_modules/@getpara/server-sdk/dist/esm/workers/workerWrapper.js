import "../chunk-FTA5RKYX.js";
import { Worker } from "worker_threads";
import { getPortalBaseURL } from "@getpara/core-sdk";
const CLEAR_WORKER_TIMEOUT_MS = 1e3 * 90;
let worker;
const resFunctionMap = {};
function removeWorkId(workId, skipClearTimeout) {
  const { timeoutId } = resFunctionMap[workId];
  delete resFunctionMap[workId];
  if (skipClearTimeout) {
    return;
  }
  clearTimeout(timeoutId);
}
function resetWorker() {
  if (worker) {
    worker.terminate();
    worker = void 0;
  }
}
async function setupWorker(ctx, resFunction, errorFunction, workId, errorContext) {
  const timeoutId = setTimeout(() => {
    if (resFunctionMap[workId]) {
      const errorMsg = `worker operation timed out after ${CLEAR_WORKER_TIMEOUT_MS}ms for workId ${workId} and opts ${JSON.stringify(resFunctionMap[workId].errorContext)}`;
      resFunctionMap[workId].errorFn(new Error(errorMsg));
      removeWorkId(workId, true);
    }
  }, CLEAR_WORKER_TIMEOUT_MS);
  resFunctionMap[workId] = {
    fn: resFunction,
    errorFn: errorFunction,
    timeoutId,
    errorContext
  };
  if (!worker || !worker.threadId) {
    const isDeno = typeof globalThis?.Deno !== "undefined";
    const workerFileName = isDeno ? "mpcWorkerServer-esm.js" : "mpcWorkerServer-bundle.js";
    const workerRes = await fetch(`${getPortalBaseURL(ctx)}/static/js/${workerFileName}`);
    worker = new Worker(await workerRes.text(), { eval: true });
    const onmessage = async (message) => {
      const { workId: messageWorkId } = message;
      if (!resFunctionMap[messageWorkId]) {
        console.warn(`received message for unknown workId: ${messageWorkId}`);
        return;
      }
      delete message.workId;
      try {
        await resFunctionMap[messageWorkId].fn(message);
        removeWorkId(messageWorkId);
      } catch (error) {
        console.error(`error in worker message handler for workId ${messageWorkId}:`, error);
        if (resFunctionMap[messageWorkId]) {
          resFunctionMap[messageWorkId].errorFn(error);
          removeWorkId(messageWorkId);
        }
      }
    };
    worker.on("message", onmessage);
    worker.on("error", (err) => {
      console.error("worker error:", err);
      Object.keys(resFunctionMap).forEach((id) => {
        if (resFunctionMap[id]) {
          const errorMsg = `worker error with workId ${id} and opts ${JSON.stringify(resFunctionMap[id].errorContext)}: ${err.message}`;
          resFunctionMap[id].errorFn(new Error(errorMsg));
          removeWorkId(id);
        }
      });
    });
    worker.on("exit", (code) => {
      console.error(`worker stopped with exit code ${code}`);
      Object.keys(resFunctionMap).forEach((id) => {
        if (resFunctionMap[id]) {
          resFunctionMap[id].errorFn(new Error(`worker exited unexpectedly with code ${code}`));
          removeWorkId(id);
        }
      });
      worker = void 0;
    });
  }
  return worker;
}
export {
  resetWorker,
  setupWorker
};

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var client_exports = {};
__export(client_exports, {
  default: () => client_default,
  handleResponseError: () => handleResponseError,
  handleResponseSuccess: () => handleResponseSuccess
});
module.exports = __toCommonJS(client_exports);
var import_axios = __toESM(require("axios"));
var import_utils = require("./utils.js");
var import_consts = require("./consts.js");
var import_error = require("./error.js");
const handleResponseSuccess = (response) => {
  if (response.status === 200) {
    return response;
  }
  throw new import_error.ParaApiError("Invalid status code");
};
const handleResponseError = (error) => {
  var _a, _b, _c;
  if (error === null) throw new import_error.ParaApiError("Error is null");
  if (import_axios.default.isAxiosError(error)) {
    let message = (_b = (_a = error.response) == null ? void 0 : _a.data) != null ? _b : "Unknown error";
    if (error.code === "ERR_NETWORK") {
      message = "Connection error";
    } else if (error.code === "ERR_CANCELED") {
      message = "Connection canceled";
    }
    throw new import_error.ParaApiError(message, error.code, error.response.status, (_c = error.request) == null ? void 0 : _c.responseURL);
  }
  throw new import_error.ParaApiError("Unknown error");
};
class Client {
  constructor({
    userManagementHost,
    apiKey,
    partnerId,
    version,
    opts,
    retrieveSessionCookie,
    persistSessionCookie
  }) {
    this.signUpOrLogIn = (body) => __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/users/init`, body);
      return res.data;
    });
    /**
     * @deprecated
     */
    this.createUser = (body) => __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/users`, body);
      return res.data;
    });
    this.checkUserExists = (auth) => __async(this, null, function* () {
      const res = yield this.baseRequest.get("/users/exists", {
        params: __spreadValues({}, auth)
      });
      return res.data;
    });
    this.verifyTelegram = (authObject) => __async(this, null, function* () {
      return (yield this.baseRequest.post("/users/telegram/v2", {
        authObject
      })).data;
    });
    this.verifyOAuth = () => __async(this, null, function* () {
      const res = yield this.baseRequest.post("/users/verify-oauth");
      return res.data;
    });
    this.loginExternalWallet = (_0) => __async(this, [_0], function* ({
      externalWallet,
      shouldTrackUser
    }) {
      const res = yield this.baseRequest.post(`/users/external-wallets/login/v2`, {
        externalWallet,
        shouldTrackUser
      });
      return res.data;
    });
    this.verifyAccount = (userId, body) => __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/users/${userId}/verify`, body);
      return res.data;
    });
    // POST /users/send-login-code
    this.sendLoginVerificationCode = (auth, isRecovery) => __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/users/send-login-code`, __spreadProps(__spreadValues({}, auth), { isRecovery }));
      return res.data;
    });
    this.getLinkedAccounts = (_0) => __async(this, [_0], function* ({
      userId,
      withMetadata = false
    }) {
      const res = yield this.baseRequest.get(
        `/users/${userId}/linked-accounts`,
        ...withMetadata ? [
          {
            params: { withMetadata }
          }
        ] : []
      );
      return { accounts: (0, import_utils.fromLinkedAccounts)(res.data.accounts) };
    });
    this.linkAccount = (_a) => __async(this, null, function* () {
      var _b = _a, { userId } = _b, opts = __objRest(_b, ["userId"]);
      const res = yield this.baseRequest.post(`/users/${userId}/linked-accounts`, opts);
      return res.data;
    });
    this.verifyLink = (_c) => __async(this, null, function* () {
      var _d = _c, {
        linkedAccountId,
        userId
      } = _d, opts = __objRest(_d, [
        "linkedAccountId",
        "userId"
      ]);
      const res = yield this.baseRequest.post(
        `/users/${userId}/linked-accounts/${linkedAccountId}/verify`,
        opts
      );
      if ("isConflict" in res.data) {
        return res.data;
      }
      const { accounts } = res.data;
      return { accounts: (0, import_utils.fromLinkedAccounts)(accounts) };
    });
    this.unlinkAccount = (_0) => __async(this, [_0], function* ({ linkedAccountId, userId }) {
      const res = yield this.baseRequest.delete(`/users/${userId}/linked-accounts/${linkedAccountId}`);
      return res.data;
    });
    // POST /users/:userId/verify-email
    /**
     * @deprecated
     */
    this.verifyEmail = (userId, body) => __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/users/${userId}/verify-email`, body);
      return res;
    });
    /**
     * @deprecated
     */
    this.verifyPhone = (userId, body) => __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/users/${userId}/verify-identifier`, body);
      return res;
    });
    this.verifyExternalWallet = (userId, body) => __async(this, null, function* () {
      const res = yield this.baseRequest.post(
        `/users/${userId}/external-wallets/verify/v2`,
        body
      );
      return res.data;
    });
    // POST /users/:userId/biometrics/key
    this.addSessionPublicKey = (userId, body) => __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/users/${userId}/biometrics/key`, body);
      return res;
    });
    // GET /users/:userId/biometrics/keys
    this.getSessionPublicKeys = (userId) => __async(this, null, function* () {
      const res = yield this.baseRequest.get(`/users/${userId}/biometrics/keys`);
      return res;
    });
    // GET /biometrics/location-hints
    this.getBiometricLocationHints = (auth) => __async(this, null, function* () {
      const res = yield this.baseRequest.get(`/biometrics/location-hints`, {
        params: auth
      });
      return res.data.hints;
    });
    // GET /users/:userId/biometrics/:biometricId
    this.getSessionPublicKey = (userId, biometricId) => __async(this, null, function* () {
      const res = yield this.baseRequest.get(`/users/${userId}/biometrics/${biometricId}`);
      return res;
    });
    // PATCH /users/:userId/biometrics/:biometricId
    this.patchSessionPublicKey = (partnerId, userId, biometricId, body) => __async(this, null, function* () {
      const res = yield this.baseRequest.patch(`/users/${userId}/biometrics/${biometricId}`, body, {
        headers: {
          [import_consts.PARTNER_ID_HEADER_NAME]: partnerId
        }
      });
      return res;
    });
    // GET /biometrics/challenge?email&publicKey
    this.getWebChallenge = (auth) => __async(this, null, function* () {
      const res = yield this.baseRequest.get("/biometrics/challenge", {
        params: __spreadValues({}, auth || {})
      });
      return res.data;
    });
    // POST /touch
    this.touchSession = (regenerate) => __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/touch?regenerate=${!!regenerate}`);
      return res.data;
    });
    // GET /sessions/:sessionLookupId/origin
    this.sessionOrigin = (sessionLookupId) => __async(this, null, function* () {
      const res = yield this.baseRequest.get(`/sessions/${sessionLookupId}/origin`);
      return res.data;
    });
    // GET /sessions/:sessionLookupId/auth-verified
    this.sessionAuthVerified = (sessionLookupId) => __async(this, null, function* () {
      const res = yield this.baseRequest.get(`/sessions/${sessionLookupId}/auth-verified`);
      return res.data;
    });
    // POST /biometrics/verify
    this.verifyWebChallenge = (partnerId, body) => __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/biometrics/verify`, body, {
        headers: {
          [import_consts.PARTNER_ID_HEADER_NAME]: partnerId
        }
      });
      return res;
    });
    // GET /users/:userId/biometrics/challenge
    this.getSessionChallenge = (userId) => __async(this, null, function* () {
      const res = yield this.baseRequest.get(`/users/${userId}/biometrics/challenge`);
      return res;
    });
    // POST /users/:userId/biometrics/verify
    this.verifySessionChallenge = (userId, body) => __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/users/${userId}/biometrics/verify`, body);
      return res;
    });
    // POST /users/:userId/wallets
    this.createWallet = (userId, body) => __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/users/${userId}/wallets`, body);
      return res.data;
    });
    // POST /wallets/pregen
    this.createPregenWallet = (body) => __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/wallets/pregen`, body);
      return res.data;
    });
    this.getPregenWallets = (pregenIds, isPortal = false, userId) => __async(this, null, function* () {
      const res = yield this.baseRequest.get("/wallets/pregen", {
        params: { ids: pregenIds, expand: isPortal, userId }
      });
      return res.data;
    });
    this.claimPregenWallets = (body) => __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/wallets/pregen/claim`, body);
      return res.data;
    });
    // POST /users/:userId/wallets/:walletId/transactions/send
    this.sendTransaction = (userId, walletId, body) => __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/users/${userId}/wallets/${walletId}/transactions/send`, body);
      return res;
    });
    // functionality changed to only sign transactions and not send them
    // POST /users/:userId/wallets/:walletId/transactions/sign
    this.signTransaction = (userId, walletId, body) => __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/users/${userId}/wallets/${walletId}/transactions/sign`, body);
      return res;
    });
    // POST /users/:userId/wallets/:walletId/refresh
    this.refreshKeys = (userId, walletId, oldPartnerId, newPartnerId, keyShareProtocolId) => __async(this, null, function* () {
      const body = { oldPartnerId, newPartnerId, keyShareProtocolId };
      const res = yield this.baseRequest.post(`/users/${userId}/wallets/${walletId}/refresh`, body);
      return res;
    });
    // PATCH /wallets/pregen/:walletId
    this.updatePregenWallet = (walletId, body) => __async(this, null, function* () {
      const res = yield this.baseRequest.patch(`/wallets/pregen/${walletId}`, body);
      return res.data;
    });
    // GET /users/:userId/wallets
    this.getWallets = (userId, includePartnerData) => __async(this, null, function* () {
      const res = yield this.baseRequest.get(
        `/users/${userId}/wallets${includePartnerData ? `?includePartnerData=${encodeURIComponent(includePartnerData)}` : ""}`
      );
      return res;
    });
    // GET /users/:userId/all-wallets
    this.getAllWallets = (userId) => __async(this, null, function* () {
      const res = yield this.baseRequest.get(`/users/${userId}/all-wallets`);
      return res;
    });
    // POST /users/:userId/wallets/set
    this.setCurrentWalletIds = (userId, walletIds, needsWallet = false, sessionLookupId, newDeviceSessionLookupId) => __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/users/${userId}/wallets/set`, {
        walletIds,
        needsWallet,
        sessionLookupId,
        newDeviceSessionLookupId
      });
      return res;
    });
    // POST /login
    this.login = (props) => __async(this, null, function* () {
      const body = props;
      const res = yield this.baseRequest.post("/login", body);
      return res;
    });
    // POST /login
    this.verifyLogin = (verificationCode) => __async(this, null, function* () {
      const body = { verificationCode };
      const res = yield this.baseRequest.post("/login/verify-email", body);
      return res;
    });
    // GET /logout
    this.logout = () => __async(this, null, function* () {
      const res = yield this.baseRequest.get("/logout");
      return res;
    });
    // POST /recovery/verification
    this.recoveryVerification = (email, verificationCode) => __async(this, null, function* () {
      const body = { email, verificationCode };
      const res = yield this.baseRequest.post("/recovery/verification", body);
      return res;
    });
    // POST /recovery
    this.recoveryInit = (email) => __async(this, null, function* () {
      const body = { email };
      const res = yield this.baseRequest.post("/recovery", body);
      return res;
    });
    this.preSignMessage = (userId, walletId, message, scheme, cosmosSignDoc, protocolId) => __async(this, null, function* () {
      const body = { message, scheme, cosmosSignDoc, protocolId };
      const res = yield this.baseRequest.post(`/users/${userId}/wallets/${walletId}/messages/sign`, body);
      return res.data;
    });
    //DELETE /users/:userId
    this.deleteSelf = (userId) => __async(this, null, function* () {
      const res = yield this.baseRequest.delete(`/users/${userId}`);
      return res;
    });
    // GET /users/:userId/wallets/:walletId/capsule-share
    this.getParaShare = (userId, walletId) => __async(this, null, function* () {
      const res = yield this.baseRequest.get(`/users/${userId}/wallets/${walletId}/capsule-share`);
      return res.data.share;
    });
    // GET /users/:userId/wallets/:walletId/download-backup-kit
    this.getBackupKit = (userId, walletId) => __async(this, null, function* () {
      const res = yield this.baseRequest.get(`/users/${userId}/wallets/${walletId}/download-backup-kit`, {
        responseType: "blob"
      });
      return res;
    });
    // PATCH /users/:userId/biometrics/:biometricId
    this.patchSessionPassword = (partnerId, userId, passwordId, body) => __async(this, null, function* () {
      const res = yield this.baseRequest.patch(`/users/${userId}/passwords/${passwordId}`, body, {
        headers: {
          [import_consts.PARTNER_ID_HEADER_NAME]: partnerId
        }
      });
      return res;
    });
    // GET /users/:userId/wallets/:walletId/balance
    this.getWalletBalance = (_0) => __async(this, [_0], function* ({ walletId, rpcUrl }) {
      const res = yield this.baseRequest.get(`/wallets/${walletId}/balance`, {
        params: {
          rpcUrl
        }
      });
      return res.data;
    });
    this.issueJwt = (..._0) => __async(this, [..._0], function* ({ keyIndex = 0 } = {}) {
      const res = yield this.baseRequest.post(`/auth/jwt`, { keyIndex });
      return res.data;
    });
    this.trackError = (opts) => __async(this, null, function* () {
      yield this.baseRequest.post("/errors/sdk", opts);
    });
    this.trackReactSdkAnalytics = (opts) => __async(this, null, function* () {
      yield this.baseRequest.post("/partners/analytics/react-sdk", opts);
    });
    const headers = __spreadValues(__spreadValues({}, apiKey && { [import_consts.API_KEY_HEADER_NAME]: apiKey }), partnerId && { [import_consts.PARTNER_ID_HEADER_NAME]: partnerId });
    const axiosConfig = {
      baseURL: userManagementHost,
      withCredentials: true,
      headers
    };
    if (retrieveSessionCookie) {
      const defaultTransformRequest = Array.isArray(import_axios.default.defaults.transformRequest) ? import_axios.default.defaults.transformRequest : [import_axios.default.defaults.transformRequest];
      axiosConfig.transformRequest = [
        function(data, headers2) {
          const currentSessionCookie = retrieveSessionCookie();
          if (currentSessionCookie) {
            headers2[import_consts.SESSION_COOKIE_HEADER_NAME] = currentSessionCookie;
          }
          if (version) {
            headers2[import_consts.VERSION_HEADER_NAME] = version;
          }
          return data;
        },
        ...defaultTransformRequest
      ];
    }
    if (persistSessionCookie) {
      const defaultTransformResponse = Array.isArray(import_axios.default.defaults.transformResponse) ? import_axios.default.defaults.transformResponse : [import_axios.default.defaults.transformResponse];
      axiosConfig.transformResponse = [
        ...defaultTransformResponse,
        function(data, headers2, _status) {
          if (headers2 == null ? void 0 : headers2[import_consts.SESSION_COOKIE_HEADER_NAME]) {
            persistSessionCookie(headers2[import_consts.SESSION_COOKIE_HEADER_NAME]);
          }
          return data;
        }
      ];
    }
    this.baseRequest = import_axios.default.create(axiosConfig);
    if (opts == null ? void 0 : opts.useFetchAdapter) {
      import_axios.default.defaults.adapter = function(config) {
        return fetch(config.baseURL + config.url.substring(1), {
          method: config.method,
          headers: config.headers,
          body: config.data,
          credentials: config.withCredentials ? "include" : void 0
        }).then(
          (response) => response.text().then((text) => ({
            data: text,
            status: response.status,
            statusText: response.statusText,
            headers: response.headers,
            config,
            request: fetch
          }))
        ).catch(function(reason) {
          throw reason;
        });
      };
    }
    this.baseRequest.interceptors.response.use(handleResponseSuccess, handleResponseError);
  }
  // DEPRECATED: use uploadUserKeyShares instead
  // POST /users/:userId/wallets/:walletId/key-shares
  uploadKeyshares(userId, walletId, encryptedKeyshares) {
    return __async(this, null, function* () {
      const body = { keyShares: encryptedKeyshares };
      const res = yield this.baseRequest.post(`/users/${userId}/wallets/${walletId}/key-shares`, body);
      return res;
    });
  }
  // POST /users/:userId/key-shares
  uploadUserKeyShares(userId, encryptedKeyshares) {
    return __async(this, null, function* () {
      const body = { keyShares: encryptedKeyshares };
      const res = yield this.baseRequest.post(`/users/${userId}/key-shares`, body);
      return res;
    });
  }
  // GET /users/:userId/wallets/:walletId/key-shares
  getKeyshare(userId, walletId, type, encryptor) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.get(
        `/users/${userId}/wallets/${walletId}/key-shares?type=${type}${encryptor ? `&encryptor=${encryptor}` : ""}`
      );
      return res;
    });
  }
  // GET /users/:userId/biometrics/key-shares
  getBiometricKeyshares(userId, biometricPublicKey, getAll) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.get(
        `/users/${userId}/biometrics/key-shares?publicKey=${biometricPublicKey}&all=${!!getAll}`
      );
      return res;
    });
  }
  // GET /users/:userId/key-shares
  getPasswordKeyshares(userId, passwordId, getAll) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.get(
        `/users/${userId}/passwords/key-shares?passwordId=${passwordId}&all=${!!getAll}`
      );
      return res;
    });
  }
  // POST '/users/:userId/temporary-shares',
  uploadTransmissionKeyshares(userId, shares) {
    return __async(this, null, function* () {
      const body = { shares };
      const res = yield this.baseRequest.post(`/users/${userId}/temporary-shares`, body);
      return res;
    });
  }
  // GET /users/:userId/temporary-shares returns { temporaryShares: { userId: string, walletId: string, encryptedShare: string, encryptedKey?: string }[] }
  getTransmissionKeyshares(userId, sessionLookupId) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.get(`/users/${userId}/temporary-shares?sessionLookupId=${sessionLookupId}`);
      return res;
    });
  }
  // POST '/users/:userId/resend-verification-code
  resendVerificationCode(_e) {
    return __async(this, null, function* () {
      var _f = _e, { userId } = _f, rest = __objRest(_f, ["userId"]);
      const res = yield this.baseRequest.post(`/users/${userId}/resend-verification-code`, rest);
      return res;
    });
  }
  // POST '/users/:userId/resend-verification-code-by-phone
  resendVerificationCodeByPhone(_g) {
    return __async(this, null, function* () {
      var _h = _g, { userId } = _h, rest = __objRest(_h, ["userId"]);
      const res = yield this.baseRequest.post(`/users/${userId}/resend-verification-code-by-phone`, rest);
      return res;
    });
  }
  // POST recovery/cancel
  cancelRecoveryAttempt(email) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/recovery/cancel`, { email });
      return res;
    });
  }
  // GET '/2fa/users/:userId/check-status'
  check2FAStatus(userId) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.get(`/2fa/users/${userId}/check-status`);
      return res;
    });
  }
  // POST '/2fa/users/:userId/enable'
  enable2FA(userId, verificationCode) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/2fa/users/${userId}/enable`, { verificationCode });
      return res;
    });
  }
  setup2FA(userId) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/2fa/users/${userId}/setup`);
      return res.data;
    });
  }
  // POST /recovery/init
  initializeRecovery(email) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/recovery/init`, { email });
      return res;
    });
  }
  // POST /auth/farcaster/init
  initializeFarcasterLogin() {
    return __async(this, arguments, function* ({ appScheme } = {}) {
      const res = yield this.baseRequest.post(`/auth/farcaster/init`, { appScheme });
      return res.data;
    });
  }
  getFarcasterAuthStatus() {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/auth/farcaster/status/v2`);
      return res.data;
    });
  }
  // POST /recovery/init
  initializeRecoveryForPhone(phone, countryCode) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/recovery/init`, { phone, countryCode });
      return res;
    });
  }
  // POST /recovery/users/:userId/wallets/:walletId/finish
  finalizeRecovery(userId, walletId) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/recovery/users/${userId}/wallets/${walletId}/finish`);
      return res;
    });
  }
  // GET /recovery/users/:userId/wallets/:walletId/key-shares
  recoverUserShares(userId, walletId) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.get(`/recovery/users/${userId}/wallets/${walletId}/key-shares?type=USER&encryptor=RECOVERY`);
      return res;
    });
  }
  // POST /recovery/verify-email
  verifyEmailForRecovery(email, verificationCode) {
    return __async(this, null, function* () {
      const body = { email, verificationCode };
      const res = yield this.baseRequest.post(`/recovery/verify-email`, body);
      return res;
    });
  }
  // POST /recovery/verify-identifier
  verifyPhoneForRecovery(phone, countryCode, verificationCode) {
    return __async(this, null, function* () {
      const body = { phone, countryCode, verificationCode };
      const res = yield this.baseRequest.post(`/recovery/verify-identifier`, body);
      return res;
    });
  }
  verify2FA(auth, verificationCode) {
    return __async(this, null, function* () {
      const body = __spreadProps(__spreadValues({}, auth), { verificationCode });
      const res = yield this.baseRequest.post("/2fa/verify", body);
      return res.data;
    });
  }
  // POST /2fa/phone/verify
  /**
   * @deprecated
   */
  verify2FAForPhone(phone, verificationCode) {
    return __async(this, null, function* () {
      const body = { phone, verificationCode };
      const res = yield this.baseRequest.post("/2fa/verify", body);
      return res;
    });
  }
  tempTrasmissionInit(message, userId) {
    return __async(this, null, function* () {
      const body = { message, userId };
      const res = yield this.baseRequest.post("/temporary-transmissions", body);
      return res;
    });
  }
  tempTrasmission(id) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.get(`/temporary-transmissions/${id}`);
      return res;
    });
  }
  getPartner(partnerId) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.get(`/partners/${partnerId}`);
      return res;
    });
  }
  acceptScopes(userId, walletId, body) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/users/${userId}/wallets/${walletId}/scopes/accept`, body);
      return res;
    });
  }
  getPendingTransaction(userId, pendingTransactionId) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.get(`/users/${userId}/pending-transactions/${pendingTransactionId}`);
      return res;
    });
  }
  acceptPendingTransaction(userId, pendingTransactionId) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/users/${userId}/pending-transactions/${pendingTransactionId}/accept`);
      return res;
    });
  }
  getOnRampConfig() {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.get(`/on-ramp-config`);
      return res.data;
    });
  }
  createOnRampPurchase(_i) {
    return __async(this, null, function* () {
      var _j = _i, {
        userId,
        params
      } = _j, walletParams = __objRest(_j, [
        "userId",
        "params"
      ]);
      const [key, identifier] = (0, import_utils.extractWalletRef)(walletParams);
      const walletString = key === "walletId" ? `wallets/${identifier}` : `external-wallets/${identifier}`;
      const res = yield this.baseRequest.post(`/users/${userId}/${walletString}/purchases`, params);
      return res.data;
    });
  }
  updateOnRampPurchase(_k) {
    return __async(this, null, function* () {
      var _l = _k, {
        userId,
        purchaseId,
        updates
      } = _l, params = __objRest(_l, [
        "userId",
        "purchaseId",
        "updates"
      ]);
      const [key, identifier] = (0, import_utils.extractWalletRef)(params);
      const walletString = key === "walletId" ? `wallets/${identifier}` : `external-wallets/${identifier}`;
      const res = yield this.baseRequest.patch(
        `/users/${userId}/${walletString}/purchases/${purchaseId}`,
        updates
      );
      return res.data;
    });
  }
  getOnRampPurchase(_m) {
    return __async(this, null, function* () {
      var _n = _m, {
        userId,
        purchaseId
      } = _n, params = __objRest(_n, [
        "userId",
        "purchaseId"
      ]);
      const [key, identifier] = (0, import_utils.extractWalletRef)(params);
      const walletString = key === "walletId" ? `wallets/${identifier}` : `external-wallets/${identifier}`;
      const res = yield this.baseRequest.get(`/users/${userId}/${walletString}/purchases/${purchaseId}`);
      return res;
    });
  }
  signMoonPayUrl(_0, _1) {
    return __async(this, arguments, function* (userId, {
      url,
      type,
      cosmosPrefix,
      testMode,
      walletId,
      externalWalletAddress
    }) {
      const walletString = walletId ? `wallets/${walletId}` : `external-wallets/${externalWalletAddress}`;
      const res = yield this.baseRequest.post(`/users/${userId}/${walletString}/moonpay-sign`, {
        url,
        type,
        cosmosPrefix,
        testMode
      });
      return res;
    });
  }
  generateOffRampTx(_0, _1) {
    return __async(this, arguments, function* (userId, {
      provider,
      chainId,
      contractAddress,
      testMode,
      walletId,
      walletType,
      destinationAddress,
      sourceAddress,
      assetQuantity
    }) {
      const res = yield this.baseRequest.post(`/users/${userId}/wallets/${walletId}/offramp-generate`, {
        provider,
        testMode,
        chainId,
        contractAddress,
        walletId,
        walletType,
        destinationAddress,
        sourceAddress,
        assetQuantity
      });
      return res.data;
    });
  }
  sendOffRampTx(_0, _1) {
    return __async(this, arguments, function* (userId, {
      tx,
      signature,
      sourceAddress,
      network,
      walletId,
      walletType
    }) {
      const res = yield this.baseRequest.post(`/users/${userId}/wallets/${walletId}/offramp-send`, {
        tx,
        signature,
        sourceAddress,
        network,
        walletType
      });
      return res.data;
    });
  }
  distributeParaShare(_o) {
    return __async(this, null, function* () {
      var _p = _o, {
        userId,
        walletId
      } = _p, rest = __objRest(_p, [
        "userId",
        "walletId"
      ]);
      const body = rest;
      const res = yield this.baseRequest.post(`/users/${userId}/wallets/${walletId}/capsule-share/distribute`, body);
      return res;
    });
  }
  keepSessionAlive(userId) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/users/${userId}/session/keep-alive`);
      return res.data;
    });
  }
  persistRecoveryPublicKeys(userId, publicKeys) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/users/${userId}/recovery-public-keys`, { publicKeys });
      return res.data;
    });
  }
  getRecoveryPublicKeys(userId) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.get(`/users/${userId}/recovery-public-keys`);
      return res.data;
    });
  }
  uploadEncryptedWalletPrivateKey(userId, encryptedWalletPrivateKey, encryptionKeyHash, biometricPublicKey, passwordId) {
    return __async(this, null, function* () {
      const body = { encryptedWalletPrivateKey, encryptionKeyHash, biometricPublicKey, passwordId };
      const res = yield this.baseRequest.post(`/users/${userId}/encrypted-wallet-private-keys`, body);
      return res.data;
    });
  }
  getEncryptedWalletPrivateKeys(userId, encryptionKeyHash) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.get(`/users/${userId}/encrypted-wallet-private-keys/${encryptionKeyHash}`);
      return res.data;
    });
  }
  getConversionRate(chainId, symbol, currency) {
    return __async(this, null, function* () {
      const params = { symbol, currency };
      const res = yield this.baseRequest.get(`/chains/${chainId}/conversion-rate`, { params });
      return res.data;
    });
  }
  getGasEstimate(chainId, totalGasPrice) {
    return __async(this, null, function* () {
      const params = { totalGasPrice };
      const res = yield this.baseRequest.get(`/chains/${chainId}/gas-estimate`, { params });
      return res.data;
    });
  }
  getGasOracle(chainId) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.get(`/chains/${chainId}/gas-oracle`);
      return res.data;
    });
  }
  // GET /users/:userId/wallets/:walletId/refresh-done
  isRefreshDone(userId, walletId, partnerId, protocolId) {
    return __async(this, null, function* () {
      const query = new URLSearchParams(__spreadValues(__spreadValues({}, partnerId ? { partnerId } : {}), protocolId ? { protocolId } : {})).toString();
      const res = yield this.baseRequest.get(`/users/${userId}/wallets/${walletId}/refresh-done?${query}`);
      return res.data;
    });
  }
  deletePendingTransaction(userId, pendingTransactionId) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.delete(`/users/${userId}/pending-transactions/${pendingTransactionId}`);
      return res.data;
    });
  }
  // POST /users/:userId/passwords/key
  addSessionPasswordPublicKey(userId, body) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/users/${userId}/passwords/key`, body);
      return res;
    });
  }
  getSupportedAuthMethods(auth) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.get("/users/supported-auth-methods", {
        params: __spreadValues({}, auth)
      });
      return res.data;
    });
  }
  getSupportedAuthMethodsV2(auth) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.get(
        "/users/supported-auth-methods/v2",
        {
          params: __spreadValues({}, auth)
        }
      );
      return res.data;
    });
  }
  getPasswords(auth) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.get("/users/passwords", {
        params: __spreadValues({}, auth)
      });
      return res.data.passwords;
    });
  }
  // POST /passwords/verify
  verifyPasswordChallenge(partnerId, body) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.post(`/passwords/verify`, body, {
        headers: {
          [import_consts.PARTNER_ID_HEADER_NAME]: partnerId
        }
      });
      return res;
    });
  }
  getEncryptedWalletPrivateKey(passwordId, sessionLookupId) {
    return __async(this, null, function* () {
      const query = new URLSearchParams({ passwordId, sessionLookupId }).toString();
      const res = yield this.baseRequest.get(`/encrypted-wallet-private-keys?${query}`);
      return res;
    });
  }
  // GET /users/:userId
  getUser(userId) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.get(`/users/${userId}`);
      return res.data;
    });
  }
  // GET /users/:userId/accounts
  getAccountMetadata(userId, partnerId) {
    return __async(this, null, function* () {
      const res = yield this.baseRequest.get(`/users/${userId}/oauth/accounts`, {
        params: { partnerId }
      });
      return {
        accountMetadata: (0, import_utils.fromAccountMetadata)(res.data.accountMetadata)
      };
    });
  }
}
var client_default = Client;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handleResponseError,
  handleResponseSuccess
});

import { AxiosResponse } from 'axios';
import { AccountMetadata, Auth, AuthIdentifier, AuthMethod, BackupKitEmailProps, BiometricLocationHint, Chain, CurrentWalletIds, EncryptedKeyShare, EncryptorType, ExternalWalletInfo, LoginExternalWalletResponse, KeyShareType, Network, OnRampAsset, OnRampConfig, OnRampProvider, OnRampPurchase, OnRampPurchaseCreateParams, OnRampPurchaseUpdateParams, PasswordStatus, PregenIds, PrimaryAuth, PublicKeyStatus, PublicKeyType, ServerAuthStateSignup, SessionInfo, Setup2faResponse, SignUpOrLogInResponse, TelegramAuthResponse, TPregenIdentifierType, VerificationEmailProps, VerifiedAuth, VerifyFarcasterResponse, VerifyTelegramResponse, VerifyThirdPartyAuth, WalletEntity, WalletParams, TWalletScheme, TWalletType, VerifyExternalWalletParams, IssueJwtParams, IssueJwtResponse, LinkAccountParams, LinkedAccounts, ResendVerificationCodeParams, LegacyAuthMethod, PrimaryAuthInfo, ServerAuthStateLogin } from './types/index.js';
interface ConfigOpts {
    useFetchAdapter?: boolean;
}
type ClientConfig = {
    userManagementHost: string;
    version?: string;
    partnerId?: string;
    apiKey: string;
    opts?: ConfigOpts;
    retrieveSessionCookie?: () => string | undefined;
    persistSessionCookie?: (cookie: string) => void;
};
interface createUserIdRes {
    protocolId: string;
    userId: string;
}
interface verifyBody {
    verificationCode: string;
    sessionLookupId?: string;
}
interface getWebChallengeRes {
    challenge: string;
    allowedPublicKeys?: string[];
}
interface sessionPublicKeyBody {
    publicKey?: string;
    sigDerivedPublicKey?: string;
    status?: PublicKeyStatus;
    type?: PublicKeyType;
    cosePublicKey?: string;
    clientDataJSON?: string;
    aaguid?: string;
}
interface WebSignature {
    clientDataJSON: string;
    authenticatorData: string;
    signature: string;
}
interface MobileSignature {
    r: string;
    s: string;
    recoveryParam: number;
}
type verifyWebChallengeBody = {
    sessionLookupId?: string;
    signature: WebSignature;
    publicKey: string;
    newDeviceSessionLookupId?: string;
};
type verifyPasswordChallengeBody = {
    sessionLookupId?: string;
    signature: string;
    publicKey: string;
    newDeviceSessionLookupId?: string;
};
interface verifySessionChallengeBody {
    signature: MobileSignature | WebSignature;
    publicKey?: string;
}
interface GetWalletsRes {
    wallets: WalletEntity[];
}
interface PasswordEntity {
    id: string;
    userId: string;
    status: PasswordStatus;
    sigDerivedPublicKey: string;
    salt: string;
    isPIN?: boolean;
}
interface createWalletBody {
    useTwoSigners?: boolean;
    scheme: TWalletScheme;
    type: TWalletType;
    cosmosPrefix?: string;
}
interface updatePregenWalletBody {
    pregenIdentifier: string;
    pregenIdentifierType: TPregenIdentifierType;
}
interface createWalletRes {
    protocolId: string;
    walletId: string;
}
interface GetWalletBalanceRes {
    balance: string;
}
interface createPregenWalletBody {
    pregenIdentifier: string;
    pregenIdentifierType: TPregenIdentifierType;
    scheme?: TWalletScheme;
    type: TWalletType;
    cosmosPrefix?: string;
}
interface claimPreGenWalletsBody {
    userId: string;
    walletIds: string[];
}
interface signTransactionBody {
    transaction: string;
    chainId: string;
    protocolId?: string;
}
interface sendTransactionBody {
    transaction: string;
    chain?: Chain;
    chainId?: string;
    protocolId?: string;
}
interface AcceptScopesBody {
    scopeIds: string[];
    partnerId: string;
}
interface sessionPasswordBody {
    status?: PasswordStatus;
    sigDerivedPublicKey?: string;
    salt?: string;
    encryptedWalletPrivateKey?: string;
    encryptionKeyHash?: string;
    isPIN?: boolean;
}
interface EncryptedWalletPrivateKey {
    id: string;
    userId: string;
    encryptedPrivateKey: string;
    encryptionKeyHash: string;
    biometricPublicKey?: string;
    passwordId?: string;
}
export type SDKType = 'WEB' | 'SERVER' | 'BRIDGE' | 'REACT_NATIVE';
export type VerifyTelegramRes = {
    isValid: true;
    userId: string;
    telegramUserId: string;
    isNewUser: boolean;
    biometricHints?: BiometricLocationHint[];
    supportedAuthMethods: AuthMethod[];
} | {
    isValid: false;
};
export declare const handleResponseSuccess: (response: AxiosResponse<any, any>) => AxiosResponse<any, any>;
export declare const handleResponseError: (error: any) => never;
declare class Client {
    private baseRequest;
    constructor({ userManagementHost, apiKey, partnerId, version, opts, retrieveSessionCookie, persistSessionCookie, }: ClientConfig);
    signUpOrLogIn: (body: VerifiedAuth & VerificationEmailProps) => Promise<SignUpOrLogInResponse>;
    /**
     * @deprecated
     */
    createUser: (body: VerifiedAuth & VerificationEmailProps) => Promise<createUserIdRes>;
    checkUserExists: (auth: VerifiedAuth) => Promise<any>;
    verifyTelegram: (authObject: TelegramAuthResponse) => Promise<VerifyTelegramResponse>;
    verifyOAuth: () => Promise<VerifyThirdPartyAuth | null>;
    loginExternalWallet: ({ externalWallet, shouldTrackUser, }: {
        externalWallet: ExternalWalletInfo;
        shouldTrackUser?: boolean;
    }) => Promise<LoginExternalWalletResponse>;
    verifyAccount: (userId: string, body: verifyBody) => Promise<ServerAuthStateSignup | ServerAuthStateLogin>;
    sendLoginVerificationCode: (auth: PrimaryAuthInfo, isRecovery?: boolean) => Promise<{
        userId: string;
    }>;
    getLinkedAccounts: ({ userId, withMetadata, }: {
        userId: string;
        withMetadata?: boolean;
    }) => Promise<{
        accounts: LinkedAccounts;
    }>;
    linkAccount: ({ userId, ...opts }: LinkAccountParams & {
        userId: string;
    }) => Promise<{
        linkedAccountId: string;
        signatureVerificationMessage?: string;
    } | {
        isConflict: true;
    }>;
    verifyLink: ({ linkedAccountId, userId, ...opts }: {
        linkedAccountId: string;
        userId: string;
        telegramAuthResponse?: TelegramAuthResponse;
        verificationCode?: string;
    } & Partial<VerifyExternalWalletParams>) => Promise<{
        accounts: LinkedAccounts;
    } | {
        isConflict: true;
    }>;
    unlinkAccount: ({ linkedAccountId, userId }: {
        linkedAccountId: string;
        userId: string;
    }) => Promise<LinkedAccounts>;
    /**
     * @deprecated
     */
    verifyEmail: (userId: string, body: verifyBody) => Promise<any>;
    /**
     * @deprecated
     */
    verifyPhone: (userId: string, body: verifyBody) => Promise<any>;
    verifyExternalWallet: (userId: string, body: VerifyExternalWalletParams) => Promise<ServerAuthStateSignup | ServerAuthStateLogin>;
    addSessionPublicKey: (userId: string, body: sessionPublicKeyBody) => Promise<any>;
    getSessionPublicKeys: (userId: string) => Promise<any>;
    getBiometricLocationHints: (auth: PrimaryAuth) => Promise<BiometricLocationHint[]>;
    getSessionPublicKey: (userId: string, biometricId: string) => Promise<any>;
    patchSessionPublicKey: (partnerId: string, userId: string, biometricId: string, body: sessionPublicKeyBody) => Promise<any>;
    getWebChallenge: (auth?: PrimaryAuth | Auth<"userId">) => Promise<getWebChallengeRes>;
    touchSession: (regenerate?: boolean) => Promise<SessionInfo>;
    sessionOrigin: (sessionLookupId: string) => Promise<{
        origin?: string;
    }>;
    sessionAuthVerified: (sessionLookupId: string) => Promise<{
        authVerified?: boolean;
    }>;
    verifyWebChallenge: (partnerId: string, body: verifyWebChallengeBody) => Promise<any>;
    getSessionChallenge: (userId: string) => Promise<any>;
    verifySessionChallenge: (userId: string, body: verifySessionChallengeBody) => Promise<any>;
    createWallet: (userId: string, body?: createWalletBody) => Promise<createWalletRes>;
    createPregenWallet: (body?: createPregenWalletBody) => Promise<createWalletRes>;
    getPregenWallets: (pregenIds: PregenIds, isPortal?: boolean, userId?: string) => Promise<{
        wallets: WalletEntity[];
    }>;
    claimPregenWallets: (body?: claimPreGenWalletsBody) => Promise<{
        walletIds: string[];
    }>;
    sendTransaction: (userId: string, walletId: string, body: sendTransactionBody) => Promise<any>;
    signTransaction: (userId: string, walletId: string, body: signTransactionBody) => Promise<any>;
    refreshKeys: (userId: string, walletId: string, oldPartnerId?: string, newPartnerId?: string, keyShareProtocolId?: string) => Promise<any>;
    updatePregenWallet: (walletId: string, body: updatePregenWalletBody) => Promise<any>;
    getWallets: (userId: string, includePartnerData?: boolean) => Promise<AxiosResponse<GetWalletsRes, any>>;
    getAllWallets: (userId: string) => Promise<AxiosResponse<GetWalletsRes, any>>;
    setCurrentWalletIds: (userId: string, walletIds: CurrentWalletIds, needsWallet?: boolean, sessionLookupId?: string, newDeviceSessionLookupId?: string) => Promise<any>;
    login: (props: {
        email: string;
    } & VerificationEmailProps) => Promise<any>;
    verifyLogin: (verificationCode: string) => Promise<any>;
    logout: () => Promise<any>;
    recoveryVerification: (email: string, verificationCode: string) => Promise<any>;
    recoveryInit: (email: string) => Promise<any>;
    preSignMessage: (userId: string, walletId: string, message: string, scheme?: TWalletScheme, cosmosSignDoc?: string, protocolId?: string) => Promise<any>;
    deleteSelf: (userId: string) => Promise<any>;
    uploadKeyshares(userId: string, walletId: string, encryptedKeyshares: EncryptedKeyShare[]): Promise<any>;
    uploadUserKeyShares(userId: string, encryptedKeyshares: (EncryptedKeyShare & {
        walletId: string;
    })[]): Promise<any>;
    getKeyshare(userId: string, walletId: string, type: KeyShareType, encryptor?: EncryptorType): Promise<any>;
    getBiometricKeyshares(userId: string, biometricPublicKey: string, getAll?: boolean): Promise<any>;
    getPasswordKeyshares(userId: string, passwordId: string, getAll?: boolean): Promise<any>;
    uploadTransmissionKeyshares(userId: string, shares: {
        walletId: string;
        encryptedShare: string;
        encryptedKey?: string;
        sessionLookupId: string;
    }[]): Promise<any>;
    getTransmissionKeyshares(userId: string, sessionLookupId: string): Promise<any>;
    getParaShare: (userId: string, walletId: string) => Promise<string>;
    getBackupKit: (userId: string, walletId: string) => Promise<any>;
    resendVerificationCode({ userId, ...rest }: ResendVerificationCodeParams): Promise<AxiosResponse<any, any>>;
    resendVerificationCodeByPhone({ userId, ...rest }: {
        userId: string;
    } & VerificationEmailProps): Promise<AxiosResponse<any, any>>;
    cancelRecoveryAttempt(email: string): Promise<AxiosResponse<any, any>>;
    check2FAStatus(userId: string): Promise<AxiosResponse<any, any>>;
    enable2FA(userId: string, verificationCode: string): Promise<AxiosResponse<any, any>>;
    setup2FA(userId: string): Promise<Setup2faResponse>;
    initializeRecovery(email: string): Promise<AxiosResponse<any, any>>;
    initializeFarcasterLogin({ appScheme }?: {
        appScheme?: string;
    }): Promise<any>;
    getFarcasterAuthStatus(): Promise<VerifyFarcasterResponse>;
    initializeRecoveryForPhone(phone: string, countryCode: string): Promise<AxiosResponse<any, any>>;
    finalizeRecovery(userId: string, walletId: string): Promise<AxiosResponse<any, any>>;
    recoverUserShares(userId: string, walletId: string): Promise<AxiosResponse<{
        keyShare: {
            encryptedShare: string;
            encryptedKey?: string;
            type: string;
            walletId: string;
        };
        keyShares: {
            encryptedShare: string;
            encryptedKey?: string;
            type: string;
            walletId: string;
        }[];
    }, any>>;
    verifyEmailForRecovery(email: string, verificationCode: string): Promise<AxiosResponse<any, any>>;
    verifyPhoneForRecovery(phone: string, countryCode: string, verificationCode: string): Promise<AxiosResponse<any, any>>;
    verify2FA(auth: VerifiedAuth, verificationCode: string): Promise<any>;
    /**
     * @deprecated
     */
    verify2FAForPhone(phone: AuthIdentifier<'phone'>, verificationCode: string): Promise<AxiosResponse<any, any>>;
    tempTrasmissionInit(message: string, userId?: string): Promise<AxiosResponse<any, any>>;
    tempTrasmission(id: string): Promise<AxiosResponse<any, any>>;
    getPartner(partnerId: string): Promise<AxiosResponse<any, any>>;
    acceptScopes(userId: string, walletId: string, body: AcceptScopesBody): Promise<AxiosResponse<any, any>>;
    getPendingTransaction(userId: string, pendingTransactionId: string): Promise<AxiosResponse<any, any>>;
    acceptPendingTransaction(userId: string, pendingTransactionId: string): Promise<AxiosResponse<any, any>>;
    getOnRampConfig(): Promise<OnRampConfig>;
    createOnRampPurchase({ userId, params, ...walletParams }: {
        userId: string;
        params: OnRampPurchaseCreateParams;
    } & WalletParams): Promise<OnRampPurchase>;
    updateOnRampPurchase({ userId, purchaseId, updates, ...params }: {
        userId: string;
        purchaseId: string;
        updates: OnRampPurchaseUpdateParams;
    } & WalletParams): Promise<OnRampPurchase>;
    getOnRampPurchase({ userId, purchaseId, ...params }: {
        userId: string;
        purchaseId: string;
    } & WalletParams): Promise<AxiosResponse<OnRampPurchase, any>>;
    signMoonPayUrl(userId: string, { url, type, cosmosPrefix, testMode, walletId, externalWalletAddress, }: {
        url: string;
        type: TWalletType;
        cosmosPrefix: string;
        testMode?: boolean;
        walletId?: string;
        externalWalletAddress?: string;
    }): Promise<AxiosResponse<{
        signature: string;
    }, any>>;
    generateOffRampTx<ReturnType = {
        tx: string;
        message?: string;
        asset: OnRampAsset;
        network: Network;
    }>(userId: string, { provider, chainId, contractAddress, testMode, walletId, walletType, destinationAddress, sourceAddress, assetQuantity, }: {
        provider: OnRampProvider;
        chainId: string;
        contractAddress?: string;
        testMode?: boolean;
        walletId: string;
        walletType: TWalletType;
        destinationAddress: string;
        sourceAddress?: string;
        assetQuantity: string | number;
    }): Promise<ReturnType>;
    sendOffRampTx<ReturnType = {
        txHash: string;
    }>(userId: string, { tx, signature, sourceAddress, network, walletId, walletType, }: {
        tx: string;
        signature: string;
        sourceAddress?: string;
        network: Network;
        walletId: string;
        walletType: TWalletType;
    }): Promise<ReturnType>;
    distributeParaShare({ userId, walletId, ...rest }: {
        userId: string;
        walletId: string;
        useDKLS: boolean;
    } & BackupKitEmailProps): Promise<AxiosResponse<any, any>>;
    keepSessionAlive(userId: string): Promise<any>;
    persistRecoveryPublicKeys(userId: string, publicKeys: string[]): Promise<{
        recoveryPublicKeys: {
            id: string;
            publicKey: string;
        }[];
    }>;
    getRecoveryPublicKeys(userId: string): Promise<{
        recoveryPublicKeys: {
            id: string;
            publicKey: string;
        }[];
    }>;
    uploadEncryptedWalletPrivateKey(userId: string, encryptedWalletPrivateKey: string, encryptionKeyHash: string, biometricPublicKey?: string, passwordId?: string): Promise<{
        encryptedWalletPrivateKey: EncryptedWalletPrivateKey;
    }>;
    getEncryptedWalletPrivateKeys(userId: string, encryptionKeyHash: string): Promise<{
        encryptedPrivateKeys: EncryptedWalletPrivateKey[];
    }>;
    getConversionRate(chainId: string, symbol: string, currency: string): Promise<any>;
    getGasEstimate(chainId: string, totalGasPrice: string): Promise<any>;
    getGasOracle(chainId: string): Promise<any>;
    isRefreshDone(userId: string, walletId: string, partnerId?: string, protocolId?: string): Promise<{
        isDone: true;
    }>;
    deletePendingTransaction(userId: string, pendingTransactionId: string): Promise<any>;
    addSessionPasswordPublicKey(userId: string, body: sessionPasswordBody): Promise<any>;
    patchSessionPassword: (partnerId: string, userId: string, passwordId: string, body: sessionPasswordBody) => Promise<any>;
    getSupportedAuthMethods(auth: Auth): Promise<{
        supportedAuthMethods: LegacyAuthMethod[];
    }>;
    getSupportedAuthMethodsV2(auth: Auth): Promise<{
        supportedAuthMethods: AuthMethod[];
        hasPasswordWithoutPIN: boolean;
    }>;
    getPasswords(auth: Auth): Promise<PasswordEntity[]>;
    verifyPasswordChallenge(partnerId: string, body: verifyPasswordChallengeBody): Promise<any>;
    getEncryptedWalletPrivateKey(passwordId: string, sessionLookupId: string): Promise<{
        data: {
            encryptedWalletPrivateKey: EncryptedWalletPrivateKey;
        };
    }>;
    getUser(userId: string): Promise<any>;
    getAccountMetadata(userId: string, partnerId: string): Promise<{
        accountMetadata: AccountMetadata;
    }>;
    getWalletBalance: ({ walletId, rpcUrl }: {
        walletId: string;
        rpcUrl?: string;
    }) => Promise<GetWalletBalanceRes>;
    issueJwt: ({ keyIndex }?: IssueJwtParams) => Promise<IssueJwtResponse>;
    trackError: (opts: {
        methodName: string;
        error: {
            name: string;
            message: string;
        };
        sdkType: SDKType;
        userId: string;
    }) => Promise<void>;
    trackReactSdkAnalytics: (opts: {
        props: object;
        reactSdkVersion: string;
    }) => Promise<void>;
}
export default Client;

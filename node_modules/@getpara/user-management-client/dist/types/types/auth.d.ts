import { CurrentWalletIds, ExternalWalletType, SupportedWalletTypes, TExternalWallet } from './wallet.js';
export declare const AUTH_TYPES: readonly ["email", "phone", "phoneLegacy", "farcaster", "telegram", "userId", "externalWallet", "discord", "x", "customId", "guestId"];
export type AuthType = 'email' | 'phone' | 'phoneLegacy' | 'farcaster' | 'telegram' | 'userId' | 'externalWallet' | 'discord' | 'x' | 'customId' | 'guestId';
export type PrimaryAuthType = Extract<AuthType, 'email' | 'phone' | 'farcaster' | 'telegram' | 'externalWallet'>;
export type VerifiedAuthType = Extract<PrimaryAuthType, 'email' | 'phone' | 'externalWallet'>;
export type PregenAuthType = Exclude<PrimaryAuthType, 'externalWallet'> | Extract<AuthType, 'discord' | 'x' | 'customId'>;
export type AuthIdentifier<T extends AuthType | never> = T extends 'phone' ? `+${number}` : string;
export type AuthInfo<T extends Exclude<AuthType, 'phoneLegacy'> = Exclude<AuthType, 'phoneLegacy'>> = {
    auth: Auth<T>;
    authType: T;
    identifier: AuthIdentifier<T>;
};
export type PrimaryAuthInfo = AuthInfo<PrimaryAuthType>;
export type VerifiedAuthInfo = AuthInfo<VerifiedAuthType>;
export type PregenAuthInfo = AuthInfo<PregenAuthType>;
export type AuthParams = Record<string, any> & {
    email?: string;
    phone?: string;
    countryCode?: string;
    farcasterUsername?: string;
    telegramUserId?: string;
    userId?: string;
    externalWalletAddress?: string;
};
export type Auth<T extends AuthType = AuthType> = T extends 'email' ? {
    email: string;
} : T extends 'phoneLegacy' ? {
    phone: string;
    countryCode: string;
} : T extends 'phone' ? {
    phone: AuthIdentifier<'phone'>;
} : T extends 'farcaster' ? {
    farcasterUsername: AuthIdentifier<'farcaster'>;
} : T extends 'telegram' ? {
    telegramUserId: AuthIdentifier<'telegram'>;
} : T extends 'externalWallet' ? {
    externalWalletAddress: AuthIdentifier<'externalWallet'>;
} : T extends 'x' ? {
    xUsername: AuthIdentifier<'x'>;
} : T extends 'discord' ? {
    discordUsername: AuthIdentifier<'discord'>;
} : T extends 'customId' ? {
    customId: AuthIdentifier<'customId'>;
} : T extends 'guestId' ? {
    guestId: AuthIdentifier<'guestId'>;
} : {
    userId: AuthIdentifier<'userId'>;
};
export type PrimaryAuth = Auth<PrimaryAuthType>;
export type VerifiedAuth = Auth<VerifiedAuthType>;
export type PregenAuth = Auth<PregenAuthType>;
export type PregenOrGuestAuth = Auth<PregenAuthType | 'guestId'>;
export type AuthExtras = {
    /**
     * The current user's third-party username.
     */
    username?: string;
    /**
     * The current user's third-party display name.
     */
    displayName?: string;
    /**
     * The current user's third-party profile picture URL.
     */
    pfpUrl?: string;
    /**
     * The current user's external wallet information.
     */
    externalWallet?: ExternalWalletInfo;
};
export declare enum EncryptorType {
    USER = "USER",
    RECOVERY = "RECOVERY",
    BIOMETRICS = "BIOMETRICS",
    PASSWORD = "PASSWORD"
}
export declare enum KeyShareType {
    USER = "USER",
    RECOVERY = "RECOVERY"
}
export declare enum PasswordStatus {
    PENDING = "PENDING",
    COMPLETE = "COMPLETE"
}
export declare enum PublicKeyStatus {
    PENDING = "PENDING",
    COMPLETE = "COMPLETE"
}
export declare enum PublicKeyType {
    MOBILE = "MOBILE",
    WEB = "WEB"
}
export interface EncryptedKeyShare {
    encryptedShare: string;
    encryptedKey?: string;
    type: KeyShareType;
    biometricPublicKey?: string;
    encryptor: EncryptorType;
    recoveryPublicKeyId?: string;
    partnerId?: string;
    protocolId?: string;
}
/** @deprecated use the string union type `TOAuthMethod` instead */
export declare enum OAuthMethod {
    GOOGLE = "GOOGLE",
    TWITTER = "TWITTER",
    APPLE = "APPLE",
    DISCORD = "DISCORD",
    FACEBOOK = "FACEBOOK",
    FARCASTER = "FARCASTER",
    TELEGRAM = "TELEGRAM"
}
export declare const OAUTH_METHODS: readonly ["GOOGLE", "TWITTER", "APPLE", "DISCORD", "FACEBOOK", "FARCASTER", "TELEGRAM"];
export type TOAuthMethod = (typeof OAUTH_METHODS)[number];
export declare const LINKED_ACCOUNT_TYPES: readonly ["EMAIL", "PHONE", "GOOGLE", "FACEBOOK", "APPLE", "TWITTER", "DISCORD", "TELEGRAM", "FARCASTER", "EXTERNAL_WALLET"];
export type TLinkedAccountType = (typeof LINKED_ACCOUNT_TYPES)[number] | 'EXTERNAL_WALLET';
export type SupportedAccountLinks = (TLinkedAccountType | TExternalWallet)[];
export declare enum AuthMethod {
    PASSWORD = "PASSWORD",
    PASSKEY = "PASSKEY",
    PIN = "PIN"
}
export declare enum LegacyAuthMethod {
    PASSWORD = "PASSWORD",
    BIOMETRIC = "BIOMETRIC"
}
export type BiometricLocationHint = {
    useragent?: string;
    aaguid?: string;
};
export type TelegramAuthResponse = {
    auth_date: number;
    first_name?: string;
    hash: string;
    id: number;
    last_name?: string;
    photo_url?: string;
    username?: string;
};
export type SessionInfo = {
    userId?: string;
    sessionId?: string;
    sessionLookupId?: string;
    partnerId: string;
    biometricVerifiedAt?: number;
    currentWalletIds?: CurrentWalletIds;
    needsWallet?: boolean;
    isAuthenticated?: boolean;
    supportedWalletTypes: SupportedWalletTypes;
    cosmosPrefix?: string;
    origin?: string;
    email?: string;
    verifiedExternalWalletAddresses?: string[];
};
export type ServerAuthStateBase = AuthExtras & {
    auth: PrimaryAuth;
    userId: string;
};
export type ServerAuthStateVerify = ServerAuthStateBase & {
    stage: 'verify';
    signatureVerificationMessage?: string;
};
export type ServerAuthStateSignup = ServerAuthStateBase & {
    stage: 'signup';
    signupAuthMethods: AuthMethod[];
};
export type ServerAuthStateLogin = ServerAuthStateBase & {
    stage: 'login';
    biometricHints?: BiometricLocationHint[];
    loginAuthMethods: AuthMethod[];
    isWalletSelectionNeeded?: boolean;
    hasPasswordWithoutPIN?: boolean;
    signatureVerificationMessage?: string;
};
export type VerifyThirdPartyAuth = ServerAuthStateSignup | ServerAuthStateLogin;
export type ExternalWalletInfo = {
    partnerId: string;
    address: string;
    type: ExternalWalletType;
    provider?: string;
    providerId?: string;
    addressBech32?: string;
    withFullParaAuth?: boolean;
    ensName?: string | null;
    ensAvatar?: string | null;
    isConnectionOnly?: boolean;
    withVerification?: boolean;
};
export type VerifyExternalWalletParams = {
    /**
     * The external wallet information to verify.
     */
    externalWallet: ExternalWalletInfo;
    /**
     * The signature of the signed verification string.
     */
    signedMessage: string;
    /**
     * For Cosmos wallets, the wallet's public key as a hex string.
     */
    cosmosPublicKeyHex?: string;
    /**
     * For Cosmos wallets, the base64 signer string.
     */
    cosmosSigner?: string;
};
export type LoginExternalWalletResponse = ServerAuthStateLogin | (ServerAuthStateVerify & {
    signatureVerificationMessage: string;
});
export type VerifyTelegramResponse = VerifyThirdPartyAuth;
export type VerifyFarcasterResponse = VerifyThirdPartyAuth | Record<string, never>;
export type ServerAuthState = ServerAuthStateVerify | ServerAuthStateSignup | ServerAuthStateLogin;
export type SignUpOrLogInResponse = ServerAuthStateVerify | ServerAuthStateLogin;
export type Setup2faResponse = {
    /**
     * Indicates whether 2FA has already been set up for the current user.
     */
    isSetup: true;
    uri: undefined;
} | {
    isSetup?: false;
    /**
     * A URI for the user to set up two-factor authentication.
     */
    uri: string;
};
export type AccountMetadataKey = Lowercase<Exclude<TOAuthMethod, 'TWITTER'> | 'X'>;
export type AccountMetadata = Partial<Record<AccountMetadataKey, {
    date: Date;
    metadata: Record<string, any>;
}>>;
export type IssueJwtParams = {
    /**
     * The index of the Para RSA keypair to use for signing the JWT. Defaults to `0`.
     */
    keyIndex?: number;
};
export type IssueJwtResponse = {
    /**
     * The Para JWT token.
     */
    token: string;
    /**
     * The `keyid`` / `kid` of the keypair used to sign the JWT.
     */
    keyId: string;
};
export type LinkedAccount<D extends Date | string = Date> = {
    id?: string;
    date: D;
    type: TLinkedAccountType;
    identifier: string;
    displayName: string;
    externalWallet?: ExternalWalletInfo;
    metadata?: unknown;
};
export type LinkedAccounts<D extends Date | string = Date> = {
    primary: LinkedAccount<D>[];
    linked: LinkedAccount<D>[];
};
export type LinkAccountParams = {
    type: TLinkedAccountType;
    identifier?: string;
    externalWallet?: ExternalWalletInfo;
};
export type VerifyLinkParams = {
    linkedAccountId: string;
    userId: string;
    telegramAuthResponse?: TelegramAuthResponse;
    verificationCode?: string;
};

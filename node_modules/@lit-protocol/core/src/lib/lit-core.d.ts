import { SIGTYPE } from '@lit-protocol/constants';
import { AuthSig, CustomNetwork, FormattedMultipleAccs, HandshakeWithSgx, KV, LitNodeClientConfig, MultipleAccessControlConditions, NodeCommandServerKeysResponse, RejectedNodePromises, SendNodeCommand, SessionSig, SessionSigsMap, SuccessNodePromises, SupportedJsonRequests } from '@lit-protocol/types';
export declare class LitCore {
    config: LitNodeClientConfig;
    connectedNodes: SetConstructor | Set<any> | any;
    serverKeys: KV | any;
    ready: boolean;
    subnetPubKey: string | null;
    networkPubKey: string | null;
    networkPubKeySet: string | null;
    hdRootPubkeys: string[] | null;
    constructor(args: any[LitNodeClientConfig | CustomNetwork | any]);
    /**
     *
     * Set bootstrapUrls to match the network litNetwork unless it's set to custom
     *
     * @returns { void }
     *
     */
    setCustomBootstrapUrls: () => void;
    /**
     *
     * Connect to the LIT nodes
     *
     * @returns { Promise } A promise that resolves when the nodes are connected.
     *
     */
    connect: () => Promise<any>;
    /**
     *
     * Get a random request ID
     *   *
     * @returns { string }
     *
     */
    getRequestId(): string;
    /**
     *
     * Handshake with SGX
     *
     * @param { HandshakeWithSgx } params
     *
     * @returns { Promise<NodeCommandServerKeysResponse> }
     *
     */
    handshakeWithSgx: (params: HandshakeWithSgx, requestId: string) => Promise<NodeCommandServerKeysResponse>;
    /**
     *
     * Send a command to nodes
     *
     * @param { SendNodeCommand }
     *
     * @returns { Promise<any> }
     *
     */
    sendCommandToNode: ({ url, data, requestId, }: SendNodeCommand) => Promise<any>;
    /**
     *
     * Get and gather node promises
     *
     * @param { any } callback
     *
     * @returns { Array<Promise<any>> }
     *
     */
    getNodePromises: (callback: Function) => Array<Promise<any>>;
    /**
     *
     * Get either auth sig or session auth sig
     *
     */
    getAuthSigOrSessionAuthSig: ({ authSig, sessionSigs, url, }: {
        authSig?: AuthSig | undefined;
        sessionSigs?: SessionSigsMap | undefined;
        url: string;
    }) => AuthSig | SessionSig;
    /**
     *
     * Get hash of access control conditions
     *
     * @param { MultipleAccessControlConditions } params
     *
     * @returns { Promise<ArrayBuffer | undefined> }
     *
     */
    getHashedAccessControlConditions: (params: MultipleAccessControlConditions) => Promise<ArrayBuffer | undefined>;
    /**
     * Handle node promises
     *
     * @param { Array<Promise<any>> } nodePromises
     *
     * @returns { Promise<SuccessNodePromises<T> | RejectedNodePromises> }
     *
     */
    handleNodePromises: <T>(nodePromises: Promise<T>[], minNodeCount?: number) => Promise<SuccessNodePromises<T> | RejectedNodePromises>;
    /**
     *
     * Throw node error
     *
     * @param { RejectedNodePromises } res
     *
     * @returns { void }
     *
     */
    _throwNodeError: (res: RejectedNodePromises) => void;
    /**
     *
     * Get different formats of access control conditions, eg. evm, sol, unified etc.
     *
     * @param { SupportedJsonRequests } params
     *
     * @returns { FormattedMultipleAccs }
     *
     */
    getFormattedAccessControlConditions: (params: SupportedJsonRequests) => FormattedMultipleAccs;
    /**
     * Calculates an HD public key from a given {@link keyId} the curve type or signature type will assumed to be k256 unless given
     * @param keyId
     * @param sigType
     * @returns {string} public key
     */
    computeHDPubKey: (keyId: string, sigType?: SIGTYPE) => string;
    /**
     * Telem collector for function invokation counts
     * @param date
     * @param functionName
     * @param executionTime
     */
    collectData: (date: string, functionName: string, executionTime: number) => void;
}

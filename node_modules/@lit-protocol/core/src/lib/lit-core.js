"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LitCore = void 0;
const crypto_1 = require("@lit-protocol/crypto");
const access_control_conditions_1 = require("@lit-protocol/access-control-conditions");
const constants_1 = require("@lit-protocol/constants");
const misc_1 = require("@lit-protocol/misc");
class LitCore {
    // ========== Constructor ==========
    constructor(args) {
        // ========== Scoped Class Helpers ==========
        /**
         *
         * Set bootstrapUrls to match the network litNetwork unless it's set to custom
         *
         * @returns { void }
         *
         */
        this.setCustomBootstrapUrls = () => {
            // -- validate
            if (this.config.litNetwork === 'custom')
                return;
            // -- execute
            const hasNetwork = this.config.litNetwork in constants_1.LIT_NETWORKS;
            if (!hasNetwork) {
                // network not found, report error
                (0, misc_1.throwError)({
                    message: 'the litNetwork specified in the LitNodeClient config not found in LIT_NETWORKS',
                    errorKind: constants_1.LIT_ERROR.LIT_NODE_CLIENT_BAD_CONFIG_ERROR.kind,
                    errorCode: constants_1.LIT_ERROR.LIT_NODE_CLIENT_BAD_CONFIG_ERROR.name,
                });
                return;
            }
            this.config.bootstrapUrls = constants_1.LIT_NETWORKS[this.config.litNetwork];
        };
        /**
         *
         * Connect to the LIT nodes
         *
         * @returns { Promise } A promise that resolves when the nodes are connected.
         *
         */
        this.connect = () => {
            // -- handshake with each node
            const requestId = this.getRequestId();
            for (const url of this.config.bootstrapUrls) {
                this.handshakeWithSgx({ url }, requestId)
                    .then((resp) => {
                    this.connectedNodes.add(url);
                    let keys = {
                        serverPubKey: resp.serverPublicKey,
                        subnetPubKey: resp.subnetPublicKey,
                        networkPubKey: resp.networkPublicKey,
                        networkPubKeySet: resp.networkPublicKeySet,
                        hdRootPubkeys: resp.hdRootPubkeys,
                    };
                    // -- validate returned keys
                    if (keys.serverPubKey === 'ERR' ||
                        keys.subnetPubKey === 'ERR' ||
                        keys.networkPubKey === 'ERR' ||
                        keys.networkPubKeySet === 'ERR') {
                        (0, misc_1.log)('Error connecting to node. Detected "ERR" in keys', url, keys);
                    }
                    this.serverKeys[url] = keys;
                })
                    .catch((e) => {
                    (0, misc_1.log)('Error connecting to node ', url, e);
                });
            }
            // -- get promise
            const promise = new Promise((resolve, reject) => {
                const startTime = Date.now();
                const interval = setInterval(() => {
                    if (Object.keys(this.serverKeys).length >= this.config.minNodeCount) {
                        clearInterval(interval);
                        // pick the most common public keys for the subnet and network from the bunch, in case some evil node returned a bad key
                        this.subnetPubKey = (0, misc_1.mostCommonString)(Object.values(this.serverKeys).map((keysFromSingleNode) => keysFromSingleNode.subnetPubKey));
                        this.networkPubKey = (0, misc_1.mostCommonString)(Object.values(this.serverKeys).map((keysFromSingleNode) => keysFromSingleNode.networkPubKey));
                        this.networkPubKeySet = (0, misc_1.mostCommonString)(Object.values(this.serverKeys).map((keysFromSingleNode) => keysFromSingleNode.networkPubKeySet));
                        this.hdRootPubkeys = (0, misc_1.mostCommonString)(Object.values(this.serverKeys).map((keysFromSingleNode) => keysFromSingleNode.hdRootPubkeys));
                        this.ready = true;
                        (0, misc_1.log)(`ðŸ”¥ lit is ready. "litNodeClient" variable is ready to use globally.`);
                        // @ts-ignore
                        globalThis.litNodeClient = this;
                        // browser only
                        if ((0, misc_1.isBrowser)()) {
                            document.dispatchEvent(new Event('lit-ready'));
                        }
                        // @ts-ignore: Expected 1 arguments, but got 0. Did you forget to include 'void' in your type argument to 'Promise'?ts(2794)
                        resolve();
                    }
                    else {
                        const now = Date.now();
                        if (now - startTime > this.config.connectTimeout) {
                            clearInterval(interval);
                            const msg = `Error: Could not connect to enough nodes after timeout of ${this.config.connectTimeout}ms.  Could only connect to ${Object.keys(this.serverKeys).length} of ${this.config.minNodeCount} required nodes.  Please check your network connection and try again.  Note that you can control this timeout with the connectTimeout config option which takes milliseconds.`;
                            (0, misc_1.log)(msg);
                            reject(msg);
                        }
                    }
                }, 500);
            });
            return promise;
        };
        /**
         *
         * Handshake with SGX
         *
         * @param { HandshakeWithSgx } params
         *
         * @returns { Promise<NodeCommandServerKeysResponse> }
         *
         */
        this.handshakeWithSgx = async (params, requestId) => {
            // -- get properties from params
            const { url } = params;
            // -- create url with path
            const urlWithPath = `${url}/web/handshake`;
            (0, misc_1.log)(`handshakeWithSgx ${urlWithPath}`);
            const data = {
                clientPublicKey: 'test',
            };
            return this.sendCommandToNode({
                url: urlWithPath,
                data,
                requestId,
            });
        };
        // ==================== SENDING COMMAND ====================
        /**
         *
         * Send a command to nodes
         *
         * @param { SendNodeCommand }
         *
         * @returns { Promise<any> }
         *
         */
        this.sendCommandToNode = async ({ url, data, requestId, }) => {
            (0, misc_1.log)(`sendCommandToNode with url ${url} and data`, data);
            const req = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Lit-SDK-Version': constants_1.version,
                    'X-Lit-SDK-Type': 'Typescript',
                    'X-Request-Id': 'lit_' + requestId,
                },
                body: JSON.stringify(data),
            };
            return fetch(url, req)
                .then(async (response) => {
                const isJson = response.headers
                    .get('content-type')
                    ?.includes('application/json');
                const data = isJson ? await response.json() : null;
                if (!response.ok) {
                    // get error message from body or default to response status
                    const error = data || response.status;
                    return Promise.reject(error);
                }
                return data;
            })
                .catch((error) => {
                console.error('Something went wrong, internal id for request: ', 'lit_' + requestId, 'Please provide this identifier with any support requests');
                return Promise.reject(error);
            });
        };
        /**
         *
         * Get and gather node promises
         *
         * @param { any } callback
         *
         * @returns { Array<Promise<any>> }
         *
         */
        this.getNodePromises = (callback) => {
            const nodePromises = [];
            for (const url of this.connectedNodes) {
                nodePromises.push(callback(url));
            }
            return nodePromises;
        };
        /**
         *
         * Get either auth sig or session auth sig
         *
         */
        this.getAuthSigOrSessionAuthSig = ({ authSig, sessionSigs, url, }) => {
            if (!authSig && !sessionSigs) {
                (0, misc_1.throwError)({
                    message: `You must pass either authSig or sessionSigs`,
                    errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                    errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
                });
                // @ts-ignore
                return;
            }
            if (sessionSigs) {
                const sigToPassToNode = sessionSigs[url];
                if (!sigToPassToNode) {
                    (0, misc_1.throwError)({
                        message: `You passed sessionSigs but we could not find session sig for node ${url}`,
                        errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                        errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
                    });
                }
                return sigToPassToNode;
            }
            return authSig;
        };
        /**
         *
         * Get hash of access control conditions
         *
         * @param { MultipleAccessControlConditions } params
         *
         * @returns { Promise<ArrayBuffer | undefined> }
         *
         */
        this.getHashedAccessControlConditions = async (params) => {
            let hashOfConditions;
            // ========== Prepare Params ==========
            const { accessControlConditions, evmContractConditions, solRpcConditions, unifiedAccessControlConditions, } = params;
            // ========== Hash ==========
            if (accessControlConditions) {
                hashOfConditions = await (0, access_control_conditions_1.hashAccessControlConditions)(accessControlConditions);
            }
            else if (evmContractConditions) {
                hashOfConditions = await (0, access_control_conditions_1.hashEVMContractConditions)(evmContractConditions);
            }
            else if (solRpcConditions) {
                hashOfConditions = await (0, access_control_conditions_1.hashSolRpcConditions)(solRpcConditions);
            }
            else if (unifiedAccessControlConditions) {
                hashOfConditions = await (0, access_control_conditions_1.hashUnifiedAccessControlConditions)(unifiedAccessControlConditions);
            }
            else {
                return;
            }
            // ========== Result ==========
            return hashOfConditions;
        };
        /**
         * Handle node promises
         *
         * @param { Array<Promise<any>> } nodePromises
         *
         * @returns { Promise<SuccessNodePromises<T> | RejectedNodePromises> }
         *
         */
        this.handleNodePromises = async (nodePromises, minNodeCount) => {
            // -- prepare
            const responses = await Promise.allSettled(nodePromises);
            const minNodes = minNodeCount ?? this.config.minNodeCount;
            // -- get fulfilled responses
            const successes = responses.filter((r) => r.status === 'fulfilled');
            // -- case: success (when success responses are more than minNodeCount)
            if (successes.length >= minNodes) {
                const successPromises = {
                    success: true,
                    values: successes.map((r) => r.value),
                };
                return successPromises;
            }
            // -- case: if we're here, then we did not succeed.  time to handle and report errors.
            // -- get "rejected" responses
            const rejected = responses.filter((r) => r.status === 'rejected');
            const mostCommonError = JSON.parse((0, misc_1.mostCommonString)(rejected.map((r) => JSON.stringify(r.reason))));
            (0, misc_1.log)(`most common error: ${JSON.stringify(mostCommonError)}`);
            const rejectedPromises = {
                success: false,
                error: mostCommonError,
            };
            return rejectedPromises;
        };
        /**
         *
         * Throw node error
         *
         * @param { RejectedNodePromises } res
         *
         * @returns { void }
         *
         */
        this._throwNodeError = (res) => {
            if (res.error && res.error.errorCode) {
                if ((res.error.errorCode === constants_1.LIT_ERROR_CODE.NODE_NOT_AUTHORIZED ||
                    res.error.errorCode === 'not_authorized') &&
                    this.config.alertWhenUnauthorized) {
                    (0, misc_1.log)('[Alert originally] You are not authorized to access to this content');
                }
                (0, misc_1.throwError)({
                    ...res.error,
                    message: res.error.message ||
                        'You are not authorized to access to this content',
                    errorCode: res.error.errorCode,
                });
            }
            else {
                (0, misc_1.throwError)({
                    message: `There was an error getting the signing shares from the nodes`,
                    error: constants_1.LIT_ERROR.UNKNOWN_ERROR,
                });
            }
        };
        /**
         *
         * Get different formats of access control conditions, eg. evm, sol, unified etc.
         *
         * @param { SupportedJsonRequests } params
         *
         * @returns { FormattedMultipleAccs }
         *
         */
        this.getFormattedAccessControlConditions = (params) => {
            // -- prepare params
            const { accessControlConditions, evmContractConditions, solRpcConditions, unifiedAccessControlConditions, } = params;
            // -- execute
            let formattedAccessControlConditions;
            let formattedEVMContractConditions;
            let formattedSolRpcConditions;
            let formattedUnifiedAccessControlConditions;
            let error = false;
            if (accessControlConditions) {
                formattedAccessControlConditions = accessControlConditions.map((c) => (0, access_control_conditions_1.canonicalAccessControlConditionFormatter)(c));
                (0, misc_1.log)('formattedAccessControlConditions', JSON.stringify(formattedAccessControlConditions));
            }
            else if (evmContractConditions) {
                formattedEVMContractConditions = evmContractConditions.map((c) => (0, access_control_conditions_1.canonicalEVMContractConditionFormatter)(c));
                (0, misc_1.log)('formattedEVMContractConditions', JSON.stringify(formattedEVMContractConditions));
            }
            else if (solRpcConditions) {
                formattedSolRpcConditions = solRpcConditions.map((c) => (0, access_control_conditions_1.canonicalSolRpcConditionFormatter)(c));
                (0, misc_1.log)('formattedSolRpcConditions', JSON.stringify(formattedSolRpcConditions));
            }
            else if (unifiedAccessControlConditions) {
                formattedUnifiedAccessControlConditions =
                    unifiedAccessControlConditions.map((c) => (0, access_control_conditions_1.canonicalUnifiedAccessControlConditionFormatter)(c));
                (0, misc_1.log)('formattedUnifiedAccessControlConditions', JSON.stringify(formattedUnifiedAccessControlConditions));
            }
            else {
                error = true;
            }
            return {
                error,
                formattedAccessControlConditions,
                formattedEVMContractConditions,
                formattedSolRpcConditions,
                formattedUnifiedAccessControlConditions,
            };
        };
        /**
         * Calculates an HD public key from a given {@link keyId} the curve type or signature type will assumed to be k256 unless given
         * @param keyId
         * @param sigType
         * @returns {string} public key
         */
        this.computeHDPubKey = (keyId, sigType = constants_1.SIGTYPE.EcdsaCaitSith) => {
            if (!this.hdRootPubkeys) {
                (0, misc_1.throwError)({
                    message: `root public keys not found, have you connected to the nodes?`,
                    errorKind: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
                    errorCode: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.code,
                });
            }
            return (0, crypto_1.computeHDPubKey)(this.hdRootPubkeys, keyId, sigType);
        };
        /**
         * Telem collector for function invokation counts
         * @param date
         * @param functionName
         * @param executionTime
         */
        this.collectData = (date, functionName, executionTime) => {
            fetch(constants_1.TELEM_API_URL + '/collect', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ date, functionName, executionTime }),
            });
        };
        let customConfig = args;
        // -- initialize default config
        this.config = constants_1.defaultLitnodeClientConfig;
        // -- initialize default auth callback
        // this.defaultAuthCallback = args?.defaultAuthCallback;
        // -- if config params are specified, replace it
        if (customConfig) {
            this.config = { ...this.config, ...customConfig };
            // this.config = override(this.config, customConfig);
        }
        // -- init default properties
        this.connectedNodes = new Set();
        this.serverKeys = {};
        this.ready = false;
        this.subnetPubKey = null;
        this.networkPubKey = null;
        this.networkPubKeySet = null;
        this.hdRootPubkeys = null;
        // -- set bootstrapUrls to match the network litNetwork unless it's set to custom
        this.setCustomBootstrapUrls();
        // -- set global variables
        globalThis.litConfig = this.config;
    }
    /**
     *
     * Get a random request ID
     *   *
     * @returns { string }
     *
     */
    getRequestId() {
        return Math.random().toString(16).slice(2);
    }
}
exports.LitCore = LitCore;
//# sourceMappingURL=lit-core.js.map
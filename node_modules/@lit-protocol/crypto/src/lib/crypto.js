"use strict";
// @ts-nocheck
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSessionKeyPair = exports.computeHDPubKey = exports.combineEcdsaShares = exports.verifySignature = exports.combineSignatureShares = exports.verifyAndDecryptWithSignatureShares = exports.decryptWithSignatureShares = exports.encrypt = void 0;
const blsSdk = require("@lit-protocol/bls-sdk");
const constants_1 = require("@lit-protocol/constants");
const wasmECDSA = require("@lit-protocol/ecdsa-sdk");
const misc_1 = require("@lit-protocol/misc");
const uint8arrays_1 = require("@lit-protocol/uint8arrays");
const nacl_1 = require("@lit-protocol/nacl");
const constants_2 = require("@lit-protocol/constants");
// if 'wasmExports' is not available, we need to initialize the BLS SDK
if (!globalThis.wasmExports) {
    blsSdk.initWasmBlsSdk().then((exports) => {
        globalThis.wasmExports = exports;
        if (!globalThis.jestTesting) {
            (0, misc_1.log)(`✅ [BLS SDK] wasmExports loaded. ${Object.keys(exports).length} functions available. Run 'wasmExports' in the console to see them.`);
        }
    });
}
if (!globalThis.wasmECDSA) {
    let init = wasmECDSA.initWasmEcdsaSdk;
    let env;
    if ((0, misc_1.isBrowser)()) {
        env = 'Browser';
    }
    else {
        env = 'NodeJS';
    }
    init().then((sdk) => {
        globalThis.wasmECDSA = sdk;
        if (!globalThis.jestTesting) {
            (0, misc_1.log)(`✅ [ECDSA SDK ${env}] wasmECDSA loaded. ${Object.keys(wasmECDSA).length} functions available. Run 'wasmECDSA' in the console to see them.`);
        }
    });
}
/**
 * Encrypt data with a BLS public key.
 *
 * @param publicKey hex-encoded string of the BLS public key to encrypt with
 * @param data Uint8Array of the data to encrypt
 * @param identity Uint8Array of the identity parameter used during encryption
 * @returns base64 encoded string of the ciphertext
 */
const encrypt = (publicKey, data, identity) => {
    return blsSdk.encrypt(publicKey, (0, uint8arrays_1.uint8arrayToString)(data, 'base64'), (0, uint8arrays_1.uint8arrayToString)(identity, 'base64'));
};
exports.encrypt = encrypt;
/**
 * Decrypt ciphertext using BLS signature shares.
 *
 * @param ciphertext base64-encoded string of the ciphertext to decrypt
 * @param shares hex-encoded array of the BLS signature shares
 * @returns Uint8Array of the decrypted data
 */
const decryptWithSignatureShares = (ciphertext, shares) => {
    // Format the signature shares
    const sigShares = shares.map((s) => JSON.stringify(s));
    // Decrypt
    const privateData = blsSdk.decrypt_with_signature_shares(ciphertext, sigShares);
    // Format
    return (0, uint8arrays_1.uint8arrayFromString)(privateData, 'base64');
};
exports.decryptWithSignatureShares = decryptWithSignatureShares;
/**
 * Verify and decrypt ciphertext using BLS signature shares.
 *
 * @param publicKey hex-encoded string of the BLS public key to verify with
 * @param identity Uint8Array of the identity parameter used during encryption
 * @param ciphertext base64-encoded string of the ciphertext to decrypt
 * @param shares hex-encoded array of the BLS signature shares
 * @returns base64-encoded string of the decrypted data
 */
const verifyAndDecryptWithSignatureShares = (publicKey, identity, ciphertext, shares) => {
    // Format the signature shares
    const sigShares = shares.map((s) => JSON.stringify(s));
    // Decrypt
    const privateData = blsSdk.verify_and_decrypt_with_signature_shares(publicKey, (0, uint8arrays_1.uint8ArrayToBase64)(identity), ciphertext, sigShares);
    // Format
    return (0, uint8arrays_1.uint8arrayFromString)(privateData, 'base64');
};
exports.verifyAndDecryptWithSignatureShares = verifyAndDecryptWithSignatureShares;
/**
 * Combine BLS signature shares.
 *
 * @param shares hex-encoded array of the BLS signature shares
 * @returns hex-encoded string of the combined signature
 */
const combineSignatureShares = (shares) => {
    // Format the signature shares
    const sigShares = shares.map((s) => JSON.stringify(s));
    return blsSdk.combine_signature_shares(sigShares);
};
exports.combineSignatureShares = combineSignatureShares;
/**
 * Verify the BLS network signature.
 *
 * @param publicKey hex-encoded string of the BLS public key to verify with.
 * @param message Uint8Array of the message to verify.
 * @param signature Uint8Array of the signature to verify.
 */
const verifySignature = (publicKey, message, signature) => {
    blsSdk.verify_signature(publicKey, (0, uint8arrays_1.uint8arrayToString)(message, 'base64'), (0, uint8arrays_1.uint8arrayToString)(signature, 'base64'));
};
exports.verifySignature = verifySignature;
/**
 *
 * Combine ECDSA Shares
 *
 * @param { SigShares | Array<SigShare> } sigShares
 *
 * @returns { any }
 *
 */
const combineEcdsaShares = (sigShares) => {
    (0, misc_1.log)('sigShares:', sigShares);
    let type = sigShares[0].sigType;
    // the public key can come from any node - it obviously will be identical from each node
    // const publicKey = sigShares[0].publicKey;
    // const dataSigned = '0x' + sigShares[0].dataSigned;
    // filter out empty shares
    let validShares = sigShares.reduce((acc, val) => {
        if (val.shareHex !== '') {
            const newVal = _remapKeyShareForEcdsa(val);
            acc.push(JSON.stringify(newVal));
        }
        return acc;
    }, []);
    (0, misc_1.log)('Valid Shares:', validShares);
    // if there are no valid shares, throw an error
    if (validShares.length === 0) {
        return (0, misc_1.throwError)({
            message: 'No valid shares to combine',
            errorKind: constants_1.LIT_ERROR.NO_VALID_SHARES.kind,
            errorCode: constants_1.LIT_ERROR.NO_VALID_SHARES.name,
        });
    }
    let sig;
    try {
        let res = '';
        switch (type) {
            case constants_2.SIGTYPE.EcdsaCaitSith:
                res = wasmECDSA.combine_signature(validShares, 2);
                try {
                    sig = JSON.parse(res);
                }
                catch (e) {
                    console.log("xx res:", res); // ERROR: Could not deserialize value
                    throw new Error(`Failed to parse signature: ${e}`);
                }
                /*
                  r and s values of the signature should be maximum of 64 bytes
                  r and s values can have polarity as the first two bits, here we remove
                */
                if (sig.r && sig.r.length > 64) {
                    while (sig.r.length > 64) {
                        sig.r = sig.r.slice(1);
                    }
                }
                if (sig.s && sig.s.length > 64) {
                    while (sig.s.length > 64) {
                        sig.s = sig.s.slice(1);
                    }
                }
                break;
            case constants_2.SIGTYPE.ECDSCAITSITHP256:
                res = wasmECDSA.combine_signature(validShares, 3);
                sig = JSON.parse(res);
                break;
            // if its another sig type, it shouldnt be resolving to this method
            default:
                throw new Error('Unsupported signature type present in signature shares. Please report this issue');
        }
    }
    catch (e) {
        (0, misc_1.log)('Failed to combine signatures:', e);
    }
    (0, misc_1.log)('signature', sig);
    return sig;
};
exports.combineEcdsaShares = combineEcdsaShares;
const computeHDPubKey = (pubkeys, keyId, sigType) => {
    // TODO: hardcoded for now, need to be replaced on each DKG as the last dkg id will be the active root key set.
    try {
        switch (sigType) {
            case constants_2.SIGTYPE.EcdsaCaitSith:
                return wasmECDSA.compute_public_key(keyId, pubkeys, 2);
                defualt: throw new Error('Non supported signature type');
        }
    }
    catch (e) {
        (0, misc_1.log)('Failed to derive public key', e);
    }
};
exports.computeHDPubKey = computeHDPubKey;
/**
 *
 * Generate a session key pair
 *
 * @returns { SessionKeyPair } sessionKeyPair
 */
const generateSessionKeyPair = () => {
    const keyPair = nacl_1.nacl.sign.keyPair();
    const sessionKeyPair = {
        publicKey: (0, uint8arrays_1.uint8arrayToString)(keyPair.publicKey, 'base16'),
        secretKey: (0, uint8arrays_1.uint8arrayToString)(keyPair.secretKey, 'base16'),
    };
    return sessionKeyPair;
};
exports.generateSessionKeyPair = generateSessionKeyPair;
const _remapKeyShareForEcdsa = (share) => {
    const keys = Object.keys(share);
    let newShare = {};
    for (const key of keys) {
        const new_key = key.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
        newShare = Object.defineProperty(newShare, new_key, Object.getOwnPropertyDescriptor(share, key));
    }
    return newShare;
};
//# sourceMappingURL=crypto.js.map
"use strict";
var _LitNodeClientNodeJs_authCallbackAndUpdateStorageItem, _LitNodeClientNodeJs_decryptWithSignatureShares, _LitNodeClientNodeJs_getIdentityParamForEncryption, _LitNodeClientNodeJs_isSuccessNodePromises;
Object.defineProperty(exports, "__esModule", { value: true });
exports.LitNodeClientNodeJs = void 0;
const tslib_1 = require("tslib");
const access_control_conditions_1 = require("@lit-protocol/access-control-conditions");
const constants_1 = require("@lit-protocol/constants");
const crypto_1 = require("@lit-protocol/crypto");
const encryption_1 = require("@lit-protocol/encryption");
const misc_1 = require("@lit-protocol/misc");
const uint8arrays_1 = require("@lit-protocol/uint8arrays");
const transactions_1 = require("@ethersproject/transactions");
const utils_1 = require("ethers/lib/utils");
const lit_siwe_1 = require("lit-siwe");
const core_1 = require("@lit-protocol/core");
const lit_third_party_libs_1 = require("@lit-protocol/lit-third-party-libs");
const auth_helpers_1 = require("@lit-protocol/auth-helpers");
const misc_browser_1 = require("@lit-protocol/misc-browser");
const nacl_1 = require("@lit-protocol/nacl");
const ethers_1 = require("ethers");
/** ---------- Main Export Class ---------- */
class LitNodeClientNodeJs extends core_1.LitCore {
    // ========== Constructor ==========
    constructor(args) {
        super(args);
        // ========== Scoped Class Helpers ==========
        /**
         *
         * Get the request body of the lit action
         *
         * @param { ExecuteJsProps } params
         *
         * @returns { JsonExecutionRequest }
         *
         */
        this.getLitActionRequestBody = (params) => {
            const reqBody = {
                ...(params.authSig && { authSig: params.authSig }),
                ...(params.sessionSigs && { sessionSigs: params.sessionSigs }),
                jsParams: (0, misc_1.convertLitActionsParams)(params.jsParams),
                // singleNode: params.singleNode ?? false,
                targetNodeRange: params.targetNodeRange ?? 0,
            };
            if (params.code) {
                const _uint8Array = (0, uint8arrays_1.uint8arrayFromString)(params.code, 'utf8');
                const encodedJs = (0, uint8arrays_1.uint8arrayToString)(_uint8Array, 'base64');
                reqBody.code = encodedJs;
            }
            if (params.ipfsId) {
                reqBody.ipfsId = params.ipfsId;
            }
            if (params.authMethods && params.authMethods.length > 0) {
                reqBody.authMethods = params.authMethods;
            }
            return reqBody;
        };
        /**
         *
         * we need to send jwt params iat (issued at) and exp (expiration) because the nodes may have different wall clock times, the nodes will verify that these params are withing a grace period
         *
         */
        this.getJWTParams = () => {
            const now = Date.now();
            const iat = Math.floor(now / 1000);
            const exp = iat + 12 * 60 * 60; // 12 hours in seconds
            return { iat, exp };
        };
        /**
         *
         * Parse the response string to JSON
         *
         * @param { string } responseString
         *
         * @returns { any } JSON object
         *
         */
        this.parseResponses = (responseString) => {
            let response;
            try {
                response = JSON.parse(responseString);
            }
            catch (e) {
                (0, misc_1.log)('Error parsing response as json.  Swallowing and returning as string.', responseString);
            }
            return response;
        };
        // ==================== SESSIONS ====================
        /**
         * Try to get the session key in the local storage,
         * if not, generates one.
         * @return { SessionKeyPair } session key pair
         */
        this.getSessionKey = () => {
            const storageKey = constants_1.LOCAL_STORAGE_KEYS.SESSION_KEY;
            const storedSessionKeyOrError = (0, misc_browser_1.getStorageItem)(storageKey);
            if (storedSessionKeyOrError.type === "ERROR" /* EITHER_TYPE.ERROR */ ||
                !storedSessionKeyOrError.result ||
                storedSessionKeyOrError.result === '') {
                console.warn(`Storage key "${storageKey}" is missing. Not a problem. Contiune...`);
                // Generate new one
                const newSessionKey = (0, crypto_1.generateSessionKeyPair)();
                // (TRY) to set to local storage
                try {
                    localStorage.setItem(storageKey, JSON.stringify(newSessionKey));
                }
                catch (e) {
                    console.warn(`Localstorage not available. Not a problem. Contiune...`);
                }
                return newSessionKey;
            }
            else {
                return JSON.parse(storedSessionKeyOrError.result);
            }
        };
        /**
         * Generates wildcard capability for each of the LIT resources
         * specified.
         * @param litResources is an array of LIT resources
         */
        this.generateSessionCapabilityObjectWithWildcards = (litResources) => {
            const sessionCapabilityObject = (0, auth_helpers_1.newSessionCapabilityObject)();
            for (const litResource of litResources) {
                sessionCapabilityObject.addAllCapabilitiesForResource(litResource);
            }
            return sessionCapabilityObject;
        };
        /**
         *
         * Get expiration for session
         *
         */
        this.getExpiration = () => {
            return new Date(Date.now() + 1000 * 60 * 60 * 24).toISOString();
        };
        /**
         *
         * Get the signature from local storage, if not, generates one
         *
         */
        this.getWalletSig = async ({ authNeededCallback, chain, sessionCapabilityObject, switchChain, expiration, sessionKeyUri, }) => {
            let walletSig;
            const storageKey = constants_1.LOCAL_STORAGE_KEYS.WALLET_SIGNATURE;
            const storedWalletSigOrError = (0, misc_browser_1.getStorageItem)(storageKey);
            // -- (TRY) to get it in the local storage
            // -- IF NOT: Generates one
            if (storedWalletSigOrError.type === "ERROR" /* EITHER_TYPE.ERROR */ ||
                !storedWalletSigOrError.result ||
                storedWalletSigOrError.result == '') {
                console.warn(`Storage key "${storageKey}" is missing. Not a problem. Continue...`);
                if (authNeededCallback) {
                    walletSig = await authNeededCallback({
                        chain,
                        statement: sessionCapabilityObject?.statement,
                        resources: sessionCapabilityObject
                            ? [sessionCapabilityObject.encodeAsSiweResource()]
                            : undefined,
                        switchChain,
                        expiration,
                        uri: sessionKeyUri,
                    });
                }
                else {
                    if (!this.defaultAuthCallback) {
                        return (0, misc_1.throwError)({
                            message: 'No default auth callback provided',
                            errorKind: constants_1.LIT_ERROR.PARAMS_MISSING_ERROR.kind,
                            errorCode: constants_1.LIT_ERROR.PARAMS_MISSING_ERROR.name,
                        });
                    }
                    walletSig = await this.defaultAuthCallback({
                        chain,
                        statement: sessionCapabilityObject.statement,
                        resources: sessionCapabilityObject
                            ? [sessionCapabilityObject.encodeAsSiweResource()]
                            : undefined,
                        switchChain,
                        expiration,
                        uri: sessionKeyUri,
                    });
                }
                // (TRY) to set walletSig to local storage
                const storeNewWalletSigOrError = (0, misc_browser_1.setStorageItem)(storageKey, JSON.stringify(walletSig));
                if (storeNewWalletSigOrError.type === 'ERROR') {
                    console.warn(`Unable to store walletSig in local storage. Not a problem. Continue...`);
                }
            }
            else {
                try {
                    walletSig = JSON.parse(storedWalletSigOrError.result);
                }
                catch (e) {
                    console.warn('Error parsing walletSig', e);
                }
            }
            return walletSig;
        };
        _LitNodeClientNodeJs_authCallbackAndUpdateStorageItem.set(this, async ({ authCallbackParams, authCallback, }) => {
            let authSig;
            if (authCallback) {
                authSig = await authCallback(authCallbackParams);
            }
            else {
                if (!this.defaultAuthCallback) {
                    return (0, misc_1.throwError)({
                        message: 'No default auth callback provided',
                        errorKind: constants_1.LIT_ERROR.PARAMS_MISSING_ERROR.kind,
                        errorCode: constants_1.LIT_ERROR.PARAMS_MISSING_ERROR.name,
                    });
                }
                authSig = await this.defaultAuthCallback(authCallbackParams);
            }
            // (TRY) to set walletSig to local storage
            const storeNewWalletSigOrError = (0, misc_browser_1.setStorageItem)(constants_1.LOCAL_STORAGE_KEYS.WALLET_SIGNATURE, JSON.stringify(authSig));
            if (storeNewWalletSigOrError.type === "SUCCESS" /* EITHER_TYPE.SUCCESS */) {
                return authSig;
            }
            // Setting local storage failed, try to remove the item key.
            console.warn(`Unable to store walletSig in local storage. Not a problem. Continuing to remove item key...`);
            const removeWalletSigOrError = (0, misc_browser_1.removeStorageItem)(constants_1.LOCAL_STORAGE_KEYS.WALLET_SIGNATURE);
            if (removeWalletSigOrError.type === "ERROR" /* EITHER_TYPE.ERROR */) {
                console.warn(`Unable to remove walletSig in local storage. Not a problem. Continuing...`);
            }
            return authSig;
        });
        /**
         *
         * Check if a session key needs to be resigned. These are the scenarios where a session key needs to be resigned:
         * 1. The authSig.sig does not verify successfully against the authSig.signedMessage
         * 2. The authSig.signedMessage.uri does not match the sessionKeyUri
         * 3. The authSig.signedMessage does not contain at least one session capability object
         *
         */
        this.checkNeedToResignSessionKey = async ({ authSig, sessionKeyUri, resourceAbilityRequests, }) => {
            const authSigSiweMessage = new lit_siwe_1.SiweMessage(authSig.signedMessage);
            try {
                await authSigSiweMessage.validate(authSig.sig);
            }
            catch (e) {
                console.debug('Need retry because verify failed', e);
                return true;
            }
            // make sure the sig is for the correct session key
            if (authSigSiweMessage.uri !== sessionKeyUri) {
                console.debug('Need retry because uri does not match');
                return true;
            }
            // make sure the authSig contains at least one resource.
            if (!authSigSiweMessage.resources ||
                authSigSiweMessage.resources.length === 0) {
                console.debug('Need retry because empty resources');
                return true;
            }
            // make sure the authSig contains session capabilities that can be parsed.
            // TODO: we currently only support the first resource being a session capability object.
            const authSigSessionCapabilityObject = (0, auth_helpers_1.decode)(authSigSiweMessage.resources[0]);
            // make sure the authSig session capability object describes capabilities that are equal or greater than
            // the abilities requested against the resources in the resource ability requests.
            for (const resourceAbilityRequest of resourceAbilityRequests) {
                if (!authSigSessionCapabilityObject.verifyCapabilitiesForResource(resourceAbilityRequest.resource, resourceAbilityRequest.ability)) {
                    console.debug('Need retry because capabilities do not match', {
                        authSigSessionCapabilityObject,
                        resourceAbilityRequest,
                    });
                    return true;
                }
            }
            return false;
        };
        // ==================== API Calls to Nodes ====================
        /**
         *
         * Get JS Execution Shares from Nodes
         *
         * @param { JsonExecutionRequest } params
         *
         * @returns { Promise<any> }
         */
        this.getJsExecutionShares = async (url, params, requestId) => {
            const { code, ipfsId, authSig, jsParams, sessionSigs, authMethods } = params;
            (0, misc_1.log)('getJsExecutionShares');
            // -- execute
            const urlWithPath = `${url}/web/execute`;
            if (!authSig) {
                throw new Error('authSig is required');
            }
            const data = {
                code,
                ipfsId,
                authSig,
                jsParams,
                authMethods,
            };
            return await this.sendCommandToNode({ url: urlWithPath, data, requestId });
        };
        this.getPkpSignExecutionShares = async (url, params, requestId) => {
            (0, misc_1.log)('getPkpSigningShares');
            const urlWithPath = `${url}/web/pkp/sign`;
            if (!params.authSig) {
                throw new Error('authSig is required');
            }
            return await this.sendCommandToNode({
                url: urlWithPath,
                data: params,
                requestId,
            });
        };
        this.getClaimKeyExecutionShares = async (url, params, requestId) => {
            (0, misc_1.log)('getPkpSigningShares');
            const urlWithPath = `${url}/web/pkp/claim`;
            if (!params.authMethod) {
                throw new Error('authMethod is required');
            }
            return await this.sendCommandToNode({
                url: urlWithPath,
                data: params,
                requestId,
            });
        };
        /**
         * Get Signing Shares for Token containing Access Control Condition
         *
         * @param { string } url
         * @param { SigningAccessControlConditionRequest } params
         *
         * @returns { Promise<NodeCommandResponse> }
         *
         */
        this.getSigningShareForToken = async (url, params, requestId) => {
            (0, misc_1.log)('getSigningShareForToken');
            const urlWithPath = `${url}/web/signing/access_control_condition`;
            return this.sendCommandToNode({
                url: urlWithPath,
                data: params,
                requestId,
            });
        };
        /**
         *
         * Get signature shares for decryption.
         *
         * @param url
         * @param params
         * @param requestId
         * @returns
         */
        this.getSigningShareForDecryption = async (url, params, requestId) => {
            (0, misc_1.log)('getSigningShareForDecryption');
            const urlWithPath = `${url}/web/encryption/sign`;
            return await this.sendCommandToNode({
                url: urlWithPath,
                data: params,
                requestId,
            });
        };
        /**
         *
         * Sign Condition ECDSA
         *
         * @param { string } url
         * @param { SignConditionECDSA } params
         *
         * @returns { Promise<NodeCommandResponse> }
         *
         */
        this.signConditionEcdsa = async (url, params, requestId) => {
            (0, misc_1.log)('signConditionEcdsa');
            const urlWithPath = `${url}/web/signing/signConditionEcdsa`;
            const data = {
                access_control_conditions: params.accessControlConditions,
                evmContractConditions: params.evmContractConditions,
                solRpcConditions: params.solRpcConditions,
                auth_sig: params.auth_sig,
                chain: params.chain,
                iat: params.iat,
                exp: params.exp,
            };
            return await this.sendCommandToNode({
                url: urlWithPath,
                data,
                requestId,
            });
        };
        /**
         *
         * Combine Shares from network public key set and signature shares
         *
         * @param { NodeBlsSigningShare } signatureShares
         *
         * @returns { string } final JWT (convert the sig to base64 and append to the jwt)
         *
         */
        this.combineSharesAndGetJWT = (signatureShares) => {
            // ========== Shares Validations ==========
            // -- sanity check
            if (!signatureShares.every((val, i, arr) => val.unsignedJwt === arr[0].unsignedJwt)) {
                const msg = 'Unsigned JWT is not the same from all the nodes.  This means the combined signature will be bad because the nodes signed the wrong things';
                (0, misc_1.log)(msg);
            }
            // ========== Sorting ==========
            // -- sort the sig shares by share index.  this is important when combining the shares.
            signatureShares.sort((a, b) => a.shareIndex - b.shareIndex);
            // ========== Combine Shares ==========
            const signature = (0, crypto_1.combineSignatureShares)(signatureShares.map((s) => s.signatureShare));
            (0, misc_1.log)('signature is', signature);
            const unsignedJwt = (0, misc_1.mostCommonString)(signatureShares.map((s) => s.unsignedJwt));
            // ========== Result ==========
            // convert the sig to base64 and append to the jwt
            const finalJwt = `${unsignedJwt}.${(0, uint8arrays_1.uint8arrayToString)((0, uint8arrays_1.uint8arrayFromString)(signature, 'base16'), 'base64urlpad')}`;
            return finalJwt;
        };
        _LitNodeClientNodeJs_decryptWithSignatureShares.set(this, (networkPubKey, identityParam, ciphertext, signatureShares) => {
            const sigShares = signatureShares.map((s) => s.signatureShare);
            return (0, crypto_1.verifyAndDecryptWithSignatureShares)(networkPubKey, identityParam, ciphertext, sigShares);
        });
        // ========== Promise Handlers ==========
        /**
         * Run lit action on a single deterministicly selected node. It's important that the nodes use the same deterministic selection algorithm.
         *
         * @param { ExecuteJsProps } params
         *
         * @returns { Promise<SuccessNodePromises<T> | RejectedNodePromises> }
         *
         */
        this.runOnTargetedNodes = async (params) => {
            const { code, authSig, jsParams, debug, sessionSigs, targetNodeRange } = params;
            (0, misc_1.log)('running runOnTargetedNodes:', targetNodeRange);
            if (!targetNodeRange) {
                return (0, misc_1.throwError)({
                    message: 'targetNodeRange is required',
                    errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                    errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
                });
            }
            // determine which node to run on
            let ipfsId;
            if (params.code) {
                // hash the code to get IPFS id
                const blockstore = new lit_third_party_libs_1.IPFSBundledSDK.MemoryBlockstore();
                let content = params.code;
                if (typeof content === 'string') {
                    content = new TextEncoder().encode(content);
                }
                else {
                    (0, misc_1.throwError)({
                        message: 'Invalid code content type for single node execution.  Your code param must be a string',
                        errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                        errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
                    });
                }
                let lastCid;
                for await (const { cid } of lit_third_party_libs_1.IPFSBundledSDK.importer([{ content }], blockstore, {
                    onlyHash: true,
                })) {
                    lastCid = cid;
                }
                ipfsId = lastCid;
            }
            else {
                ipfsId = params.ipfsId;
            }
            if (!ipfsId) {
                return (0, misc_1.throwError)({
                    message: 'ipfsId is required',
                    error: constants_1.LIT_ERROR.INVALID_PARAM_TYPE,
                });
            }
            // select targetNodeRange number of random index of the bootstrapUrls.length
            const randomSelectedNodeIndexes = [];
            let nodeCounter = 0;
            while (randomSelectedNodeIndexes.length < targetNodeRange) {
                const str = `${nodeCounter}:${ipfsId.toString()}`;
                const cidBuffer = Buffer.from(str);
                const hash = (0, utils_1.sha256)(cidBuffer);
                const hashAsNumber = ethers_1.BigNumber.from(hash);
                const nodeIndex = hashAsNumber
                    .mod(this.config.bootstrapUrls.length)
                    .toNumber();
                (0, misc_1.log)('nodeIndex:', nodeIndex);
                // must be unique & less than bootstrapUrls.length
                if (!randomSelectedNodeIndexes.includes(nodeIndex) &&
                    nodeIndex < this.config.bootstrapUrls.length) {
                    randomSelectedNodeIndexes.push(nodeIndex);
                }
                nodeCounter++;
            }
            (0, misc_1.log)('Final Selected Indexes:', randomSelectedNodeIndexes);
            const requestId = this.getRequestId();
            const nodePromises = [];
            for (let i = 0; i < randomSelectedNodeIndexes.length; i++) {
                // should we mix in the jsParams?  to do this, we need a canonical way to serialize the jsParams object that will be identical in rust.
                // const jsParams = params.jsParams || {};
                // const jsParamsString = JSON.stringify(jsParams);
                const nodeIndex = randomSelectedNodeIndexes[i];
                // FIXME: we are using this.config.bootstrapUrls to pick the selected node, but we
                // should be using something like the list of nodes from the staking contract
                // because the staking nodes can change, and the rust code will use the same list
                const url = this.config.bootstrapUrls[nodeIndex];
                (0, misc_1.log)(`running on node ${nodeIndex} at ${url}`);
                const reqBody = this.getLitActionRequestBody(params);
                // -- choose the right signature
                let sigToPassToNode = this.getAuthSigOrSessionAuthSig({
                    authSig,
                    sessionSigs,
                    url,
                });
                reqBody.authSig = sigToPassToNode;
                // this return { url: string, data: JsonRequest }
                let singleNodePromise = this.getJsExecutionShares(url, reqBody, requestId);
                nodePromises.push(singleNodePromise);
            }
            const handledPromise = await this.handleNodePromises(nodePromises, targetNodeRange);
            // -- handle response
            return handledPromise;
        };
        // ========== Shares Resolvers ==========
        this._getFlattenShare = (share) => {
            // flatten the signature object so that the properties of the signature are top level
            const flattenObj = Object.entries(share).map(([key, item]) => {
                if (item === null || item === undefined) {
                    return item;
                }
                const typedItem = item;
                const requiredProperties = ['sigType', 'dataSigned', 'signatureShare', 'shareIndex', 'bigR', 'publicKey', 'sigName'];
                if (requiredProperties.every(prop => typedItem[prop] !== undefined && typedItem[prop] !== null)) {
                    return item;
                }
            });
            // removed all null values and should only have one item
            const flattenShare = (flattenObj.filter(item => item !== null))[0];
            return flattenShare;
        };
        /**
         *
         * Get signatures from signed data
         *
         * @param { Array<any> } signedData
         *
         * @returns { any }
         *
         */
        this.getSessionSignatures = (signedData) => {
            // -- prepare
            let signatures = {};
            // TOOD: get keys of signedData
            const keys = Object.keys(signedData[0]);
            // -- execute
            keys.forEach((key) => {
                const shares = signedData.map((r) => r[key]);
                shares.sort((a, b) => a.shareIndex - b.shareIndex);
                const sigShares = shares.map((s) => {
                    const share = this._getFlattenShare(s);
                    return {
                        sigType: share.sigType,
                        signatureShare: share.signatureShare.replaceAll('"', ''),
                        shareIndex: share.shareIndex,
                        // @ts-ignore
                        bigR: share.bigR.replaceAll('"', ''),
                        publicKey: share.publicKey.replaceAll('"', ''),
                        dataSigned: share.dataSigned.replaceAll('"', ''),
                        siweMessage: share.siweMessage,
                    };
                });
                (0, misc_1.log)('getSessionSignatures - sigShares', sigShares);
                const sigType = (0, misc_1.mostCommonString)(sigShares.map((s) => s.sigType));
                // -- validate if this.networkPubKeySet is null
                if (this.networkPubKeySet === null) {
                    (0, misc_1.throwError)({
                        message: 'networkPubKeySet cannot be null',
                        errorKind: constants_1.LIT_ERROR.PARAM_NULL_ERROR.kind,
                        errorCode: constants_1.LIT_ERROR.PARAM_NULL_ERROR.name,
                    });
                    return;
                }
                // -- validate if signature type is ECDSA
                if (sigType !== 'ECDSA') {
                    (0, misc_1.throwError)({
                        message: 'signature type is not ECDSA',
                        errorKind: constants_1.LIT_ERROR.UNKNOWN_SIGNATURE_TYPE.kind,
                        errorCode: constants_1.LIT_ERROR.UNKNOWN_SIGNATURE_TYPE.name,
                    });
                    return;
                }
                let signature;
                if (sigType === constants_1.SIGTYPE.EcdsaCaitSith ||
                    sigType === constants_1.SIGTYPE.EcdsaCAITSITHP256) {
                    signature = (0, crypto_1.combineEcdsaShares)(sigShares);
                }
                const encodedSig = (0, utils_1.joinSignature)({
                    r: '0x' + signature.r,
                    s: '0x' + signature.s,
                    v: signature.recid,
                });
                signatures[key] = {
                    ...signature,
                    signature: encodedSig,
                    publicKey: (0, misc_1.mostCommonString)(sigShares.map((s) => s.publicKey)),
                    dataSigned: (0, misc_1.mostCommonString)(sigShares.map((s) => s.dataSigned)),
                    siweMessage: (0, misc_1.mostCommonString)(sigShares.map((s) => s.siweMessage)),
                };
            });
            return signatures;
        };
        /**
         *
         * Get signatures from signed data
         *
         * @param { Array<any> } signedData
         *
         * @returns { any }
         *
         */
        this.getSignatures = (signedData) => {
            // -- prepare
            let signatures = {};
            // TOOD: get keys of signedData
            const keys = Object.keys(signedData[0]);
            // -- execute
            keys.forEach((key) => {
                const shares = signedData.map((r) => r[key]);
                shares.sort((a, b) => a.shareIndex - b.shareIndex);
                const sigShares = shares.map((s) => {
                    const share = this._getFlattenShare(s);
                    return ({
                        sigType: share.sigType,
                        signatureShare: share.signatureShare.replaceAll('"', ''),
                        shareIndex: share.shareIndex,
                        // @ts-ignore
                        bigR: share.bigR.replaceAll('"', ''),
                        publicKey: share.publicKey.replaceAll('"', ''),
                        dataSigned: share.dataSigned.replaceAll('"', ''),
                        sigName: share.sigName ? share.sigName : 'sig',
                    });
                });
                (0, misc_1.log)('getSignatures - sigShares', sigShares);
                const sigType = (0, misc_1.mostCommonString)(sigShares.map((s) => s.sigType));
                // -- validate if this.networkPubKeySet is null
                if (this.networkPubKeySet === null) {
                    (0, misc_1.throwError)({
                        message: 'networkPubKeySet cannot be null',
                        errorKind: constants_1.LIT_ERROR.PARAM_NULL_ERROR.kind,
                        errorCode: constants_1.LIT_ERROR.PARAM_NULL_ERROR.name,
                    });
                    return;
                }
                // -- validate if signature type is ECDSA
                if (sigType !== constants_1.SIGTYPE.EcdsaCaitSith) {
                    (0, misc_1.throwError)({
                        message: 'signature type is not ECDSA',
                        errorKind: constants_1.LIT_ERROR.UNKNOWN_SIGNATURE_TYPE.kind,
                        errorCode: constants_1.LIT_ERROR.UNKNOWN_SIGNATURE_TYPE.name,
                    });
                    return;
                }
                let signature;
                if (sigType === constants_1.SIGTYPE.EcdsaCaitSith ||
                    sigType === constants_1.SIGTYPE.EcdsaCAITSITHP256) {
                    signature = (0, crypto_1.combineEcdsaShares)(sigShares);
                }
                const encodedSig = (0, utils_1.joinSignature)({
                    r: '0x' + signature.r,
                    s: '0x' + signature.s,
                    v: signature.recid,
                });
                signatures[key] = {
                    ...signature,
                    signature: encodedSig,
                    publicKey: (0, misc_1.mostCommonString)(sigShares.map((s) => s.publicKey)),
                    dataSigned: (0, misc_1.mostCommonString)(sigShares.map((s) => s.dataSigned)),
                };
            });
            return signatures;
        };
        /**
         *
         * Get a single signature
         *
         * @param { Array<any> } shareData from all node promises
         *
         * @returns { string } signature
         *
         */
        this.getSignature = async (shareData) => {
            // R_x & R_y values can come from any node (they will be different per node), and will generate a valid signature
            const R_x = shareData[0].local_x;
            const R_y = shareData[0].local_y;
            // the public key can come from any node - it obviously will be identical from each node
            const public_key = shareData[0].public_key;
            const valid_shares = shareData.map((s) => s.signature_share);
            const shares = JSON.stringify(valid_shares);
            await wasmECDSA.initWasmEcdsaSdk(); // init WASM
            const signature = wasmECDSA.combine_signature(R_x, R_y, shares);
            (0, misc_1.log)('raw ecdsa sig', signature);
            return signature;
        };
        // ========== Scoped Business Logics ==========
        /**
         *
         * Execute JS on the nodes and combine and return any resulting signatures
         *
         * @param { ExecuteJsRequest } params
         *
         * @returns { ExecuteJsResponse }
         *
         */
        this.executeJs = async (params) => {
            // ========== Prepare Params ==========
            const { code, ipfsId, authSig, jsParams, debug, sessionSigs, targetNodeRange, } = params;
            // ========== Validate Params ==========
            // -- validate: If it's NOT ready
            if (!this.ready) {
                const message = '1 LitNodeClient is not ready.  Please call await litNodeClient.connect() first.';
                (0, misc_1.throwError)({
                    message,
                    errorKind: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
                    errorCode: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name,
                });
            }
            const paramsIsSafe = (0, encryption_1.safeParams)({
                functionName: 'executeJs',
                params: params,
            });
            if (!paramsIsSafe) {
                return (0, misc_1.throwError)({
                    message: 'executeJs params are not valid',
                    errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                    errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
                });
            }
            let res;
            // -- only run on a single node
            if (targetNodeRange) {
                res = await this.runOnTargetedNodes(params);
            }
            else {
                // ========== Prepare Variables ==========
                // -- prepare request body
                const reqBody = this.getLitActionRequestBody(params);
                // ========== Get Node Promises ==========
                // -- fetch shares from nodes
                const requestId = this.getRequestId();
                const nodePromises = this.getNodePromises((url) => {
                    // -- choose the right signature
                    let sigToPassToNode = this.getAuthSigOrSessionAuthSig({
                        authSig,
                        sessionSigs,
                        url,
                    });
                    reqBody.authSig = sigToPassToNode;
                    return this.getJsExecutionShares(url, reqBody, requestId);
                });
                // -- resolve promises
                res = await this.handleNodePromises(nodePromises);
            }
            // -- case: promises rejected
            if (res.success === false) {
                this._throwNodeError(res);
            }
            // -- case: promises success (TODO: check the keys of "values")
            const responseData = res.values;
            (0, misc_1.log)('responseData', JSON.stringify(responseData, null, 2));
            // ========== Extract shares from response data ==========
            // -- 1. combine signed data as a list, and get the signatures from it
            const signedDataList = responseData.map((r) => {
                // add the signed data to the signature share
                delete r.signedData.result;
                // nodes do not camel case the response from /web/pkp/sign.
                const snakeToCamel = (s) => s.replace(/(_\w)/g, (k) => k[1].toUpperCase());
                //@ts-ignore
                const convertShare = (share) => {
                    const keys = Object.keys(share);
                    let convertedShare = {};
                    for (const key of keys) {
                        convertedShare = Object.defineProperty(convertedShare, snakeToCamel(key), Object.getOwnPropertyDescriptor(share, key));
                    }
                    return convertedShare;
                };
                const convertedShare = convertShare(r.signedData);
                const keys = Object.keys(convertedShare);
                for (const key of keys) {
                    //@ts-ignore
                    if (typeof convertedShare[key] === 'string') {
                        //@ts-ignore
                        convertedShare[key] = convertedShare[key]
                            .replace('"', '')
                            .replace('"', '');
                    }
                }
                //@ts-ignore
                convertedShare.dataSigned = convertedShare.digest;
                return {
                    signature: convertedShare,
                };
            });
            const signatures = this.getSignatures(signedDataList);
            // -- 2. combine responses as a string, and get parse it as JSON
            let response = (0, misc_1.mostCommonString)(responseData.map((r) => r.response));
            response = this.parseResponses(response);
            // -- 3. combine logs
            const mostCommonLogs = (0, misc_1.mostCommonString)(responseData.map((r) => r.logs));
            // ========== Result ==========
            let returnVal = {
                signatures,
                decryptions: [],
                response,
                logs: mostCommonLogs,
            };
            // -- case: debug mode
            if (debug) {
                const allNodeResponses = responseData.map((r) => r.response);
                const allNodeLogs = responseData.map((r) => r.logs);
                returnVal.debug = {
                    allNodeResponses,
                    allNodeLogs,
                    rawNodeHTTPResponses: responseData,
                };
            }
            return returnVal;
        };
        this.pkpSign = async (params) => {
            let { authSig, sessionSigs, toSign, pubKey, authMethods } = params;
            // the nodes will only accept a normal array type as a paramater due to serizalization issues with Uint8Array type.
            // this loop below is to normalize the message to a basic array.
            let arr = [];
            for (let i = 0; i < toSign.length; i++) {
                arr.push(toSign[i]);
            }
            toSign = arr;
            const requestId = this.getRequestId();
            const nodePromises = this.getNodePromises((url) => {
                // -- choose the right signature
                let sigToPassToNode = this.getAuthSigOrSessionAuthSig({
                    authSig,
                    sessionSigs,
                    url,
                });
                let reqBody = {
                    toSign,
                    pubkey: pubKey,
                    authSig: sigToPassToNode,
                    authMethods,
                };
                return this.getPkpSignExecutionShares(url, reqBody, requestId);
            });
            const res = await this.handleNodePromises(nodePromises);
            // -- case: promises rejected
            if (res.success === false) {
                this._throwNodeError(res);
            }
            // -- case: promises success (TODO: check the keys of "values")
            const responseData = res.values;
            (0, misc_1.log)('responseData', JSON.stringify(responseData, null, 2));
            // ========== Extract shares from response data ==========
            // -- 1. combine signed data as a list, and get the signatures from it
            const signedDataList = responseData.map((r) => {
                // add the signed data to the signature share
                delete r.signatureShare.result;
                // nodes do not camel case the response from /web/pkp/sign.
                const snakeToCamel = (s) => s.replace(/(_\w)/g, (k) => k[1].toUpperCase());
                //@ts-ignore
                const convertShare = (share) => {
                    const keys = Object.keys(share);
                    let convertedShare = {};
                    for (const key of keys) {
                        convertedShare = Object.defineProperty(convertedShare, snakeToCamel(key), Object.getOwnPropertyDescriptor(share, key));
                    }
                    return convertedShare;
                };
                const convertedShare = convertShare(r.signatureShare);
                const keys = Object.keys(convertedShare);
                for (const key of keys) {
                    //@ts-ignore
                    if (typeof convertedShare[key] === 'string') {
                        //@ts-ignore
                        convertedShare[key] = convertedShare[key]
                            .replace('"', '')
                            .replace('"', '');
                    }
                }
                //@ts-ignore
                convertedShare.dataSigned = convertedShare.digest;
                return {
                    signature: convertedShare,
                };
            });
            const signatures = this.getSignatures(signedDataList);
            (0, misc_1.log)(`signature combination`, signatures);
            return signatures.signature; // only a single signature is ever present, so we just return it.
        };
        /**
         *
         * Request a signed JWT from the LIT network. Before calling this function, you must know the access control conditions for the item you wish to gain authorization for.
         *
         * @param { GetSignedTokenRequest } params
         *
         * @returns { Promise<string> } final JWT
         *
         */
        this.getSignedToken = async (params) => {
            // ========== Prepare Params ==========
            const { chain, authSig, sessionSigs } = params;
            // ========== Validation ==========
            // -- validate if it's ready
            if (!this.ready) {
                const message = '3 LitNodeClient is not ready.  Please call await litNodeClient.connect() first.';
                (0, misc_1.throwError)({
                    message,
                    errorKind: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
                    errorCode: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name,
                });
            }
            // -- validate if this.networkPubKeySet is null
            if (this.networkPubKeySet === null) {
                return (0, misc_1.throwError)({
                    message: 'networkPubKeySet cannot be null',
                    errorKind: constants_1.LIT_ERROR.PARAM_NULL_ERROR.kind,
                    errorCode: constants_1.LIT_ERROR.PARAM_NULL_ERROR.name,
                });
            }
            const paramsIsSafe = (0, encryption_1.safeParams)({
                functionName: 'getSignedToken',
                params,
            });
            if (!paramsIsSafe) {
                return (0, misc_1.throwError)({
                    message: `Parameter validation failed.`,
                    errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                    errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
                });
            }
            // ========== Prepare ==========
            // we need to send jwt params iat (issued at) and exp (expiration)
            // because the nodes may have different wall clock times
            // the nodes will verify that these params are withing a grace period
            const { iat, exp } = this.getJWTParams();
            // ========== Formatting Access Control Conditions =========
            const { error, formattedAccessControlConditions, formattedEVMContractConditions, formattedSolRpcConditions, formattedUnifiedAccessControlConditions, } = this.getFormattedAccessControlConditions(params);
            if (error) {
                return (0, misc_1.throwError)({
                    message: `You must provide either accessControlConditions or evmContractConditions or solRpcConditions or unifiedAccessControlConditions`,
                    errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                    errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
                });
            }
            // ========== Get Node Promises ==========
            const requestId = this.getRequestId();
            const nodePromises = this.getNodePromises((url) => {
                // -- if session key is available, use it
                let authSigToSend = sessionSigs ? sessionSigs[url] : authSig;
                return this.getSigningShareForToken(url, {
                    accessControlConditions: formattedAccessControlConditions,
                    evmContractConditions: formattedEVMContractConditions,
                    solRpcConditions: formattedSolRpcConditions,
                    unifiedAccessControlConditions: formattedUnifiedAccessControlConditions,
                    chain,
                    authSig: authSigToSend,
                    iat,
                    exp,
                }, requestId);
            });
            // -- resolve promises
            const res = await this.handleNodePromises(nodePromises);
            // -- case: promises rejected
            if (res.success === false) {
                this._throwNodeError(res);
            }
            const signatureShares = res.values;
            (0, misc_1.log)('signatureShares', signatureShares);
            // ========== Result ==========
            const finalJwt = this.combineSharesAndGetJWT(signatureShares);
            return finalJwt;
        };
        /**
         *
         * Encrypt data using the LIT network public key.
         *
         */
        this.encrypt = async (params) => {
            // ========== Validate Params ==========
            // -- validate if it's ready
            if (!this.ready) {
                const message = '6 LitNodeClient is not ready.  Please call await litNodeClient.connect() first.';
                (0, misc_1.throwError)({
                    message,
                    errorKind: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
                    errorCode: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name,
                });
            }
            // -- validate if this.subnetPubKey is null
            if (!this.subnetPubKey) {
                const message = 'subnetPubKey cannot be null';
                return (0, misc_1.throwError)({
                    message,
                    errorKind: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
                    errorCode: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name,
                });
            }
            const paramsIsSafe = (0, encryption_1.safeParams)({
                functionName: 'encrypt',
                params,
            });
            if (!paramsIsSafe) {
                return (0, misc_1.throwError)({
                    message: `You must provide either accessControlConditions or evmContractConditions or solRpcConditions or unifiedAccessControlConditions`,
                    errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                    errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
                });
            }
            // ========== Hashing Access Control Conditions =========
            // hash the access control conditions
            let hashOfConditions = await this.getHashedAccessControlConditions(params);
            if (!hashOfConditions) {
                return (0, misc_1.throwError)({
                    message: `You must provide either accessControlConditions or evmContractConditions or solRpcConditions or unifiedAccessControlConditions`,
                    errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                    errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
                });
            }
            const hashOfConditionsStr = (0, uint8arrays_1.uint8arrayToString)(new Uint8Array(hashOfConditions), 'base16');
            // ========== Hashing Private Data ==========
            // hash the private data
            const hashOfPrivateData = await crypto.subtle.digest('SHA-256', params.dataToEncrypt);
            const hashOfPrivateDataStr = (0, uint8arrays_1.uint8arrayToString)(new Uint8Array(hashOfPrivateData), 'base16');
            // ========== Assemble identity parameter ==========
            const identityParam = tslib_1.__classPrivateFieldGet(this, _LitNodeClientNodeJs_getIdentityParamForEncryption, "f").call(this, hashOfConditionsStr, hashOfPrivateDataStr);
            // ========== Encrypt ==========
            const ciphertext = (0, crypto_1.encrypt)(this.subnetPubKey, params.dataToEncrypt, (0, uint8arrays_1.uint8arrayFromString)(identityParam, 'utf8'));
            return { ciphertext, dataToEncryptHash: hashOfPrivateDataStr };
        };
        /**
         *
         * Decrypt ciphertext with the LIT network.
         *
         */
        this.decrypt = async (params) => {
            const { authSig, sessionSigs, chain, ciphertext, dataToEncryptHash } = params;
            // ========== Validate Params ==========
            // -- validate if it's ready
            if (!this.ready) {
                const message = '6 LitNodeClient is not ready.  Please call await litNodeClient.connect() first.';
                (0, misc_1.throwError)({
                    message,
                    errorKind: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
                    errorCode: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name,
                });
            }
            // -- validate if this.subnetPubKey is null
            if (!this.subnetPubKey) {
                const message = 'subnetPubKey cannot be null';
                return (0, misc_1.throwError)({
                    message,
                    errorKind: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
                    errorCode: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name,
                });
            }
            const paramsIsSafe = (0, encryption_1.safeParams)({
                functionName: 'decrypt',
                params,
            });
            if (!paramsIsSafe) {
                return (0, misc_1.throwError)({
                    message: `Parameter validation failed.`,
                    errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                    errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
                });
            }
            // ========== Hashing Access Control Conditions =========
            // hash the access control conditions
            let hashOfConditions = await this.getHashedAccessControlConditions(params);
            if (!hashOfConditions) {
                return (0, misc_1.throwError)({
                    message: `You must provide either accessControlConditions or evmContractConditions or solRpcConditions or unifiedAccessControlConditions`,
                    errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                    errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
                });
            }
            const hashOfConditionsStr = (0, uint8arrays_1.uint8arrayToString)(new Uint8Array(hashOfConditions), 'base16');
            // ========== Formatting Access Control Conditions =========
            const { error, formattedAccessControlConditions, formattedEVMContractConditions, formattedSolRpcConditions, formattedUnifiedAccessControlConditions, } = this.getFormattedAccessControlConditions(params);
            if (error) {
                (0, misc_1.throwError)({
                    message: `You must provide either accessControlConditions or evmContractConditions or solRpcConditions or unifiedAccessControlConditions`,
                    errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                    errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
                });
            }
            // ========== Assemble identity parameter ==========
            const identityParam = tslib_1.__classPrivateFieldGet(this, _LitNodeClientNodeJs_getIdentityParamForEncryption, "f").call(this, hashOfConditionsStr, dataToEncryptHash);
            (0, misc_1.log)('identityParam', identityParam);
            // ========== Get Network Signature ==========
            const requestId = this.getRequestId();
            const nodePromises = this.getNodePromises((url) => {
                // -- if session key is available, use it
                let authSigToSend = sessionSigs ? sessionSigs[url] : authSig;
                return this.getSigningShareForDecryption(url, {
                    accessControlConditions: formattedAccessControlConditions,
                    evmContractConditions: formattedEVMContractConditions,
                    solRpcConditions: formattedSolRpcConditions,
                    unifiedAccessControlConditions: formattedUnifiedAccessControlConditions,
                    dataToEncryptHash,
                    chain,
                    authSig: authSigToSend,
                }, requestId);
            });
            // -- resolve promises
            const res = await this.handleNodePromises(nodePromises);
            // -- case: promises rejected
            if (res.success === false) {
                this._throwNodeError(res);
            }
            const signatureShares = res.values;
            (0, misc_1.log)('signatureShares', signatureShares);
            // ========== Result ==========
            const decryptedData = tslib_1.__classPrivateFieldGet(this, _LitNodeClientNodeJs_decryptWithSignatureShares, "f").call(this, this.subnetPubKey, (0, uint8arrays_1.uint8arrayFromString)(identityParam, 'utf8'), ciphertext, signatureShares);
            return { decryptedData };
        };
        this.getLitResourceForEncryption = async (params) => {
            // ========== Hashing Access Control Conditions =========
            // hash the access control conditions
            let hashOfConditions = await this.getHashedAccessControlConditions(params);
            if (!hashOfConditions) {
                return (0, misc_1.throwError)({
                    message: `You must provide either accessControlConditions or evmContractConditions or solRpcConditions or unifiedAccessControlConditions`,
                    errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                    errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
                });
            }
            const hashOfConditionsStr = (0, uint8arrays_1.uint8arrayToString)(new Uint8Array(hashOfConditions), 'base16');
            // ========== Hashing Private Data ==========
            // hash the private data
            const hashOfPrivateData = await crypto.subtle.digest('SHA-256', params.dataToEncrypt);
            const hashOfPrivateDataStr = (0, uint8arrays_1.uint8arrayToString)(new Uint8Array(hashOfPrivateData), 'base16');
            return new auth_helpers_1.LitAccessControlConditionResource(`${hashOfConditionsStr}/${hashOfPrivateDataStr}`);
        };
        _LitNodeClientNodeJs_getIdentityParamForEncryption.set(this, (hashOfConditionsStr, hashOfPrivateDataStr) => {
            return new auth_helpers_1.LitAccessControlConditionResource(`${hashOfConditionsStr}/${hashOfPrivateDataStr}`).getResourceKey();
        });
        /**
         *
         * Validates a condition, and then signs the condition if the validation returns true.
         * Before calling this function, you must know the on chain conditions that you wish to validate.
         *
         * @param { ValidateAndSignECDSA } params
         *
         * @returns { Promise<string> }
         */
        this.validateAndSignEcdsa = async (params) => {
            // ========== Validate Params ==========
            // -- validate if it's ready
            if (!this.ready) {
                const message = '7 LitNodeClient is not ready.  Please call await litNodeClient.connect() first.';
                (0, misc_1.throwError)({
                    message,
                    errorKind: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
                    errorCode: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name,
                });
            }
            // ========== Prepare Params ==========
            const { accessControlConditions, chain, auth_sig } = params;
            // ========== Prepare JWT Params ==========
            // we need to send jwt params iat (issued at) and exp (expiration)
            // because the nodes may have different wall clock times
            // the nodes will verify that these params are withing a grace period
            const { iat, exp } = this.getJWTParams();
            // -- validate
            if (!accessControlConditions) {
                return (0, misc_1.throwError)({
                    message: `You must provide either accessControlConditions or evmContractConditions or solRpcConditions`,
                    errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                    errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
                });
            }
            // -- formatted access control conditions
            let formattedAccessControlConditions;
            formattedAccessControlConditions = accessControlConditions.map((c) => (0, access_control_conditions_1.canonicalAccessControlConditionFormatter)(c));
            (0, misc_1.log)('formattedAccessControlConditions', JSON.stringify(formattedAccessControlConditions));
            // ========== Node Promises ==========
            const requestId = this.getRequestId();
            const nodePromises = this.getNodePromises((url) => {
                return this.signConditionEcdsa(url, {
                    accessControlConditions: formattedAccessControlConditions,
                    evmContractConditions: undefined,
                    solRpcConditions: undefined,
                    auth_sig,
                    chain,
                    iat,
                    exp,
                }, requestId);
            });
            // ----- Resolve Promises -----
            try {
                const shareData = await Promise.all(nodePromises);
                if (shareData[0].result == 'failure')
                    return 'Condition Failed';
                const signature = this.getSignature(shareData);
                return signature;
            }
            catch (e) {
                (0, misc_1.log)('Error - signed_ecdsa_messages - ', e);
                const signed_ecdsa_message = nodePromises[0];
                return signed_ecdsa_message;
            }
        };
        /** ============================== SESSION ============================== */
        /**
         * Sign a session public key using a PKP, which generates an authSig.
         * @returns {Object} An object containing the resulting signature.
         */
        this.signSessionKey = async (params) => {
            // ========== Validate Params ==========
            // -- validate: If it's NOT ready
            if (!this.ready) {
                const message = '8 LitNodeClient is not ready.  Please call await litNodeClient.connect() first.';
                (0, misc_1.throwError)({
                    message,
                    errorKind: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
                    errorCode: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name,
                });
            }
            // -- construct SIWE message that will be signed by node to generate an authSig.
            const _expiration = params.expiration ||
                new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString();
            // Try to get it from local storage, if not generates one~
            let sessionKey = params.sessionKey ?? this.getSessionKey();
            let sessionKeyUri = constants_1.LIT_SESSION_KEY_URI + sessionKey.publicKey;
            // Compute the address from the public key if it's provided. Otherwise, the node will compute it.
            const pkpEthAddress = (function () {
                if (params.pkpPublicKey)
                    return (0, transactions_1.computeAddress)(params.pkpPublicKey);
                // This will be populated by the node, using dummy value for now.
                return '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2';
            })();
            let siwe_statement = 'Lit Protocol PKP session signature';
            if (!!params.statement) {
                siwe_statement += ' ' + params.statement;
            }
            let siweMessage = new lit_siwe_1.SiweMessage({
                domain: params?.domain || globalThis.location?.host || 'litprotocol.com',
                address: pkpEthAddress,
                statement: siwe_statement,
                uri: sessionKeyUri,
                version: '1',
                chainId: params.chainId ?? 1,
                expirationTime: _expiration,
                resources: params.resources,
            });
            let siweMessageStr = siweMessage.prepareMessage();
            // ========== Get Node Promises ==========
            // -- fetch shares from nodes
            const requestId = this.getRequestId();
            const nodePromises = this.getNodePromises((url) => {
                return this.getSignSessionKeyShares(url, {
                    body: {
                        sessionKey: sessionKeyUri,
                        authMethods: params.authMethods,
                        pkpPublicKey: params.pkpPublicKey,
                        authSig: params.authSig,
                        siweMessage: siweMessageStr,
                    },
                }, requestId);
            });
            // -- resolve promises
            const res = await this.handleNodePromises(nodePromises);
            // -- case: promises rejected
            if (!tslib_1.__classPrivateFieldGet(this, _LitNodeClientNodeJs_isSuccessNodePromises, "f").call(this, res)) {
                this._throwNodeError(res);
                return {};
            }
            const responseData = res.values;
            (0, misc_1.log)('responseData', JSON.stringify(responseData, null, 2));
            // ========== Extract shares from response data ==========
            // -- 1. combine signed data as a list, and get the signatures from it
            const signedDataList = responseData.map((r) => r.signedData);
            const signatures = this.getSessionSignatures(signedDataList);
            const { sessionSig } = signatures;
            return {
                authSig: {
                    sig: sessionSig.signature,
                    derivedVia: 'web3.eth.personal.sign via Lit PKP',
                    signedMessage: sessionSig.siweMessage,
                    address: (0, transactions_1.computeAddress)('0x' + sessionSig.publicKey),
                },
                pkpPublicKey: sessionSig.publicKey,
            };
        };
        _LitNodeClientNodeJs_isSuccessNodePromises.set(this, (res) => {
            return res.success === true;
        });
        this.getSignSessionKeyShares = async (url, params, requestId) => {
            (0, misc_1.log)('getSignSessionKeyShares');
            const urlWithPath = `${url}/web/sign_session_key`;
            return await this.sendCommandToNode({
                url: urlWithPath,
                data: params.body,
                requestId,
            });
        };
        this.generateAuthMethodForWebAuthn = (params) => ({
            authMethodType: constants_1.AUTH_METHOD_TYPE_IDS.WEBAUTHN,
            accessToken: JSON.stringify(params),
        });
        this.generateAuthMethodForDiscord = (access_token) => ({
            authMethodType: constants_1.AUTH_METHOD_TYPE_IDS.DISCORD,
            accessToken: access_token,
        });
        this.generateAuthMethodForGoogle = (access_token) => ({
            authMethodType: constants_1.AUTH_METHOD_TYPE_IDS.GOOGLE,
            accessToken: access_token,
        });
        this.generateAuthMethodForGoogleJWT = (access_token) => ({
            authMethodType: constants_1.AUTH_METHOD_TYPE_IDS.GOOGLE_JWT,
            accessToken: access_token,
        });
        /**
         * Get session signatures for a set of resources
         *
         * High level, how this works:
         * 1. Generate or retrieve session key
         * 2. Generate or retrieve the wallet signature of the session key
         * 3. Sign the specific resources with the session key
         *
         * Note: When generating session signatures for different PKPs or auth methods,
         * be sure to call disconnectWeb3 to clear auth signatures stored in local storage
         *
         * @param { GetSessionSigsProps } params
         */
        this.getSessionSigs = async (params) => {
            // -- prepare
            // Try to get it from local storage, if not generates one~
            let sessionKey = params.sessionKey ?? this.getSessionKey();
            let sessionKeyUri = this.getSessionKeyUri(sessionKey.publicKey);
            // First get or generate the session capability object for the specified resources.
            const sessionCapabilityObject = params.sessionCapabilityObject
                ? params.sessionCapabilityObject
                : this.generateSessionCapabilityObjectWithWildcards(params.resourceAbilityRequests.map((r) => r.resource));
            let expiration = params.expiration || this.getExpiration();
            // -- (TRY) to get the wallet signature
            let authSig = await this.getWalletSig({
                authNeededCallback: params.authNeededCallback,
                chain: params.chain,
                sessionCapabilityObject,
                switchChain: params.switchChain,
                expiration: expiration,
                sessionKeyUri: sessionKeyUri,
            });
            let needToResignSessionKey = await this.checkNeedToResignSessionKey({
                authSig,
                sessionKeyUri,
                resourceAbilityRequests: params.resourceAbilityRequests,
            });
            // -- (CHECK) if we need to resign the session key
            if (needToResignSessionKey) {
                (0, misc_1.log)('need to re-sign session key.  Signing...');
                authSig = await tslib_1.__classPrivateFieldGet(this, _LitNodeClientNodeJs_authCallbackAndUpdateStorageItem, "f").call(this, {
                    authCallback: params.authNeededCallback,
                    authCallbackParams: {
                        chain: params.chain,
                        statement: sessionCapabilityObject.statement,
                        resources: [sessionCapabilityObject.encodeAsSiweResource()],
                        switchChain: params.switchChain,
                        expiration,
                        uri: sessionKeyUri,
                    },
                });
            }
            if (authSig.address === '' ||
                authSig.derivedVia === '' ||
                authSig.sig === '' ||
                authSig.signedMessage === '') {
                (0, misc_1.throwError)({
                    message: 'No wallet signature found',
                    errorKind: constants_1.LIT_ERROR.WALLET_SIGNATURE_NOT_FOUND_ERROR.kind,
                    errorCode: constants_1.LIT_ERROR.WALLET_SIGNATURE_NOT_FOUND_ERROR.name,
                });
                // @ts-ignore - we throw an error above, so below should never be reached
                return;
            }
            // ===== AFTER we have Valid Signed Session Key =====
            // - Let's sign the resources with the session key
            // - 5 minutes is the default expiration for a session signature
            // - Because we can generate a new session sig every time the user wants to access a resource without prompting them to sign with their wallet
            let sessionExpiration = new Date(Date.now() + 1000 * 60 * 5);
            const signingTemplate = {
                sessionKey: sessionKey.publicKey,
                resourceAbilityRequests: params.resourceAbilityRequests,
                capabilities: [authSig],
                issuedAt: new Date().toISOString(),
                expiration: sessionExpiration.toISOString(),
            };
            const signatures = {};
            this.connectedNodes.forEach((nodeAddress) => {
                const toSign = {
                    ...signingTemplate,
                    nodeAddress,
                };
                let signedMessage = JSON.stringify(toSign);
                const uint8arrayKey = (0, uint8arrays_1.uint8arrayFromString)(sessionKey.secretKey, 'base16');
                const uint8arrayMessage = (0, uint8arrays_1.uint8arrayFromString)(signedMessage, 'utf8');
                let signature = nacl_1.nacl.sign.detached(uint8arrayMessage, uint8arrayKey);
                // log("signature", signature);
                signatures[nodeAddress] = {
                    sig: (0, uint8arrays_1.uint8arrayToString)(signature, 'base16'),
                    derivedVia: 'litSessionSignViaNacl',
                    signedMessage,
                    address: sessionKey.publicKey,
                    algo: 'ed25519',
                };
            });
            (0, misc_1.log)('signatures:', signatures);
            return signatures;
        };
        /**
         *
         * Get Session Key URI eg. lit:session:0x1234
         *
         * @param publicKey is the public key of the session key
         * @returns { string } the session key uri
         */
        this.getSessionKeyUri = (publicKey) => {
            return constants_1.LIT_SESSION_KEY_URI + publicKey;
        };
        // -- initialize default auth callback
        this.defaultAuthCallback = args?.defaultAuthCallback;
    }
    /**
     * Check if a given object is of type SessionKeyPair.
     *
     * @param obj - The object to check.
     * @returns True if the object is of type SessionKeyPair.
     */
    isSessionKeyPair(obj) {
        return (typeof obj === 'object' &&
            'publicKey' in obj &&
            'secretKey' in obj &&
            typeof obj.publicKey === 'string' &&
            typeof obj.secretKey === 'string');
    }
    /**
     * Authenticates an Auth Method for claiming a Programmable Key Pair (PKP).
     * A {@link MintCallback} can be defined for custom on chain interactions
     * by default the callback will forward to a relay server for minting on chain.
     * @param {ClaimKeyRequest} params an Auth Method and {@link MintCallback}
     * @returns {Promise<ClaimKeyResponse>}
     */
    async claimKeyId(params) {
        if (!this.ready) {
            const message = 'LitNodeClient is not ready.  Please call await litNodeClient.connect() first.';
            (0, misc_1.throwError)({
                message,
                errorKind: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
                errorCode: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name,
            });
        }
        if (params.authMethod.authMethodType === constants_1.AuthMethodType.LitAction) {
            (0, misc_1.throwError)({
                message: 'Unsupported auth method type. Webauthn, and Lit Actions are not supported for claiming',
                errorKind: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
                errorCode: constants_1.LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name,
            });
        }
        const nodePromises = await this.getNodePromises((url) => {
            const requestId = this.getRequestId();
            const nodeRequestParams = {
                authMethod: params.authMethod,
            };
            return this.getClaimKeyExecutionShares(url, nodeRequestParams, requestId);
        });
        const responseData = await this.handleNodePromises(nodePromises);
        if (responseData.success === true) {
            const nodeSignatures = responseData.values.map((r) => {
                let sig = ethers_1.ethers.utils.splitSignature(`0x${r.signature}`);
                return {
                    r: sig.r,
                    s: sig.s,
                    v: sig.v,
                };
            });
            const derivedKeyId = responseData.values[0]
                .derivedKeyId;
            const pubkey = this.computeHDPubKey(derivedKeyId);
            let mintTx = '';
            if (params.mintCallback) {
                mintTx = await params.mintCallback({
                    derivedKeyId,
                    authMethodType: params.authMethod.authMethodType,
                    signatures: nodeSignatures,
                    pubkey,
                    signer: params.signer,
                    relayUrl: params.relayUrl,
                    relayApiKey: params.relayApiKey,
                });
            }
            mintTx = await (0, misc_1.defaultMintClaimCallback)({
                derivedKeyId,
                authMethodType: params.authMethod.authMethodType,
                signatures: nodeSignatures,
                pubkey,
            });
            return {
                signatures: nodeSignatures,
                claimedKeyId: derivedKeyId,
                pubkey,
                mintTx,
            };
        }
        else {
            return (0, misc_1.throwError)({
                message: 'claim request has failed',
                errorKind: constants_1.LIT_ERROR.UNKNOWN_ERROR.kind,
                errorCode: constants_1.LIT_ERROR.UNKNOWN_ERROR.code,
            });
        }
    }
}
exports.LitNodeClientNodeJs = LitNodeClientNodeJs;
_LitNodeClientNodeJs_authCallbackAndUpdateStorageItem = new WeakMap(), _LitNodeClientNodeJs_decryptWithSignatureShares = new WeakMap(), _LitNodeClientNodeJs_getIdentityParamForEncryption = new WeakMap(), _LitNodeClientNodeJs_isSuccessNodePromises = new WeakMap();
//# sourceMappingURL=lit-node-client-nodejs.js.map